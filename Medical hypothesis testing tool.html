<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foundation Series: Hypothesis Testing in Medicine & Clinical Research</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f8fffe;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #20b2aa;
        }
        h1 {
            color: #dc143c;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        h2 {
            color: #dc143c;
            border-bottom: 3px solid #dc143c;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        h3 {
            color: #2f8b8b;
            margin-top: 25px;
        }
        .subtitle {
            text-align: center;
            color: #2f8b8b;
            font-size: 1.1em;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .foundation-badge {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            text-align: center;
            margin: 20px auto;
            display: inline-block;
            font-size: 0.9em;
        }
        .section {
            background: #f0ffff;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #2f8b8b;
        }
        .concept-intro {
            background: linear-gradient(to right, #e6f3ff, #f0f8ff);
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #4169e1;
            border-left: 6px solid #4169e1;
        }
        .concept {
            background: #e8fffe;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #20b2aa;
        }
        .controls {
            background: #f8ffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #20b2aa;
        }
        button {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .results {
            background: #ffffff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .chart-container {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #20b2aa;
            height: 400px;
            position: relative;
        }
        select, input {
            padding: 8px;
            margin: 5px;
            border: 2px solid #20b2aa;
            border-radius: 4px;
            background: white;
        }
        .formula {
            background: #f0f8ff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #2f8b8b;
            font-size: 0.95em;
        }
        .key-concept {
            background: #fff5ee;
            border: 2px solid #ff6347;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 6px solid #ff6347;
        }
        .clinical-context {
            background: linear-gradient(to right, #ffe8e8, #fff0f0);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .regulatory-box {
            background: linear-gradient(to right, #f0f8ff, #e6f3ff);
            border: 2px solid #4169e1;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .navigation {
            background: #e8fffe;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            border: 1px solid #20b2aa;
        }
        .nav-button {
            background: #2f8b8b;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .nav-button:hover {
            background: #20b2aa;
        }
        .section-content {
            display: none;
        }
        .section-content.active {
            display: block;
        }
        .power-visual {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #20b2aa;
            padding: 8px;
            text-align: left;
        }
        th {
            background: #2f8b8b;
            color: white;
        }
        tr:nth-child(even) {
            background: #f8fffe;
        }
        .highlight {
            background: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .assessment {
            background: linear-gradient(to right, #f0ffff, #e8fffe);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .question {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #20b2aa;
        }
        .when-to-use {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .assumptions-box {
            background: #fff8e1;
            border: 2px solid #ffa726;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Foundation Series: Hypothesis Testing in Medicine & Clinical Research</h1>
        <div class="subtitle">Statistical Inference for Evidence-Based Healthcare</div>
        
        <div class="foundation-badge">üî¨ FOUNDATION SERIES: From Research Questions to Statistical Evidence</div>

        <div class="navigation">
            <h3>Navigate Hypothesis Testing Foundations</h3>
            <button class="nav-button" onclick="showSection('framework')">Hypothesis Framework</button>
            <button class="nav-button" onclick="showSection('errors')">Errors & Power</button>
            <button class="nav-button" onclick="showSection('pvalues')">P-values & Significance</button>
            <button class="nav-button" onclick="showSection('means')">Comparing Means</button>
            <button class="nav-button" onclick="showSection('categorical')">Categorical Data</button>
            <button class="nav-button" onclick="showSection('nonparametric')">Non-parametric Tests</button>
            <button class="nav-button" onclick="showSection('diagnostic')">Diagnostic Tests</button>
            <button class="nav-button" onclick="showSection('equivalence')">Equivalence Testing</button>
            <button class="nav-button" onclick="showSection('survival')">Survival Analysis Intro</button>
            <button class="nav-button" onclick="showSection('assessment')">Assessment</button>
        </div>

        <!-- Section 1: Hypothesis Testing Framework -->
        <div id="framework-section" class="section-content active">
            <div class="section">
                <h2>üéØ Hypothesis Testing Framework in Clinical Research</h2>
                
                <div class="concept-intro">
                    <h3>üìö What is Hypothesis Testing?</h3>
                    <p><strong>Hypothesis testing is the statistical method used to make decisions about populations based on sample data.</strong> In clinical research, it helps us answer questions like "Does this new treatment work better than standard care?" or "Is there a relationship between smoking and lung disease?"</p>
                    
                    <p><strong>Why it matters in healthcare:</strong> Medical decisions affect lives, so we need rigorous statistical evidence to distinguish real treatment effects from random chance. Hypothesis testing provides the framework for making these evidence-based decisions.</p>
                </div>

                <div class="concept">
                    <h3>Formulating Hypotheses: The Foundation of Scientific Inquiry</h3>
                    
                    <div class="key-concept">
                        <h4>üîç Key Concepts:</h4>
                        <p><strong>Null Hypothesis (H‚ÇÄ):</strong> "No effect" or "no difference" - what we assume is true unless proven otherwise</p>
                        <p><strong>Alternative Hypothesis (H‚ÇÅ or H‚Çê):</strong> What we want to demonstrate - the research claim</p>
                        <p><strong>PICO Framework:</strong> Patient/Population, Intervention, Comparison, Outcome - structures clinical questions</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Clinical Research Example:</h4>
                        <p><strong>Research Question:</strong> "Does the new antihypertensive drug reduce blood pressure more than standard treatment?"</p>
                        <p><strong>H‚ÇÄ:</strong> Œº_new - Œº_standard = 0 (no difference in mean blood pressure reduction)</p>
                        <p><strong>H‚ÇÅ:</strong> Œº_new - Œº_standard ‚â† 0 (there is a difference in mean reduction)</p>
                    </div>

                    <div class="formula">
                        PICO Framework Application:
                        <br>P: Patients with hypertension (systolic BP >140 mmHg)
                        <br>I: New antihypertensive drug (intervention)
                        <br>C: Current standard treatment (control)
                        <br>O: Reduction in systolic blood pressure (outcome)
                    </div>

                    <div class="controls">
                        <h4>Interactive Hypothesis Builder</h4>
                        <label>Research Area: 
                            <select id="research-area">
                                <option value="treatment">Treatment Effectiveness</option>
                                <option value="diagnosis">Diagnostic Accuracy</option>
                                <option value="prevention">Disease Prevention</option>
                                <option value="risk-factor">Risk Factor Association</option>
                            </select>
                        </label><br>
                        <label>Study Design: 
                            <select id="study-design">
                                <option value="rct">Randomized Controlled Trial</option>
                                <option value="cohort">Cohort Study</option>
                                <option value="case-control">Case-Control Study</option>
                                <option value="cross-sectional">Cross-sectional Study</option>
                            </select>
                        </label><br>
                        <label>Test Type: 
                            <select id="test-type">
                                <option value="two-sided">Two-sided (‚â†)</option>
                                <option value="one-sided-greater">One-sided (>)</option>
                                <option value="one-sided-less">One-sided (<)</option>
                            </select>
                        </label><br>
                        <button onclick="buildHypothesis()">Build Hypothesis Statement</button>
                    </div>

                    <div id="framework-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="when-to-use">
                        <h4>üí° When to Use One-sided vs Two-sided Tests:</h4>
                        <p><strong>Two-sided:</strong> Most common - we don't know direction of effect (drug could help or harm)</p>
                        <p><strong>One-sided:</strong> When direction is predetermined (safety studies, non-inferiority trials)</p>
                        <p><strong>Regulatory note:</strong> Health Canada generally requires two-sided tests unless strong scientific rationale</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 2: Statistical Errors & Power -->
        <div id="errors-section" class="section-content">
            <div class="section">
                <h2>‚öñÔ∏è Statistical Errors & Power Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Understanding Statistical Errors</h3>
                    <p><strong>Statistical errors are inevitable in hypothesis testing because we're making decisions about populations based on samples.</strong> Understanding these errors is crucial for designing studies and interpreting results responsibly.</p>
                    
                    <p><strong>Why it matters in healthcare:</strong> Type I errors can lead to approving ineffective treatments, while Type II errors can prevent beneficial treatments from reaching patients. Both have serious consequences for public health.</p>
                </div>

                <div class="concept">
                    <h3>Types of Statistical Errors & Their Clinical Consequences</h3>
                    
                    <div class="key-concept">
                        <h4>üö® Error Types:</h4>
                        <p><strong>Type I Error (Œ±):</strong> Rejecting a true null hypothesis - "false positive"</p>
                        <p><strong>Type II Error (Œ≤):</strong> Failing to reject a false null hypothesis - "false negative"</p>
                        <p><strong>Statistical Power (1-Œ≤):</strong> Probability of correctly rejecting a false null hypothesis</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Clinical Consequences:</h4>
                        <p><strong>Type I Error in Drug Trials:</strong> Approving an ineffective drug ‚Üí Patients get false hope, healthcare costs increase, delay in finding real treatments</p>
                        <p><strong>Type II Error in Drug Trials:</strong> Missing an effective treatment ‚Üí Patients continue to suffer, beneficial therapy delayed</p>
                    </div>

                    <table style="margin: 15px 0;">
                        <tr><th>Reality \ Decision</th><th>Reject H‚ÇÄ</th><th>Fail to Reject H‚ÇÄ</th></tr>
                        <tr><td>H‚ÇÄ is True</td><td style="background: #ffe8e8;">Type I Error (Œ±)</td><td style="background: #e8ffe8;">Correct Decision</td></tr>
                        <tr><td>H‚ÇÄ is False</td><td style="background: #e8ffe8;">Correct Decision (Power)</td><td style="background: #ffe8e8;">Type II Error (Œ≤)</td></tr>
                    </table>

                    <div class="controls">
                        <h4>Interactive Power Analysis Calculator</h4>
                        <label>Effect Size (Cohen's d): <input type="number" id="effect-size" value="0.5" min="0.1" max="2.0" step="0.1"></label><br>
                        <label>Sample Size per Group: <input type="number" id="sample-size" value="50" min="10" max="200" step="5"></label><br>
                        <label>Significance Level (Œ±): <input type="number" id="alpha-level" value="0.05" min="0.01" max="0.10" step="0.01"></label><br>
                        <label>Clinical Context: 
                            <select id="clinical-context">
                                <option value="efficacy">Drug Efficacy Trial</option>
                                <option value="safety">Safety Study</option>
                                <option value="bioequivalence">Bioequivalence Study</option>
                                <option value="screening">Screening Test</option>
                            </select>
                        </label><br>
                        <button onclick="calculatePower()">Calculate Power & Sample Size</button>
                    </div>

                    <div id="errors-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="power-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Health Canada Guidelines:</h4>
                        <p>‚Ä¢ Standard significance level: Œ± = 0.05 (two-sided)</p>
                        <p>‚Ä¢ Minimum power requirement: 80% for pivotal trials</p>
                        <p>‚Ä¢ Sample size justification required in protocols</p>
                        <p>‚Ä¢ Interim analysis adjustments for multiple looks</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: P-values & Statistical Significance -->
        <div id="pvalues-section" class="section-content">
            <div class="section">
                <h2>üìä P-values & Statistical Significance</h2>
                
                <div class="concept-intro">
                    <h3>üìö Understanding P-values</h3>
                    <p><strong>A p-value is the probability of observing data as extreme or more extreme than what we observed, assuming the null hypothesis is true.</strong> It's NOT the probability that the null hypothesis is true, or that the results occurred by chance.</p>
                    
                    <p><strong>Why proper interpretation matters:</strong> Misunderstanding p-values leads to poor clinical decisions. P-values don't measure effect size, clinical importance, or the probability that a treatment works.</p>
                </div>

                <div class="concept">
                    <h3>P-value Interpretation & Multiple Testing</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Correct P-value Interpretation:</h4>
                        <p><strong>p < 0.05 means:</strong> If the null hypothesis were true, we'd see data this extreme or more extreme less than 5% of the time</p>
                        <p><strong>p < 0.05 does NOT mean:</strong> The null hypothesis has only 5% chance of being true, or the result has 95% chance of being "real"</p>
                        <p><strong>Clinical vs Statistical Significance:</strong> A tiny, clinically meaningless difference can be statistically significant with large samples</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Multiple Testing Problem:</h4>
                        <p><strong>The Problem:</strong> Testing multiple endpoints increases chance of false positive findings</p>
                        <p><strong>Example:</strong> Testing 20 safety parameters at Œ±=0.05 ‚Üí Expected 1 false positive even if drug is completely safe</p>
                        <p><strong>Solutions:</strong> Bonferroni correction, False Discovery Rate (FDR), pre-specified primary endpoints</p>
                    </div>

                    <div class="formula">
                        Multiple Testing Corrections:
                        <br>Bonferroni: Œ±_adjusted = Œ± / number_of_tests
                        <br>Holm-Bonferroni: Sequential adjustment starting with smallest p-value
                        <br>FDR (Benjamini-Hochberg): Controls proportion of false discoveries
                    </div>

                    <div class="controls">
                        <h4>P-value Simulation & Multiple Testing</h4>
                        <label>Number of Comparisons: <input type="number" id="num-comparisons" value="10" min="1" max="50" step="1"></label><br>
                        <label>True Effect Present: 
                            <select id="true-effect">
                                <option value="none">No Real Effects (All H‚ÇÄ True)</option>
                                <option value="some">Some Real Effects (Mixed)</option>
                                <option value="all">All Real Effects (All H‚ÇÄ False)</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Test: <input type="number" id="pvalue-sample" value="100" min="20" max="500" step="20"></label><br>
                        <label>Correction Method: 
                            <select id="correction-method">
                                <option value="none">No Correction</option>
                                <option value="bonferroni">Bonferroni</option>
                                <option value="holm">Holm-Bonferroni</option>
                                <option value="fdr">False Discovery Rate</option>
                            </select>
                        </label><br>
                        <button onclick="simulateMultipleTesting()">Simulate Multiple Testing</button>
                    </div>

                    <div id="pvalues-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="pvalue-chart"></canvas>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è P-hacking Prevention:</h4>
                        <p>‚Ä¢ Pre-register primary hypotheses and analysis plans</p>
                        <p>‚Ä¢ Distinguish exploratory vs confirmatory analyses</p>
                        <p>‚Ä¢ Report all tested comparisons, not just significant ones</p>
                        <p>‚Ä¢ Use appropriate multiple testing corrections</p>
                        <p>‚Ä¢ Focus on effect sizes and confidence intervals alongside p-values</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Comparing Means -->
        <div id="means-section" class="section-content">
            <div class="section">
                <h2>üìà Comparing Means in Clinical Research</h2>
                
                <div class="concept-intro">
                    <h3>üìö When Do We Compare Means?</h3>
                    <p><strong>Comparing means is fundamental in clinical research when our outcome is continuous</strong> (blood pressure, cholesterol levels, quality of life scores, biomarker concentrations). We use different tests depending on study design and data characteristics.</p>
                    
                    <p><strong>Clinical applications:</strong> Drug efficacy trials comparing treatment groups, before/after treatment analysis, dose-response studies, multi-center trials with site effects.</p>
                </div>

                <div class="concept">
                    <h3>t-Tests and ANOVA for Clinical Data</h3>
                    
                    <div class="key-concept">
                        <h4>üî¨ Test Selection Guide:</h4>
                        <p><strong>One-sample t-test:</strong> Compare sample mean to known standard (e.g., normal lab values)</p>
                        <p><strong>Two-sample t-test:</strong> Compare two independent groups (treatment vs control)</p>
                        <p><strong>Paired t-test:</strong> Compare before/after measurements on same patients</p>
                        <p><strong>ANOVA:</strong> Compare three or more groups simultaneously</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è Assumptions for t-tests:</h4>
                        <p>‚Ä¢ <strong>Normality:</strong> Data approximately normally distributed (or large sample)</p>
                        <p>‚Ä¢ <strong>Independence:</strong> Observations independent of each other</p>
                        <p>‚Ä¢ <strong>Equal variances:</strong> Similar variability in both groups (for two-sample)</p>
                        <p>‚Ä¢ <strong>What if violated?</strong> Use non-parametric alternatives or data transformations</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Canadian Clinical Trial Example:</h4>
                        <p><strong>Study:</strong> Health Canada-approved diabetes medication trial across 5 Canadian centers</p>
                        <p><strong>Design:</strong> Randomized, double-blind, placebo-controlled</p>
                        <p><strong>Primary outcome:</strong> Change in HbA1c from baseline to 12 weeks</p>
                        <p><strong>Analysis:</strong> Two-sample t-test comparing mean change between groups</p>
                    </div>

                    <div class="controls">
                        <h4>Interactive Clinical Trial Analyzer</h4>
                        <label>Study Type: 
                            <select id="study-type">
                                <option value="independent">Two Independent Groups</option>
                                <option value="paired">Before/After (Paired)</option>
                                <option value="anova">Multiple Groups (ANOVA)</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="means-sample-size" value="80" min="20" max="200" step="10"></label><br>
                        <label>Expected Effect Size: <input type="number" id="means-effect" value="0.5" min="0.1" max="1.5" step="0.1"></label><br>
                        <label>Clinical Outcome: 
                            <select id="clinical-outcome">
                                <option value="hba1c">HbA1c Change (%)</option>
                                <option value="bp">Blood Pressure (mmHg)</option>
                                <option value="cholesterol">LDL Cholesterol (mg/dL)</option>
                                <option value="pain">Pain Score (0-10)</option>
                            </select>
                        </label><br>
                        <button onclick="simulateMeansTest()">Simulate Clinical Trial</button>
                    </div>

                    <div id="means-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="means-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Regulatory Considerations:</h4>
                        <p>‚Ä¢ <strong>Primary endpoint:</strong> Must be pre-specified and clinically meaningful</p>
                        <p>‚Ä¢ <strong>Minimal clinically important difference:</strong> Define before study start</p>
                        <p>‚Ä¢ <strong>Missing data handling:</strong> Intent-to-treat vs per-protocol analysis</p>
                        <p>‚Ä¢ <strong>Non-inferiority margins:</strong> Must be justified if testing non-inferiority</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 5: Categorical Data Analysis -->
        <div id="categorical-section" class="section-content">
            <div class="section">
                <h2>üìã Categorical Data Analysis in Healthcare</h2>
                
                <div class="concept-intro">
                    <h3>üìö Working with Categorical Outcomes</h3>
                    <p><strong>Many medical outcomes are categorical rather than continuous</strong> - cure/no cure, adverse event/no event, disease/no disease, treatment response categories. These require different statistical approaches than continuous data.</p>
                    
                    <p><strong>Clinical importance:</strong> Safety analysis (counting adverse events), efficacy studies with binary outcomes, risk factor identification, diagnostic test evaluation.</p>
                </div>

                <div class="concept">
                    <h3>Chi-square Tests & Exact Methods</h3>
                    
                    <div class="key-concept">
                        <h4>üßÆ Test Selection for Categorical Data:</h4>
                        <p><strong>Chi-square test of independence:</strong> Test association between two categorical variables</p>
                        <p><strong>Fisher's exact test:</strong> Exact p-values when sample sizes are small</p>
                        <p><strong>McNemar's test:</strong> For paired/matched data (before/after, matched case-control)</p>
                        <p><strong>Chi-square goodness of fit:</strong> Test if data follows expected distribution</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è When to Use Each Test:</h4>
                        <p>‚Ä¢ <strong>Chi-square test:</strong> Expected frequency ‚â•5 in all cells</p>
                        <p>‚Ä¢ <strong>Fisher's exact:</strong> Small samples or sparse tables</p>
                        <p>‚Ä¢ <strong>McNemar's test:</strong> Paired binary data (same subjects measured twice)</p>
                        <p>‚Ä¢ <strong>Cochran-Mantel-Haenszel:</strong> Controlling for confounding variables</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Healthcare Examples:</h4>
                        <p><strong>Safety Analysis:</strong> Compare adverse event rates between treatment and placebo</p>
                        <p><strong>Case-Control Study:</strong> Association between smoking history and lung cancer</p>
                        <p><strong>Matched Pairs:</strong> Treatment response before and after intervention</p>
                        <p><strong>Diagnostic Study:</strong> Agreement between two diagnostic methods</p>
                    </div>

                    <div class="formula">
                        2x2 Contingency Table Analysis:
                        <br>Chi-square = Œ£[(Observed - Expected)¬≤ / Expected]
                        <br>Odds Ratio = (ad)/(bc) where a,b,c,d are cell counts
                        <br>Fisher's exact p-value uses hypergeometric distribution
                        <br>McNemar's test = (|b-c|-1)¬≤/(b+c) for discordant pairs
                    </div>

                    <div class="controls">
                        <h4>Categorical Data Analysis Simulator</h4>
                        <label>Study Design: 
                            <select id="categorical-design">
                                <option value="independent">Two Independent Groups</option>
                                <option value="case-control">Case-Control Study</option>
                                <option value="matched">Matched Pairs</option>
                                <option value="dose-response">Dose-Response (Trend)</option>
                            </select>
                        </label><br>
                        <label>Sample Size: <input type="number" id="categorical-n" value="200" min="50" max="1000" step="50"></label><br>
                        <label>Effect Size (OR): <input type="number" id="categorical-or" value="2.0" min="0.5" max="5.0" step="0.2"></label><br>
                        <label>Outcome Type: 
                            <select id="categorical-outcome">
                                <option value="adverse-event">Adverse Events</option>
                                <option value="treatment-response">Treatment Response</option>
                                <option value="disease-risk">Disease Risk Factor</option>
                                <option value="diagnostic-test">Diagnostic Test Result</option>
                            </select>
                        </label><br>
                        <button onclick="analyzeCategoricalData()">Analyze Categorical Data</button>
                    </div>

                    <div id="categorical-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="categorical-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° Clinical Decision Guidelines:</h4>
                        <p>‚Ä¢ <strong>Risk ratios:</strong> Better for common outcomes (>10%)</p>
                        <p>‚Ä¢ <strong>Odds ratios:</strong> Approximate risk ratios for rare outcomes</p>
                        <p>‚Ä¢ <strong>Number needed to treat:</strong> 1/absolute risk reduction for clinical interpretation</p>
                        <p>‚Ä¢ <strong>Consider confounders:</strong> Age, sex, comorbidities often affect relationships</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 6: Non-parametric Tests -->
        <div id="nonparametric-section" class="section-content">
            <div class="section">
                <h2>üìä Non-parametric Tests: When Assumptions Fail</h2>
                
                <div class="concept-intro">
                    <h3>üìö Why Non-parametric Methods?</h3>
                    <p><strong>Medical data often violates the assumptions required for standard t-tests and ANOVA</strong> - data may be skewed, have outliers, or be measured on ordinal scales. Non-parametric tests make fewer assumptions about data distribution.</p>
                    
                    <p><strong>Common in healthcare:</strong> Pain scores, quality of life measures, biomarker levels with extreme outliers, time-to-event data, small sample sizes where normality can't be assumed.</p>
                </div>

                <div class="concept">
                    <h3>Distribution-Free Statistical Methods</h3>
                    
                    <div class="key-concept">
                        <h4>üîß Non-parametric Test Arsenal:</h4>
                        <p><strong>Mann-Whitney U (Wilcoxon rank-sum):</strong> Two independent groups (alternative to t-test)</p>
                        <p><strong>Wilcoxon signed-rank:</strong> Paired data (alternative to paired t-test)</p>
                        <p><strong>Kruskal-Wallis:</strong> Three or more groups (alternative to ANOVA)</p>
                        <p><strong>Spearman correlation:</strong> Monotonic relationships (alternative to Pearson)</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è When to Use Non-parametric Tests:</h4>
                        <p>‚Ä¢ <strong>Skewed data:</strong> Cannot be normalized by transformation</p>
                        <p>‚Ä¢ <strong>Ordinal scales:</strong> Data measured on ranking scales</p>
                        <p>‚Ä¢ <strong>Small samples:</strong> Cannot verify normality assumption</p>
                        <p>‚Ä¢ <strong>Outliers:</strong> Extreme values that shouldn't be excluded</p>
                        <p>‚Ä¢ <strong>Trade-off:</strong> Robust but less powerful than parametric tests when assumptions are met</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Healthcare Applications:</h4>
                        <p><strong>Pain Studies:</strong> Visual analog scale scores (0-10) often skewed</p>
                        <p><strong>Quality of Life:</strong> SF-36 scores with ceiling/floor effects</p>
                        <p><strong>Biomarkers:</strong> Inflammatory markers with log-normal distribution</p>
                        <p><strong>Time Measurements:</strong> Hospital length of stay with extreme outliers</p>
                    </div>

                    <div class="formula">
                        Non-parametric Test Statistics:
                        <br>Mann-Whitney U: U = n‚ÇÅn‚ÇÇ + n‚ÇÅ(n‚ÇÅ+1)/2 - R‚ÇÅ
                        <br>Wilcoxon signed-rank: W = sum of positive ranks
                        <br>Kruskal-Wallis: H = [12/N(N+1)] Œ£(R¬≤·µ¢/n·µ¢) - 3(N+1)
                        <br>All based on ranks rather than actual values
                    </div>

                    <div class="controls">
                        <h4>Non-parametric Test Comparison Tool</h4>
                        <label>Data Distribution: 
                            <select id="data-distribution">
                                <option value="normal">Normal (for comparison)</option>
                                <option value="skewed">Right-skewed</option>
                                <option value="outliers">Normal with outliers</option>
                                <option value="ordinal">Ordinal scale</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="nonpar-sample" value="50" min="10" max="200" step="10"></label><br>
                        <label>True Effect Size: <input type="number" id="nonpar-effect" value="0.5" min="0" max="1.5" step="0.1"></label><br>
                        <label>Clinical Scenario: 
                            <select id="nonpar-scenario">
                                <option value="pain">Pain Score Comparison</option>
                                <option value="biomarker">Biomarker Levels</option>
                                <option value="qol">Quality of Life Assessment</option>
                                <option value="los">Hospital Length of Stay</option>
                            </select>
                        </label><br>
                        <button onclick="compareParametricNonparametric()">Compare Test Methods</button>
                    </div>

                    <div id="nonparametric-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="nonparametric-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° Decision Framework:</h4>
                        <p>‚Ä¢ <strong>First choice:</strong> Check assumptions for parametric tests</p>
                        <p>‚Ä¢ <strong>Transformation:</strong> Try log, square root, or other transformations</p>
                        <p>‚Ä¢ <strong>Non-parametric:</strong> When transformations don't help</p>
                        <p>‚Ä¢ <strong>Report both:</strong> If borderline, show parametric and non-parametric results</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 7: Diagnostic Test Evaluation -->
        <div id="diagnostic-section" class="section-content">
            <div class="section">
                <h2>üî¨ Diagnostic Test Evaluation & ROC Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Evaluating Medical Tests</h3>
                    <p><strong>Diagnostic tests are fundamental tools in medicine, but no test is perfect.</strong> We need statistical methods to quantify how well tests discriminate between diseased and healthy patients, and to establish optimal cut-points for clinical decision-making.</p>
                    
                    <p><strong>Clinical importance:</strong> Laboratory test validation, imaging interpretation, screening program development, clinical decision support tools, biomarker discovery.</p>
                </div>

                <div class="concept">
                    <h3>Sensitivity, Specificity & ROC Curves</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Diagnostic Performance Measures:</h4>
                        <p><strong>Sensitivity:</strong> Proportion of diseased patients correctly identified (true positive rate)</p>
                        <p><strong>Specificity:</strong> Proportion of healthy patients correctly identified (true negative rate)</p>
                        <p><strong>Positive Predictive Value (PPV):</strong> Probability disease is present given positive test</p>
                        <p><strong>Negative Predictive Value (NPV):</strong> Probability disease is absent given negative test</p>
                    </div>

                    <div class="clinical-context">
                        <h4>The 2x2 Diagnostic Table:</h4>
                        <table style="margin: 15px 0;">
                            <tr><th></th><th>Disease +</th><th>Disease -</th><th>Total</th></tr>
                            <tr><th>Test +</th><td>a (TP)</td><td>b (FP)</td><td>a+b</td></tr>
                            <tr><th>Test -</th><td>c (FN)</td><td>d (TN)</td><td>c+d</td></tr>
                            <tr><th>Total</th><td>a+c</td><td>b+d</td><td>n</td></tr>
                        </table>
                        <p><strong>Sensitivity = a/(a+c)</strong> | <strong>Specificity = d/(b+d)</strong></p>
                        <p><strong>PPV = a/(a+b)</strong> | <strong>NPV = d/(c+d)</strong></p>
                    </div>

                    <div class="formula">
                        ROC Analysis:
                        <br>ROC Curve: Plot Sensitivity vs (1-Specificity) for all cut-points
                        <br>AUC: Area Under ROC Curve (0.5 = random, 1.0 = perfect)
                        <br>Likelihood Ratio +: Sensitivity / (1-Specificity)
                        <br>Likelihood Ratio -: (1-Sensitivity) / Specificity
                        <br>DOR (Diagnostic Odds Ratio): LR+ / LR-
                    </formula>

                    <div class="controls">
                        <h4>Diagnostic Test Simulator</h4>
                        <label>Disease Prevalence (%): <input type="number" id="prevalence" value="20" min="1" max="50" step="1"></label><br>
                        <label>Total Sample Size: <input type="number" id="diagnostic-n" value="500" min="100" max="2000" step="100"></label><br>
                        <label>Test Performance: 
                            <select id="test-performance">
                                <option value="excellent">Excellent (AUC ~0.9)</option>
                                <option value="good">Good (AUC ~0.8)</option>
                                <option value="moderate">Moderate (AUC ~0.7)</option>
                                <option value="poor">Poor (AUC ~0.6)</option>
                            </select>
                        </label><br>
                        <label>Clinical Setting: 
                            <select id="clinical-setting">
                                <option value="screening">Population Screening</option>
                                <option value="diagnostic">Diagnostic Workup</option>
                                <option value="monitoring">Disease Monitoring</option>
                                <option value="research">Research Biomarker</option>
                            </select>
                        </label><br>
                        <button onclick="simulateDiagnosticTest()">Simulate Diagnostic Study</button>
                    </div>

                    <div id="diagnostic-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="diagnostic-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Regulatory Requirements:</h4>
                        <p>‚Ä¢ <strong>Health Canada Class II/III devices:</strong> Clinical validation required</p>
                        <p>‚Ä¢ <strong>Companion diagnostics:</strong> Co-development with therapeutic</p>
                        <p>‚Ä¢ <strong>Laboratory standards:</strong> ISO 15189 quality management</p>
                        <p>‚Ä¢ <strong>Clinical utility:</strong> Must demonstrate impact on patient outcomes</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 8: Equivalence & Non-inferiority Testing -->
        <div id="equivalence-section" class="section-content">
            <div class="section">
                <h2>‚öñÔ∏è Equivalence & Non-inferiority Testing</h2>
                
                <div class="concept-intro">
                    <h3>üìö When "No Difference" is the Goal</h3>
                    <p><strong>Sometimes we want to show that treatments are equivalent or that a new treatment is "not worse" than standard care.</strong> This requires different statistical approaches because we're trying to demonstrate similarity rather than difference.</p>
                    
                    <p><strong>Clinical applications:</strong> Generic drug approval, biosimilar studies, showing new treatment has similar efficacy with better safety profile, device comparisons, cost-effectiveness when treatments are clinically equivalent.</p>
                </div>

                <div class="concept">
                    <h3>Equivalence vs Non-inferiority Designs</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Design Types:</h4>
                        <p><strong>Equivalence:</strong> Show treatments are clinically similar (within equivalence margins)</p>
                        <p><strong>Non-inferiority:</strong> Show new treatment is not worse than reference by more than margin</p>
                        <p><strong>Superiority:</strong> Show new treatment is better than reference (traditional approach)</p>
                        <p><strong>Key insight:</strong> Must define clinically meaningful margins BEFORE study</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Canadian Examples:</h4>
                        <p><strong>Generic Drugs:</strong> Bioequivalence studies showing 80-125% of reference drug exposure</p>
                        <p><strong>Biosimilars:</strong> Non-inferiority for efficacy, equivalence for safety</p>
                        <p><strong>Medical Devices:</strong> New device not inferior to predicate device</p>
                        <p><strong>Cost Considerations:</strong> New treatment similar efficacy but lower cost</p>
                    </div>

                    <div class="formula">
                        Equivalence Testing:
                        <br>H‚ÇÄ: |Œº‚ÇÅ - Œº‚ÇÇ| ‚â• Œ¥ (treatments differ by ‚â• margin)
                        <br>H‚ÇÅ: |Œº‚ÇÅ - Œº‚ÇÇ| < Œ¥ (treatments equivalent)
                        <br><br>
                        Non-inferiority Testing:
                        <br>H‚ÇÄ: Œº‚ÇÅ - Œº‚ÇÇ ‚â§ -Œ¥ (new treatment inferior)
                        <br>H‚ÇÅ: Œº‚ÇÅ - Œº‚ÇÇ > -Œ¥ (new treatment non-inferior)
                        <br><br>
                        Both require LARGER samples than superiority trials
                    </div>

                    <div class="controls">
                        <h4>Equivalence Study Designer</h4>
                        <label>Study Type: 
                            <select id="equivalence-type">
                                <option value="equivalence">Equivalence (Generic Drug)</option>
                                <option value="non-inferiority">Non-inferiority (Biosimilar)</option>
                                <option value="superiority">Superiority (for comparison)</option>
                            </select>
                        </label><br>
                        <label>Equivalence Margin: <input type="number" id="equivalence-margin" value="5" min="1" max="20" step="1"> (clinical units)</label><br>
                        <label>True Difference: <input type="number" id="true-difference" value="2" min="0" max="10" step="0.5"> (actual difference)</label><br>
                        <label>Standard Deviation: <input type="number" id="equiv-sd" value="15" min="5" max="30" step="1"></label><br>
                        <label>Regulatory Context: 
                            <select id="regulatory-context">
                                <option value="generic">Generic Drug (Health Canada)</option>
                                <option value="biosimilar">Biosimilar (Health Canada)</option>
                                <option value="device">Medical Device (Health Canada)</option>
                                <option value="fda">US FDA Comparison</option>
                            </select>
                        </label><br>
                        <button onclick="designEquivalenceStudy()">Design Equivalence Study</button>
                    </div>

                    <div id="equivalence-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="equivalence-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Health Canada Guidelines:</h4>
                        <p>‚Ä¢ <strong>Bioequivalence:</strong> 90% CI for ratio must be within 80-125%</p>
                        <p>‚Ä¢ <strong>Biosimilars:</strong> Stepwise approach starting with analytical similarity</p>
                        <p>‚Ä¢ <strong>Margin justification:</strong> Must preserve substantial portion of active control effect</p>
                        <p>‚Ä¢ <strong>Intent-to-treat:</strong> Primary analysis for non-inferiority</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 9: Survival Analysis Introduction -->
        <div id="survival-section" class="section-content">
            <div class="section">
                <h2>‚è±Ô∏è Introduction to Survival Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Time-to-Event Data in Medicine</h3>
                    <p><strong>Many medical outcomes are defined by when they occur, not just if they occur.</strong> Survival analysis handles time-to-event data where we track patients until they experience an event (death, disease recurrence, treatment failure) or are lost to follow-up.</p>
                    
                    <p><strong>Why special methods needed:</strong> Standard statistical methods can't handle censored data (incomplete observations where we only know the event hadn't occurred by last follow-up).</p>
                </div>

                <div class="concept">
                    <h3>Kaplan-Meier Estimation & Log-rank Test</h3>
                    
                    <div class="key-concept">
                        <h4>‚è∞ Key Survival Concepts:</h4>
                        <p><strong>Event:</strong> Outcome of interest (death, relapse, cure, adverse event)</p>
                        <p><strong>Censoring:</strong> Incomplete observations (lost to follow-up, study ends, competing events)</p>
                        <p><strong>Survival function S(t):</strong> Probability of surviving beyond time t</p>
                        <p><strong>Hazard function h(t):</strong> Instantaneous risk of event at time t</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Medical Applications:</h4>
                        <p><strong>Oncology:</strong> Overall survival, progression-free survival, time to treatment failure</p>
                        <p><strong>Cardiology:</strong> Time to first cardiac event, device failure time</p>
                        <p><strong>Infectious Disease:</strong> Time to cure, time to viral clearance</p>
                        <p><strong>Chronic Disease:</strong> Time to disease progression, medication adherence duration</p>
                    </div>

                    <div class="formula">
                        Kaplan-Meier Estimator:
                        <br>≈ú(t) = ‚àè[t·µ¢‚â§t] (1 - d·µ¢/n·µ¢)
                        <br>where d·µ¢ = events at time t·µ¢, n·µ¢ = at risk at time t·µ¢
                        <br><br>
                        Log-rank Test:
                        <br>Compares survival curves between groups
                        <br>Chi-square test on observed vs expected events
                        <br>Assumption: Proportional hazards over time
                    </formula>

                    <div class="controls">
                        <h4>Survival Analysis Simulator</h4>
                        <label>Study Design: 
                            <select id="survival-design">
                                <option value="treatment-comparison">Treatment vs Control</option>
                                <option value="prognostic-factor">Prognostic Factor Study</option>
                                <option value="dose-response">Dose-Response Analysis</option>
                                <option value="quality-study">Quality of Life Impact</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="survival-n" value="100" min="50" max="500" step="25"></label><br>
                        <label>Follow-up Duration (months): <input type="number" id="followup-time" value="24" min="6" max="60" step="6"></label><br>
                        <label>Hazard Ratio: <input type="number" id="hazard-ratio" value="0.7" min="0.3" max="2.0" step="0.1"></label><br>
                        <label>Censoring Rate (%): <input type="number" id="censoring-rate" value="20" min="5" max="50" step="5"></label><br>
                        <label>Clinical Context: 
                            <select id="survival-context">
                                <option value="cancer">Cancer Treatment Trial</option>
                                <option value="cardiovascular">Cardiovascular Prevention</option>
                                <option value="chronic-disease">Chronic Disease Management</option>
                                <option value="device">Medical Device Study</option>
                            </select>
                        </label><br>
                        <button onclick="simulateSurvivalStudy()">Simulate Survival Study</button>
                    </div>

                    <div id="survival-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="survival-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° When to Use Survival Analysis:</h4>
                        <p>‚Ä¢ <strong>Time matters:</strong> Not just if event occurs, but when</p>
                        <p>‚Ä¢ <strong>Censored data:</strong> Some patients haven't experienced event by study end</p>
                        <p>‚Ä¢ <strong>Competing risks:</strong> Multiple possible outcomes</p>
                        <p>‚Ä¢ <strong>Advanced methods:</strong> Cox regression for multiple covariates</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Assessment Section -->
        <div id="assessment-section" class="section-content">
            <div class="assessment">
                <h2>üß† Hypothesis Testing Assessment</h2>
                <p>Test your understanding of hypothesis testing concepts in clinical research. Questions rotate each session.</p>
                <button onclick="generateHypothesisQuestions()">Generate New Questions</button>
                
                <div id="hypothesis-questions-container">
                    <!-- Questions will be populated by JavaScript -->
                </div>
                
                <button onclick="checkHypothesisAnswers()" id="hypothesis-check-btn" style="display:none;">Check Answers</button>
                <div id="hypothesis-assessment-results"></div>
            </div>
        </div>
    </div>

    <script>
        let currentHypothesisQuestions = [];
        let charts = {};
        
        // Navigation functionality
        function showSection(sectionName) {
            const sections = document.querySelectorAll('.section-content');
            sections.forEach(section => {
                section.classList.remove('active');
            });
            
            const selectedSection = document.getElementById(sectionName + '-section');
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
        }

        // Section 1: Build Hypothesis
        function buildHypothesis() {
            const researchArea = document.getElementById('research-area').value;
            const studyDesign = document.getElementById('study-design').value;
            const testType = document.getElementById('test-type').value;

            const scenarios = {
                treatment: {
                    rct: {
                        question: "Does the new antihypertensive medication reduce systolic blood pressure more than placebo?",
                        population: "Adults with stage 1 hypertension (SBP 130-139 mmHg)",
                        intervention: "New ACE inhibitor (study drug)",
                        comparison: "Matching placebo",
                        outcome: "Change in systolic BP from baseline to 12 weeks"
                    },
                    cohort: {
                        question: "Does adherence to Mediterranean diet reduce cardiovascular events?",
                        population: "Adults aged 55+ with cardiovascular risk factors",
                        intervention: "High adherence to Mediterranean diet",
                        comparison: "Low adherence to Mediterranean diet", 
                        outcome: "Incidence of major cardiovascular events over 5 years"
                    }
                },
                diagnosis: {
                    rct: {
                        question: "Is the new rapid COVID-19 test as accurate as PCR?",
                        population: "Patients presenting with COVID-19 symptoms",
                        intervention: "New rapid antigen test",
                        comparison: "RT-PCR (reference standard)",
                        outcome: "Diagnostic sensitivity and specificity"
                    }
                },
                prevention: {
                    rct: {
                        question: "Does vitamin D supplementation reduce fracture risk in elderly?",
                        population: "Community-dwelling adults ‚â•65 years",
                        intervention: "Vitamin D 1000 IU daily",
                        comparison: "Placebo",
                        outcome: "Incidence of fragility fractures over 2 years"
                    }
                }
            };

            const scenario = scenarios[researchArea][studyDesign] || scenarios[researchArea]['rct'];
            
            // Generate hypothesis statements
            let nullHypothesis, altHypothesis, statisticalTest;
            
            switch (testType) {
                case 'two-sided':
                    nullHypothesis = "H‚ÇÄ: There is no difference between intervention and comparison groups";
                    altHypothesis = "H‚ÇÅ: There is a difference between intervention and comparison groups";
                    statisticalTest = "Two-sided test (Œ± = 0.05)";
                    break;
                case 'one-sided-greater':
                    nullHypothesis = "H‚ÇÄ: Intervention is not superior to comparison";
                    altHypothesis = "H‚ÇÅ: Intervention is superior to comparison";
                    statisticalTest = "One-sided superiority test (Œ± = 0.05)";
                    break;
                case 'one-sided-less':
                    nullHypothesis = "H‚ÇÄ: Intervention is not inferior to comparison";
                    altHypothesis = "H‚ÇÅ: Intervention is non-inferior to comparison";
                    statisticalTest = "One-sided non-inferiority test (Œ± = 0.025)";
                    break;
            }

            document.getElementById('framework-results').style.display = 'block';
            document.getElementById('framework-results').innerHTML = `
                <h4>Research Hypothesis Framework</h4>
                
                <p><strong>PICO Framework:</strong></p>
                <p><strong>P (Population):</strong> ${scenario.population}</p>
                <p><strong>I (Intervention):</strong> ${scenario.intervention}</p>
                <p><strong>C (Comparison):</strong> ${scenario.comparison}</p>
                <p><strong>O (Outcome):</strong> ${scenario.outcome}</p>
                
                <p><strong>Research Question:</strong></p>
                <p>${scenario.question}</p>
                
                <p><strong>Statistical Hypotheses:</strong></p>
                <p><strong>${nullHypothesis}</strong></p>
                <p><strong>${altHypothesis}</strong></p>
                
                <p><strong>Analysis Plan:</strong></p>
                <p>‚Ä¢ Statistical test: ${statisticalTest}</p>
                <p>‚Ä¢ Study design: ${studyDesign.toUpperCase()}</p>
                <p>‚Ä¢ Primary endpoint: ${scenario.outcome}</p>
                <p>‚Ä¢ Regulatory pathway: ${getRegulatory(researchArea)}</p>
                
                <p><strong>Sample Size Considerations:</strong></p>
                <p>‚Ä¢ Power: 80% (Œ≤ = 0.20)</p>
                <p>‚Ä¢ Effect size: Must be clinically meaningful</p>
                <p>‚Ä¢ Two-sided tests require larger samples than one-sided</p>
            `;
        }

        function getRegulatory(area) {
            const pathways = {
                treatment: 'Health Canada New Drug Submission (NDS)',
                diagnosis: 'Health Canada Medical Device License (MDL)', 
                prevention: 'Health Canada Natural Health Product (NHP)',
                'risk-factor': 'Health Canada Guidelines for observational studies'
            };
            return pathways[area] || 'Standard regulatory pathway';
        }

        // Section 2: Power Analysis
        function calculatePower() {
            const effectSize = parseFloat(document.getElementById('effect-size').value);
            const sampleSize = parseInt(document.getElementById('sample-size').value);
            const alpha = parseFloat(document.getElementById('alpha-level').value);
            const context = document.getElementById('clinical-context').value;

            // Calculate power (simplified Cohen's approach)
            const delta = effectSize * Math.sqrt(sampleSize / 2);
            const criticalValue = getZCritical(alpha);
            const power = 1 - normalCDF(criticalValue - delta) + normalCDF(-criticalValue - delta);

            // Calculate required sample size for 80% power
            const powerTarget = 0.80;
            const zBeta = getZCritical(1 - powerTarget);
            const requiredN = Math.ceil(2 * Math.pow((criticalValue + zBeta) / effectSize, 2));

            // Clinical consequences
            const consequences = getClinicalConsequences(context, alpha, 1 - power);

            document.getElementById('errors-results').style.display = 'block';
            document.getElementById('errors-results').innerHTML = `
                <h4>Power Analysis Results</h4>
                
                <p><strong>Study Parameters:</strong></p>
                <p>‚Ä¢ Effect size (Cohen's d): ${effectSize}</p>
                <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                <p>‚Ä¢ Significance level (Œ±): ${alpha}</p>
                <p>‚Ä¢ Clinical context: ${context.replace('-', ' ')}</p>
                
                <p><strong>Statistical Power Analysis:</strong></p>
                <p>‚Ä¢ <span class="highlight">Current power: ${(power * 100).toFixed(1)}%</span></p>
                <p>‚Ä¢ Type II error rate (Œ≤): ${((1 - power) * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Required sample size for 80% power: ${requiredN} per group</p>
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ Probability of detecting true effect: ${(power * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Risk of missing true effect: ${((1 - power) * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Power adequacy: ${power >= 0.8 ? 'Adequate' : 'Inadequate - increase sample size'}</p>
                
                <p><strong>Clinical Consequences:</strong></p>
                <p>‚Ä¢ Type I error impact: ${consequences.typeI}</p>
                <p>‚Ä¢ Type II error impact: ${consequences.typeII}</p>
                <p>‚Ä¢ Cost per additional patient: ${consequences.cost}</p>
            `;

            createPowerCurve(effectSize, alpha, sampleSize, power);
        }

        function getClinicalConsequences(context, alpha, beta) {
            const consequences = {
                efficacy: {
                    typeI: 'Approving ineffective treatment - patients receive no benefit, healthcare costs increase',
                    typeII: 'Missing effective treatment - patients continue to suffer from untreated condition',
                    cost: 'CAD $15,000-25,000 per patient'
                },
                safety: {
                    typeI: 'False safety signal - unnecessary treatment restrictions, patient access reduced',
                    typeII: 'Missing real safety issue - patients exposed to preventable harm',
                    cost: 'CAD $8,000-15,000 per patient'
                },
                bioequivalence: {
                    typeI: 'Concluding non-equivalence when equivalent - generic drug unnecessarily rejected',
                    typeII: 'Missing non-equivalence - potentially inferior generic approved',
                    cost: 'CAD $5,000-10,000 per patient'
                }
            };
            return consequences[context] || consequences.efficacy;
        }

        function createPowerCurve(baseEffect, alpha, currentN, currentPower) {
            const ctx = document.getElementById('power-chart').getContext('2d');
            if (charts.power) charts.power.destroy();

            // Generate power curve across effect sizes
            const effectSizes = [];
            const powers = [];
            
            for (let d = 0; d <= 1.5; d += 0.05) {
                const delta = d * Math.sqrt(currentN / 2);
                const criticalValue = getZCritical(alpha);
                const power = 1 - normalCDF(criticalValue - delta) + normalCDF(-criticalValue - delta);
                effectSizes.push(d);
                powers.push(power * 100);
            }

            charts.power = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: effectSizes.map(d => d.toFixed(2)),
                    datasets: [{
                        label: 'Statistical Power (%)',
                        data: powers,
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'Minimum Power (80%)',
                        data: Array(effectSizes.length).fill(80),
                        borderColor: '#dc143c',
                        borderDash: [10, 5],
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: `Current Study (d=${baseEffect})`,
                        data: [{x: baseEffect.toFixed(2), y: currentPower * 100}],
                        type: 'scatter',
                        backgroundColor: '#ff6b6b',
                        borderColor: '#ff6b6b',
                        pointRadius: 8,
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Power Curve: Power vs Effect Size'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Effect Size (Cohen\'s d)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Statistical Power (%)'
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        // Section 3: Multiple Testing Simulation
        function simulateMultipleTesting() {
            const numTests = parseInt(document.getElementById('num-comparisons').value);
            const trueEffect = document.getElementById('true-effect').value;
            const sampleSize = parseInt(document.getElementById('pvalue-sample').value);
            const correction = document.getElementById('correction-method').value;

            // Simulate p-values
            const results = [];
            const rawPValues = [];
            const adjustedPValues = [];

            for (let i = 0; i < numTests; i++) {
                let pValue;
                if (trueEffect === 'none') {
                    // All null hypotheses true - p-values uniform [0,1]
                    pValue = Math.random();
                } else if (trueEffect === 'some') {
                    // Half have true effects
                    if (i < numTests / 2) {
                        // True effect present - lower p-values
                        pValue = Math.random() * 0.3;
                    } else {
                        // No effect - uniform p-values
                        pValue = Math.random();
                    }
                } else {
                    // All have true effects
                    pValue = Math.random() * 0.2;
                }
                
                rawPValues.push(pValue);
                
                results.push({
                    test: i + 1,
                    rawP: pValue,
                    significant: pValue < 0.05,
                    truePositive: (trueEffect === 'all') || (trueEffect === 'some' && i < numTests / 2)
                });
            }

            // Apply correction
            if (correction === 'bonferroni') {
                for (let i = 0; i < numTests; i++) {
                    adjustedPValues[i] = Math.min(1, rawPValues[i] * numTests);
                    results[i].adjustedP = adjustedPValues[i];
                    results[i].sigAfterCorrection = adjustedPValues[i] < 0.05;
                }
            } else if (correction === 'holm') {
                // Holm-Bonferroni step-down
                const sorted = rawPValues.map((p, i) => ({p, index: i}))
                                        .sort((a, b) => a.p - b.p);
                
                for (let i = 0; i < numTests; i++) {
                    const adjustedP = Math.min(1, sorted[i].p * (numTests - i));
                    adjustedPValues[sorted[i].index] = adjustedP;
                    results[sorted[i].index].adjustedP = adjustedP;
                    results[sorted[i].index].sigAfterCorrection = adjustedP < 0.05;
                }
            } else if (correction === 'fdr') {
                // Benjamini-Hochberg FDR
                const sorted = rawPValues.map((p, i) => ({p, index: i}))
                                        .sort((a, b) => a.p - b.p);
                
                for (let i = 0; i < numTests; i++) {
                    const adjustedP = Math.min(1, sorted[i].p * numTests / (i + 1));
                    adjustedPValues[sorted[i].index] = adjustedP;
                    results[sorted[i].index].adjustedP = adjustedP;
                    results[sorted[i].index].sigAfterCorrection = adjustedP < 0.05;
                }
            } else {
                // No correction
                for (let i = 0; i < numTests; i++) {
                    adjustedPValues[i] = rawPValues[i];
                    results[i].adjustedP = rawPValues[i];
                    results[i].sigAfterCorrection = rawPValues[i] < 0.05;
                }
            }

            // Calculate error rates
            const sigBefore = results.filter(r => r.significant).length;
            const sigAfter = results.filter(r => r.sigAfterCorrection).length;
            const falsePositives = results.filter(r => r.sigAfterCorrection && !r.truePositive).length;
            const truePositives = results.filter(r => r.sigAfterCorrection && r.truePositive).length;

            document.getElementById('pvalues-results').style.display = 'block';
            document.getElementById('pvalues-results').innerHTML = `
                <h4>Multiple Testing Simulation Results</h4>
                
                <p><strong>Study Setup:</strong></p>
                <p>‚Ä¢ Number of tests: ${numTests}</p>
                <p>‚Ä¢ True effects: ${trueEffect === 'none' ? 'None (all null true)' : trueEffect === 'some' ? 'Some (mixed)' : 'All tests have true effects'}</p>
                <p>‚Ä¢ Correction method: ${correction === 'none' ? 'No correction' : correction.toUpperCase()}</p>
                
                <p><strong>Results Summary:</strong></p>
                <table>
                    <tr><th>Measure</th><th>Before Correction</th><th>After Correction</th></tr>
                    <tr><td>Significant tests</td><td>${sigBefore}</td><td>${sigAfter}</td></tr>
                    <tr><td>False positives</td><td>${results.filter(r => r.significant && !r.truePositive).length}</td><td>${falsePositives}</td></tr>
                    <tr><td>True positives</td><td>${results.filter(r => r.significant && r.truePositive).length}</td><td>${truePositives}</td></tr>
                    <tr><td>Family-wise error rate</td><td>${results.filter(r => r.significant && !r.truePositive).length > 0 ? 'Yes' : 'No'}</td><td>${falsePositives > 0 ? 'Yes' : 'No'}</td></tr>
                </table>
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Correction effectiveness: ${(((sigBefore - sigAfter) / Math.max(1, sigBefore)) * 100).toFixed(0)}% reduction in significant findings</span></p>
                <p>‚Ä¢ Type I error control: ${falsePositives === 0 ? 'Excellent' : falsePositives <= 1 ? 'Good' : 'Inadequate'}</p>
                <p>‚Ä¢ Power preservation: ${truePositives}/${results.filter(r => r.truePositive).length} true effects detected</p>
                
                <div style="max-height: 200px; overflow-y: auto;">
                    <table style="font-size: 0.9em;">
                        <tr><th>Test</th><th>Raw p</th><th>Adjusted p</th><th>Significant</th></tr>
                        ${results.slice(0, 10).map(r => `
                            <tr style="background-color: ${r.sigAfterCorrection ? '#e8ffe8' : '#f8f8f8'}">
                                <td>${r.test}</td>
                                <td>${r.rawP.toFixed(4)}</td>
                                <td>${r.adjustedP.toFixed(4)}</td>
                                <td>${r.sigAfterCorrection ? '‚úì' : '‚úó'}</td>
                            </tr>
                        `).join('')}
                        ${results.length > 10 ? '<tr><td colspan="4">... (showing first 10 tests)</td></tr>' : ''}
                    </table>
                </div>
            `;

            createPValueHistogram(rawPValues, adjustedPValues, correction);
        }

        function createPValueHistogram(rawPValues, adjustedPValues, correction) {
            const ctx = document.getElementById('pvalue-chart').getContext('2d');
            if (charts.pvalue) charts.pvalue.destroy();

            // Create histograms
            const bins = [0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.1, 0.2, 0.5, 1.0];
            const rawCounts = new Array(bins.length - 1).fill(0);
            const adjCounts = new Array(bins.length - 1).fill(0);

            rawPValues.forEach(p => {
                for (let i = 0; i < bins.length - 1; i++) {
                    if (p >= bins[i] && p < bins[i + 1]) {
                        rawCounts[i]++;
                        break;
                    }
                }
            });

            adjustedPValues.forEach(p => {
                for (let i = 0; i < bins.length - 1; i++) {
                    if (p >= bins[i] && p < bins[i + 1]) {
                        adjCounts[i]++;
                        break;
                    }
                }
            });

            charts.pvalue = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: bins.slice(0, -1).map((b, i) => `${b}-${bins[i + 1]}`),
                    datasets: [{
                        label: 'Raw P-values',
                        data: rawCounts,
                        backgroundColor: 'rgba(47, 139, 139, 0.7)',
                        borderColor: '#2f8b8b',
                        borderWidth: 2
                    }, {
                        label: 'Adjusted P-values',
                        data: adjCounts,
                        backgroundColor: 'rgba(220, 20, 60, 0.7)',
                        borderColor: '#dc143c',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `P-value Distribution: ${correction === 'none' ? 'No Correction' : correction.toUpperCase()}`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'P-value Range'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Number of Tests'
                            }
                        }
                    }
                }
            });
        }

        // Utility functions
        function getZCritical(alpha) {
            // Approximate critical values
            if (alpha <= 0.01) return 2.58;
            if (alpha <= 0.05) return 1.96;
            return 1.645;
        }

        function normalCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function erf(x) {
            const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
            const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        // Section 4: Means Testing
        function simulateMeansTest() {
            const studyType = document.getElementById('study-type').value;
            const sampleSize = parseInt(document.getElementById('means-sample-size').value);
            const effectSize = parseFloat(document.getElementById('means-effect').value);
            const outcome = document.getElementById('clinical-outcome').value;

            const outcomeParams = {
                'hba1c': { name: 'HbA1c Change', unit: '%', baseline: 8.5, sd: 1.2, clinicalThreshold: 0.5 },
                'bp': { name: 'Systolic BP', unit: 'mmHg', baseline: 145, sd: 15, clinicalThreshold: 5 },
                'cholesterol': { name: 'LDL Cholesterol', unit: 'mg/dL', baseline: 150, sd: 30, clinicalThreshold: 10 },
                'pain': { name: 'Pain Score', unit: '(0-10)', baseline: 6.5, sd: 2.0, clinicalThreshold: 1.0 }
            };

            const params = outcomeParams[outcome];
            let results = {};

            if (studyType === 'independent') {
                // Two independent groups
                const controlGroup = generateNormalData(sampleSize, params.baseline, params.sd);
                const treatmentGroup = generateNormalData(sampleSize, params.baseline - effectSize * params.sd, params.sd);
                
                const controlMean = mean(controlGroup);
                const treatmentMean = mean(treatmentGroup);
                const pooledSD = Math.sqrt((variance(controlGroup) + variance(treatmentGroup)) / 2);
                const se = pooledSD * Math.sqrt(2 / sampleSize);
                const tStat = (controlMean - treatmentMean) / se;
                const df = 2 * sampleSize - 2;
                const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
                
                results = {
                    type: 'Two-sample t-test',
                    controlMean: controlMean,
                    treatmentMean: treatmentMean,
                    difference: controlMean - treatmentMean,
                    se: se,
                    tStat: tStat,
                    df: df,
                    pValue: pValue,
                    clinicallySig: Math.abs(controlMean - treatmentMean) >= params.clinicalThreshold
                };
                
            } else if (studyType === 'paired') {
                // Paired data (before/after)
                const beforeData = generateNormalData(sampleSize, params.baseline, params.sd);
                const afterData = beforeData.map(x => x - effectSize * params.sd + (Math.random() - 0.5) * params.sd * 0.5);
                const differences = beforeData.map((x, i) => x - afterData[i]);
                
                const meanDiff = mean(differences);
                const sdDiff = Math.sqrt(variance(differences));
                const se = sdDiff / Math.sqrt(sampleSize);
                const tStat = meanDiff / se;
                const df = sampleSize - 1;
                const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
                
                results = {
                    type: 'Paired t-test',
                    beforeMean: mean(beforeData),
                    afterMean: mean(afterData),
                    difference: meanDiff,
                    se: se,
                    tStat: tStat,
                    df: df,
                    pValue: pValue,
                    clinicallySig: Math.abs(meanDiff) >= params.clinicalThreshold
                };
            } else {
                // ANOVA (3 groups)
                const group1 = generateNormalData(sampleSize, params.baseline, params.sd);
                const group2 = generateNormalData(sampleSize, params.baseline - effectSize * params.sd * 0.5, params.sd);
                const group3 = generateNormalData(sampleSize, params.baseline - effectSize * params.sd, params.sd);
                
                const allData = [...group1, ...group2, ...group3];
                const grandMean = mean(allData);
                const groupMeans = [mean(group1), mean(group2), mean(group3)];
                
                // Calculate F-statistic
                const msb = sampleSize * groupMeans.reduce((sum, gm) => sum + Math.pow(gm - grandMean, 2), 0) / 2;
                const msw = (variance(group1) + variance(group2) + variance(group3)) / 3;
                const fStat = msb / msw;
                const pValue = 1 - fCDF(fStat, 2, 3 * sampleSize - 3);
                
                results = {
                    type: 'One-way ANOVA',
                    groupMeans: groupMeans,
                    fStat: fStat,
                    pValue: pValue,
                    grandMean: grandMean,
                    clinicallySig: Math.max(...groupMeans) - Math.min(...groupMeans) >= params.clinicalThreshold
                };
            }

            document.getElementById('means-results').style.display = 'block';
            document.getElementById('means-results').innerHTML = `
                <h4>${results.type}: ${params.name} Analysis</h4>
                
                <p><strong>Study Design:</strong></p>
                <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                <p>‚Ä¢ Expected effect size: ${effectSize} (Cohen's d)</p>
                <p>‚Ä¢ Primary outcome: ${params.name} (${params.unit})</p>
                <p>‚Ä¢ Clinical threshold: ${params.clinicalThreshold} ${params.unit}</p>
                
                <p><strong>Results:</strong></p>
                ${getResultsDisplay(results, params)}
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Statistical significance: ${results.pValue < 0.05 ? 'Yes' : 'No'} (p = ${results.pValue.toFixed(4)})</span></p>
                <p>‚Ä¢ Clinical significance: ${results.clinicallySig ? 'Yes' : 'No'} (‚â•${params.clinicalThreshold} ${params.unit})</p>
                <p>‚Ä¢ Effect size interpretation: ${interpretEffectSize(effectSize)}</p>
                <p>‚Ä¢ Regulatory implication: ${getRegImplication(results.pValue < 0.05, results.clinicallySig)}</p>
            `;

            createMeansVisualization(results, studyType, params);
        }

        function getResultsDisplay(results, params) {
            if (results.type.includes('ANOVA')) {
                return `
                    <table>
                        <tr><th>Group</th><th>Mean (${params.unit})</th></tr>
                        <tr><td>Group 1 (Control)</td><td>${results.groupMeans[0].toFixed(2)}</td></tr>
                        <tr><td>Group 2 (Low Dose)</td><td>${results.groupMeans[1].toFixed(2)}</td></tr>
                        <tr><td>Group 3 (High Dose)</td><td>${results.groupMeans[2].toFixed(2)}</td></tr>
                    </table>
                    <p>‚Ä¢ F-statistic: ${results.fStat.toFixed(2)}</p>
                    <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                `;
            } else {
                return `
                    <table>
                        <tr><th>Group</th><th>Mean (${params.unit})</th></tr>
                        ${results.controlMean ? `<tr><td>Control</td><td>${results.controlMean.toFixed(2)}</td></tr>` : ''}
                        ${results.treatmentMean ? `<tr><td>Treatment</td><td>${results.treatmentMean.toFixed(2)}</td></tr>` : ''}
                        ${results.beforeMean ? `<tr><td>Before</td><td>${results.beforeMean.toFixed(2)}</td></tr>` : ''}
                        ${results.afterMean ? `<tr><td>After</td><td>${results.afterMean.toFixed(2)}</td></tr>` : ''}
                    </table>
                    <p>‚Ä¢ Mean difference: ${results.difference.toFixed(2)} ${params.unit}</p>
                    <p>‚Ä¢ Standard error: ${results.se.toFixed(3)}</p>
                    <p>‚Ä¢ t-statistic: ${results.tStat.toFixed(2)} (df = ${results.df})</p>
                    <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                `;
            }
        }

        function interpretEffectSize(d) {
            const abs_d = Math.abs(d);
            if (abs_d < 0.2) return 'Small effect';
            if (abs_d < 0.5) return 'Small to medium effect';
            if (abs_d < 0.8) return 'Medium effect';
            return 'Large effect';
        }

        function getRegImplication(statSig, clinSig) {
            if (statSig && clinSig) return 'Strong evidence for regulatory approval';
            if (statSig && !clinSig) return 'Statistically significant but questionable clinical benefit';
            if (!statSig && clinSig) return 'Clinically relevant but insufficient statistical evidence';
            return 'Insufficient evidence for regulatory approval';
        }

        // Section 5: Categorical Data Analysis
        function analyzeCategoricalData() {
            const design = document.getElementById('categorical-design').value;
            const n = parseInt(document.getElementById('categorical-n').value);
            const or = parseFloat(document.getElementById('categorical-or').value);
            const outcome = document.getElementById('categorical-outcome').value;

            let results = {};

            if (design === 'independent') {
                // 2x2 contingency table
                const p1 = 0.2; // baseline event rate
                const p2 = p1 * or / (1 + p1 * (or - 1)); // adjusted for odds ratio
                
                const events1 = Math.round(n * p1);
                const events2 = Math.round(n * p2);
                const noEvents1 = n - events1;
                const noEvents2 = n - events2;
                
                const chiSq = calculateChiSquare([[events1, noEvents1], [events2, noEvents2]]);
                const observedOR = (events1 * noEvents2) / (events2 * noEvents1);
                const rr = p1 / p2;
                
                results = {
                    type: 'Chi-square test of independence',
                    table: [[events1, noEvents1], [events2, noEvents2]],
                    chiSq: chiSq.statistic,
                    pValue: chiSq.pValue,
                    or: observedOR,
                    rr: rr,
                    nnt: Math.abs(1 / (p1 - p2))
                };
            } else if (design === 'case-control') {
                // Case-control design
                const exposureRate = 0.3;
                const cases = n / 2;
                const controls = n / 2;
                
                const exposedCases = Math.round(cases * exposureRate * or / (1 + exposureRate * (or - 1)));
                const unexposedCases = cases - exposedCases;
                const exposedControls = Math.round(controls * exposureRate);
                const unexposedControls = controls - exposedControls;
                
                const observedOR = (exposedCases * unexposedControls) / (unexposedCases * exposedControls);
                const chiSq = calculateChiSquare([[exposedCases, unexposedCases], [exposedControls, unexposedControls]]);
                
                results = {
                    type: 'Case-control study (Chi-square test)',
                    table: [[exposedCases, unexposedCases], [exposedControls, unexposedControls]],
                    chiSq: chiSq.statistic,
                    pValue: chiSq.pValue,
                    or: observedOR
                };
            }

            document.getElementById('categorical-results').style.display = 'block';
            document.getElementById('categorical-results').innerHTML = `
                <h4>${results.type}: ${outcome.replace('-', ' ')} Analysis</h4>
                
                <p><strong>Study Design:</strong></p>
                <p>‚Ä¢ Total sample size: ${n}</p>
                <p>‚Ä¢ Expected odds ratio: ${or}</p>
                <p>‚Ä¢ Analysis: ${results.type}</p>
                
                <p><strong>2x2 Contingency Table:</strong></p>
                <table>
                    <tr><th></th><th>Event +</th><th>Event -</th><th>Total</th></tr>
                    <tr><td>Group 1</td><td>${results.table[0][0]}</td><td>${results.table[0][1]}</td><td>${results.table[0][0] + results.table[0][1]}</td></tr>
                    <tr><td>Group 2</td><td>${results.table[1][0]}</td><td>${results.table[1][1]}</td><td>${results.table[1][0] + results.table[1][1]}</td></tr>
                </table>
                
                <p><strong>Statistical Results:</strong></p>
                <p>‚Ä¢ Chi-square statistic: ${results.chiSq.toFixed(2)}</p>
                <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                <p>‚Ä¢ <span class="highlight">Odds ratio: ${results.or.toFixed(2)}</span></p>
                ${results.rr ? `<p>‚Ä¢ Risk ratio: ${results.rr.toFixed(2)}</p>` : ''}
                ${results.nnt ? `<p>‚Ä¢ Number needed to treat: ${results.nnt.toFixed(0)}</p>` : ''}
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ Statistical significance: ${results.pValue < 0.05 ? 'Significant association' : 'No significant association'}</p>
                <p>‚Ä¢ Effect magnitude: ${interpretOR(results.or)}</p>
                <p>‚Ä¢ Clinical relevance: ${getClinicalRelevance(outcome, results.or)}</p>
            `;

            createCategoricalVisualization(results, outcome);
        }

        function calculateChiSquare(table) {
            const a = table[0][0], b = table[0][1];
            const c = table[1][0], d = table[1][1];
            const n = a + b + c + d;
            
            const expected = [
                [(a + b) * (a + c) / n, (a + b) * (b + d) / n],
                [(c + d) * (a + c) / n, (c + d) * (b + d) / n]
            ];
            
            let chiSq = 0;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    chiSq += Math.pow(table[i][j] - expected[i][j], 2) / expected[i][j];
                }
            }
            
            const pValue = 1 - chiSquareCDF(chiSq, 1);
            return { statistic: chiSq, pValue: pValue };
        }

        function interpretOR(or) {
            if (or > 2.0) return 'Strong positive association';
            if (or > 1.5) return 'Moderate positive association';
            if (or > 1.1) return 'Weak positive association';
            if (or > 0.9) return 'No meaningful association';
            if (or > 0.67) return 'Weak negative association';
            if (or > 0.5) return 'Moderate negative association';
            return 'Strong negative association';
        }

        function getClinicalRelevance(outcome, or) {
            if (outcome.includes('adverse')) {
                return or > 1.5 ? 'Clinically important safety signal' : 'Acceptable safety profile';
            } else if (outcome.includes('treatment')) {
                return or > 1.5 ? 'Clinically meaningful treatment benefit' : 'Limited treatment benefit';
            }
            return 'Requires clinical context for interpretation';
        }

        // Additional utility functions
        function generateNormalData(n, mean, sd) {
            const data = [];
            for (let i = 0; i < n; i++) {
                // Box-Muller transformation
                const u = Math.random();
                const v = Math.random();
                const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
                data.push(mean + z * sd);
            }
            return data;
        }

        function mean(data) {
            return data.reduce((a, b) => a + b, 0) / data.length;
        }

        function variance(data) {
            const m = mean(data);
            return data.reduce((sum, x) => sum + Math.pow(x - m, 2), 0) / (data.length - 1);
        }

        function tCDF(t, df) {
            // Approximate t-distribution CDF
            if (df >= 30) return normalCDF(t);
            return 0.5 + 0.5 * Math.sign(t) * Math.pow(1 - 1 / (1 + t * t / df), df / 2);
        }

        function fCDF(f, df1, df2) {
            // Very rough F-distribution approximation
            if (f < 0) return 0;
            if (f > 10) return 1;
            return 1 - Math.exp(-f / 2);
        }

        function chiSquareCDF(x, df) {
            // Approximate chi-square CDF
            if (df === 1) return 2 * normalCDF(Math.sqrt(x)) - 1;
            if (df === 2) return 1 - Math.exp(-x / 2);
            return 1 - Math.exp(-x / 2); // Simplified
        }

        // Chart creation functions
        function createMeansVisualization(results, studyType, params) {
            const ctx = document.getElementById('means-chart').getContext('2d');
            if (charts.means) charts.means.destroy();

            if (studyType === 'anova') {
                charts.means = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Control', 'Low Dose', 'High Dose'],
                        datasets: [{
                            label: `${params.name} (${params.unit})`,
                            data: results.groupMeans,
                            backgroundColor: ['rgba(255, 107, 107, 0.8)', 'rgba(255, 193, 7, 0.8)', 'rgba(47, 139, 139, 0.8)'],
                            borderColor: ['#ff6b6b', '#ffc107', '#2f8b8b'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'ANOVA: Group Means Comparison'
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: `${params.name} (${params.unit})`
                                }
                            }
                        }
                    }
                });
            } else {
                const labels = studyType === 'paired' ? ['Before', 'After'] : ['Control', 'Treatment'];
                const data = studyType === 'paired' ? 
                    [results.beforeMean, results.afterMean] :
                    [results.controlMean, results.treatmentMean];

                charts.means = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `${params.name} (${params.unit})`,
                            data: data,
                            backgroundColor: ['rgba(255, 107, 107, 0.8)', 'rgba(47, 139, 139, 0.8)'],
                            borderColor: ['#ff6b6b', '#2f8b8b'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${results.type}: Mean Comparison`
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: `${params.name} (${params.unit})`
                                }
                            }
                        }
                    }
                });
            }
        }

        function createNonparametricVisualization(group1Data, group2Data, distribution, scenario) {
            const ctx = document.getElementById('nonparametric-chart').getContext('2d');
            if (charts.nonparametric) charts.nonparametric.destroy();

            // Create box plot-style visualization
            const group1Stats = {
                min: Math.min(...group1Data),
                q1: percentile(group1Data, 25),
                median: median(group1Data),
                q3: percentile(group1Data, 75),
                max: Math.max(...group1Data),
                mean: mean(group1Data)
            };
            
            const group2Stats = {
                min: Math.min(...group2Data),
                q1: percentile(group2Data, 25),
                median: median(group2Data),
                q3: percentile(group2Data, 75),
                max: Math.max(...group2Data),
                mean: mean(group2Data)
            };

            charts.nonparametric = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Group 1 Data',
                        data: group1Data.slice(0, 20).map((value, i) => ({x: 1, y: value})),
                        backgroundColor: 'rgba(255, 107, 107, 0.6)',
                        borderColor: '#ff6b6b',
                        pointRadius: 4
                    }, {
                        label: 'Group 2 Data',
                        data: group2Data.slice(0, 20).map((value, i) => ({x: 2, y: value})),
                        backgroundColor: 'rgba(47, 139, 139, 0.6)',
                        borderColor: '#2f8b8b',
                        pointRadius: 4
                    }, {
                        label: 'Group 1 Median',
                        data: [{x: 1, y: group1Stats.median}],
                        backgroundColor: '#dc143c',
                        borderColor: '#dc143c',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false
                    }, {
                        label: 'Group 2 Median',
                        data: [{x: 2, y: group2Stats.median}],
                        backgroundColor: '#dc143c',
                        borderColor: '#dc143c',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Non-parametric Analysis: ${distribution} Distribution`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Groups'
                            },
                            min: 0.5,
                            max: 2.5,
                            ticks: {
                                callback: function(value) {
                                    return value === 1 ? 'Group 1' : value === 2 ? 'Group 2' : '';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Outcome Value'
                            }
                        }
                    }
                }
            });
        }

        function createDiagnosticVisualization(rocPoints, auc, performance) {
            const ctx = document.getElementById('diagnostic-chart').getContext('2d');
            if (charts.diagnostic) charts.diagnostic.destroy();

            charts.diagnostic = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: `ROC Curve (AUC = ${auc.toFixed(3)})`,
                        data: rocPoints,
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Random Chance (AUC = 0.5)',
                        data: [{x: 0, y: 0}, {x: 1, y: 1}],
                        borderColor: '#999',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `ROC Curve Analysis - ${performance} Performance`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'False Positive Rate (1 - Specificity)'
                            },
                            min: 0,
                            max: 1
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'True Positive Rate (Sensitivity)'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        function createEquivalenceVisualization(observedDiff, ci90Lower, ci90Upper, ci95Lower, ci95Upper, margin, studyType) {
            const ctx = document.getElementById('equivalence-chart').getContext('2d');
            if (charts.equivalence) charts.equivalence.destroy();

            const datasets = [{
                label: 'Observed Difference',
                data: [{x: observedDiff, y: 1}],
                backgroundColor: '#2f8b8b',
                borderColor: '#2f8b8b',
                pointRadius: 8,
                pointStyle: 'circle'
            }];

            if (studyType === 'equivalence') {
                datasets.push({
                    label: '90% Confidence Interval',
                    data: [{x: ci90Lower, y: 1}, {x: ci90Upper, y: 1}],
                    backgroundColor: 'transparent',
                    borderColor: '#dc143c',
                    borderWidth: 4,
                    pointRadius: 6,
                    pointStyle: 'line',
                    showLine: true
                });
                datasets.push({
                    label: 'Equivalence Margins',
                    data: [{x: -margin, y: 0.5}, {x: -margin, y: 1.5}],
                    backgroundColor: 'transparent',
                    borderColor: '#ff6b6b',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true
                });
                datasets.push({
                    label: '',
                    data: [{x: margin, y: 0.5}, {x: margin, y: 1.5}],
                    backgroundColor: 'transparent',
                    borderColor: '#ff6b6b',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true
                });
            } else {
                datasets.push({
                    label: '95% Confidence Interval',
                    data: [{x: ci95Lower, y: 1}, {x: ci95Upper, y: 1}],
                    backgroundColor: 'transparent',
                    borderColor: '#dc143c',
                    borderWidth: 4,
                    pointRadius: 6,
                    pointStyle: 'line',
                    showLine: true
                });
                datasets.push({
                    label: 'Non-inferiority Margin',
                    data: [{x: -margin, y: 0.5}, {x: -margin, y: 1.5}],
                    backgroundColor: 'transparent',
                    borderColor: '#ff6b6b',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true
                });
            }

            datasets.push({
                label: 'No Difference',
                data: [{x: 0, y: 0.5}, {x: 0, y: 1.5}],
                backgroundColor: 'transparent',
                borderColor: '#666',
                borderWidth: 2,
                pointRadius: 0,
                showLine: true
            });

            charts.equivalence = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${studyType.charAt(0).toUpperCase() + studyType.slice(1)} Analysis`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Treatment Difference'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: ''
                            },
                            min: 0.3,
                            max: 1.7,
                            ticks: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        function createSurvivalVisualization(km1, km2, contextInfo) {
            const ctx = document.getElementById('survival-chart').getContext('2d');
            if (charts.survival) charts.survival.destroy();

            // Convert KM data to chart format
            const km1Data = [{x: 0, y: 1}].concat(km1.map(point => ({x: point.time, y: point.survival})));
            const km2Data = [{x: 0, y: 1}].concat(km2.map(point => ({x: point.time, y: point.survival})));

            charts.survival = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: contextInfo.group1,
                        data: km1Data,
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        borderWidth: 3,
                        stepped: true,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: contextInfo.group2,
                        data: km2Data,
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.1)',
                        borderWidth: 3,
                        stepped: true,
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Kaplan-Meier Survival Curves: ${contextInfo.title}`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time (months)'
                            },
                            min: 0
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Survival Probability'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        function createCategoricalVisualization(results, outcome) {
            const ctx = document.getElementById('categorical-chart').getContext('2d');
            if (charts.categorical) charts.categorical.destroy();

            charts.categorical = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Group 1', 'Group 2'],
                    datasets: [{
                        label: 'Events',
                        data: [results.table[0][0], results.table[1][0]],
                        backgroundColor: 'rgba(220, 20, 60, 0.8)',
                        borderColor: '#dc143c',
                        borderWidth: 2
                    }, {
                        label: 'No Events',
                        data: [results.table[0][1], results.table[1][1]],
                        backgroundColor: 'rgba(47, 139, 139, 0.8)',
                        borderColor: '#2f8b8b',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${outcome.replace('-', ' ')} Analysis`
                        }
                    },
                    scales: {
                        x: {
                            stacked: true
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Number of Patients'
                            }
                        }
                    }
                }
            });
        }

        // Assessment Questions
        const hypothesisQuestionPools = {
            framework: [
                {
                    question: "A clinical trial tests whether a new diabetes drug reduces HbA1c more than placebo. What is the appropriate null hypothesis?",
                    options: [
                        "H‚ÇÄ: New drug reduces HbA1c by at least 0.5%",
                        "H‚ÇÄ: There is no difference in HbA1c reduction between new drug and placebo",
                        "H‚ÇÄ: New drug is superior to placebo",
                        "H‚ÇÄ: Patients prefer the new drug over placebo"
                    ],
                    correct: 1,
                    explanation: "The null hypothesis always states 'no effect' or 'no difference.' We assume no difference until evidence proves otherwise."
                }
            ],
            power: [
                {
                    question: "A study has 60% power to detect a clinically important difference. What does this mean?",
                    options: [
                        "There's a 60% chance the null hypothesis is true",
                        "There's a 40% chance of making a Type I error",
                        "If a true effect exists, there's a 60% chance of detecting it",
                        "60% of similar studies would show statistical significance"
                    ],
                    correct: 2,
                    explanation: "Power is the probability of correctly rejecting a false null hypothesis - i.e., detecting a true effect when it exists."
                }
            ],
            pvalues: [
                {
                    question: "A study reports p=0.03. This means:",
                    options: [
                        "There's a 3% chance the null hypothesis is true",
                        "There's a 97% chance the treatment works",
                        "If null hypothesis were true, we'd see data this extreme 3% of the time",
                        "The treatment effect is clinically significant"
                    ],
                    correct: 2,
                    explanation: "P-value is the probability of observing data as extreme or more extreme than observed, assuming the null hypothesis is true."
                }
            ],
            tests: [
                {
                    question: "You want to compare pain scores (0-10 scale) before and after treatment in the same 30 patients. Data are skewed. Which test is most appropriate?",
                    options: [
                        "Paired t-test",
                        "Two-sample t-test", 
                        "Wilcoxon signed-rank test",
                        "Mann-Whitney U test"
                    ],
                    correct: 2,
                    explanation: "Wilcoxon signed-rank test is the non-parametric equivalent of paired t-test, appropriate for skewed paired data."
                }
            ]
        };

        function generateHypothesisQuestions() {
            currentHypothesisQuestions = [];
            const pools = Object.keys(hypothesisQuestionPools);
            
            pools.forEach(pool => {
                const questions = hypothesisQuestionPools[pool];
                const randomQ = questions[Math.floor(Math.random() * questions.length)];
                currentHypothesisQuestions.push(randomQ);
            });

            displayHypothesisQuestions();
        }

        function displayHypothesisQuestions() {
            const container = document.getElementById('hypothesis-questions-container');
            let html = '';
            
            currentHypothesisQuestions.forEach((q, index) => {
                const shuffledOptions = [...q.options];
                const correctAnswer = shuffledOptions[q.correct];
                
                for (let i = shuffledOptions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                }
                
                const newCorrectIndex = shuffledOptions.indexOf(correctAnswer);
                
                html += `
                    <div class="question">
                        <h4>Question ${index + 1}</h4>
                        <p><strong>${q.question}</strong></p>
                        ${shuffledOptions.map((option, i) => `
                            <label>
                                <input type="radio" name="hq${index}" value="${i}" data-correct="${i === newCorrectIndex}">
                                ${String.fromCharCode(65 + i)}. ${option}
                            </label><br>
                        `).join('')}
                    </div>
                `;
            });
            
            container.innerHTML = html;
            document.getElementById('hypothesis-check-btn').style.display = 'block';
        }

        function checkHypothesisAnswers() {
            let correct = 0;
            let total = currentHypothesisQuestions.length;
            let results = '<h4>Hypothesis Testing Assessment Results</h4>';
            
            currentHypothesisQuestions.forEach((q, index) => {
                const selected = document.querySelector(`input[name="hq${index}"]:checked`);
                const isCorrect = selected && selected.dataset.correct === 'true';
                
                if (isCorrect) correct++;
                
                results += `
                    <p><strong>Question ${index + 1}:</strong> ${isCorrect ? '‚úì Correct' : '‚úó Incorrect'}</p>
                    <p><em>Explanation:</em> ${q.explanation}</p>
                `;
            });
            
            const percentage = (correct / total * 100).toFixed(1);
            results = `<p><strong>Score: ${correct}/${total} (${percentage}%)</strong></p>` + results;
            
            if (correct === total) {
                results += '<p><span style="color: #2f8b8b; font-weight: bold;">üéì Excellent! You have mastered hypothesis testing fundamentals!</span></p>';
            }
            
            document.getElementById('hypothesis-assessment-results').innerHTML = results;
        }

        // Initialize
        window.onload = function() {
            generateHypothesisQuestions();
            showSection('framework');
        };

        // Placeholder functions for additional sections (6-9) would go here
        // These would follow the same pattern as the implemented sections

        function compareParametricNonparametric() {
            const distribution = document.getElementById('data-distribution').value;
            const sampleSize = parseInt(document.getElementById('nonpar-sample').value);
            const effectSize = parseFloat(document.getElementById('nonpar-effect').value);
            const scenario = document.getElementById('nonpar-scenario').value;

            // Generate data based on distribution type
            let group1Data, group2Data;
            const baseValue = 50;
            
            switch (distribution) {
                case 'normal':
                    group1Data = generateNormalData(sampleSize, baseValue, 15);
                    group2Data = generateNormalData(sampleSize, baseValue + effectSize * 15, 15);
                    break;
                case 'skewed':
                    group1Data = generateLogNormalData(sampleSize, baseValue, 0.5);
                    group2Data = generateLogNormalData(sampleSize, baseValue + effectSize * 15, 0.5);
                    break;
                case 'outliers':
                    group1Data = generateNormalWithOutliers(sampleSize, baseValue, 15);
                    group2Data = generateNormalWithOutliers(sampleSize, baseValue + effectSize * 15, 15);
                    break;
                case 'ordinal':
                    group1Data = generateOrdinalData(sampleSize, baseValue);
                    group2Data = generateOrdinalData(sampleSize, baseValue + effectSize * 2);
                    break;
            }

            // Parametric test (t-test)
            const tTestResults = performTTest(group1Data, group2Data);
            
            // Non-parametric test (Mann-Whitney U)
            const mannWhitneyResults = performMannWhitney(group1Data, group2Data);
            
            // Effect size calculations
            const cohenD = (mean(group2Data) - mean(group1Data)) / Math.sqrt((variance(group1Data) + variance(group2Data)) / 2);
            const rankBiserial = mannWhitneyResults.u1 / (sampleSize * sampleSize);

            const scenarioInfo = getScenarioInfo(scenario);

            document.getElementById('nonparametric-results').style.display = 'block';
            document.getElementById('nonparametric-results').innerHTML = `
                <h4>Parametric vs Non-parametric Test Comparison</h4>
                
                <p><strong>Clinical Scenario:</strong> ${scenarioInfo.description}</p>
                <p><strong>Data Characteristics:</strong></p>
                <p>‚Ä¢ Distribution: ${distribution}</p>
                <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                <p>‚Ä¢ True effect size: ${effectSize}</p>
                <p>‚Ä¢ Outcome measure: ${scenarioInfo.outcome}</p>
                
                <p><strong>Descriptive Statistics:</strong></p>
                <table>
                    <tr><th>Group</th><th>Mean</th><th>Median</th><th>SD</th><th>IQR</th></tr>
                    <tr>
                        <td>Group 1</td>
                        <td>${mean(group1Data).toFixed(2)}</td>
                        <td>${median(group1Data).toFixed(2)}</td>
                        <td>${Math.sqrt(variance(group1Data)).toFixed(2)}</td>
                        <td>${(percentile(group1Data, 75) - percentile(group1Data, 25)).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Group 2</td>
                        <td>${mean(group2Data).toFixed(2)}</td>
                        <td>${median(group2Data).toFixed(2)}</td>
                        <td>${Math.sqrt(variance(group2Data)).toFixed(2)}</td>
                        <td>${(percentile(group2Data, 75) - percentile(group2Data, 25)).toFixed(2)}</td>
                    </tr>
                </table>

                <p><strong>Statistical Test Comparison:</strong></p>
                <table>
                    <tr><th>Test Type</th><th>Test Statistic</th><th>p-value</th><th>Effect Size</th><th>Interpretation</th></tr>
                    <tr style="background-color: ${tTestResults.pValue < 0.05 ? '#e8ffe8' : '#ffe8e8'}">
                        <td>Two-sample t-test</td>
                        <td>t = ${tTestResults.tStat.toFixed(2)}</td>
                        <td>${tTestResults.pValue.toFixed(4)}</td>
                        <td>d = ${cohenD.toFixed(3)}</td>
                        <td>${tTestResults.pValue < 0.05 ? 'Significant' : 'Not significant'}</td>
                    </tr>
                    <tr style="background-color: ${mannWhitneyResults.pValue < 0.05 ? '#e8ffe8' : '#ffe8e8'}">
                        <td>Mann-Whitney U</td>
                        <td>U = ${mannWhitneyResults.u1.toFixed(0)}</td>
                        <td>${mannWhitneyResults.pValue.toFixed(4)}</td>
                        <td>r = ${rankBiserial.toFixed(3)}</td>
                        <td>${mannWhitneyResults.pValue < 0.05 ? 'Significant' : 'Not significant'}</td>
                    </tr>
                </table>

                <p><strong>Test Assumptions:</strong></p>
                <p>‚Ä¢ <strong>t-test assumptions:</strong> ${checkTTestAssumptions(distribution)}</p>
                <p>‚Ä¢ <strong>Mann-Whitney assumptions:</strong> ${checkMannWhitneyAssumptions()}</p>
                
                <p><strong>Recommendation:</strong></p>
                <p>‚Ä¢ <span class="highlight">${getTestRecommendation(distribution, tTestResults.pValue, mannWhitneyResults.pValue)}</span></p>
                <p>‚Ä¢ Clinical significance: ${interpretClinicalSignificance(scenarioInfo, effectSize)}</p>
                <p>‚Ä¢ Regulatory consideration: ${getRegulatory(scenario)}</p>
            `;

            createNonparametricVisualization(group1Data, group2Data, distribution, scenario);
        }

        function generateLogNormalData(n, meanLog, sigmaLog) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const normalValue = generateNormalData(1, meanLog, sigmaLog)[0];
                data.push(Math.exp(normalValue / 10)); // Scale for reasonable values
            }
            return data;
        }

        function generateNormalWithOutliers(n, mean, sd) {
            const data = generateNormalData(Math.floor(n * 0.9), mean, sd);
            const outliers = Math.floor(n * 0.1);
            for (let i = 0; i < outliers; i++) {
                data.push(mean + (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2) * sd);
            }
            return data.sort((a, b) => a - b);
        }

        function generateOrdinalData(n, baseValue) {
            const data = [];
            const scale = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // 10-point scale
            const center = Math.max(1, Math.min(10, Math.round(baseValue / 10)));
            
            for (let i = 0; i < n; i++) {
                const random = Math.random();
                if (random < 0.3) data.push(center);
                else if (random < 0.6) data.push(Math.max(1, center + (Math.random() > 0.5 ? 1 : -1)));
                else data.push(scale[Math.floor(Math.random() * scale.length)]);
            }
            return data;
        }

        function performTTest(group1, group2) {
            const mean1 = mean(group1);
            const mean2 = mean(group2);
            const var1 = variance(group1);
            const var2 = variance(group2);
            const n1 = group1.length;
            const n2 = group2.length;
            
            const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
            const se = Math.sqrt(pooledVar * (1/n1 + 1/n2));
            const tStat = (mean2 - mean1) / se;
            const df = n1 + n2 - 2;
            const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
            
            return { tStat, pValue, df, se };
        }

        function performMannWhitney(group1, group2) {
            const combined = [...group1.map((x, i) => ({value: x, group: 1, index: i})), 
                             ...group2.map((x, i) => ({value: x, group: 2, index: i}))];
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks
            let rank = 1;
            for (let i = 0; i < combined.length; i++) {
                let j = i;
                while (j < combined.length - 1 && combined[j].value === combined[j + 1].value) {
                    j++;
                }
                const avgRank = (rank + rank + (j - i)) / 2;
                for (let k = i; k <= j; k++) {
                    combined[k].rank = avgRank;
                }
                rank = j + 2;
            }
            
            const r1 = combined.filter(x => x.group === 1).reduce((sum, x) => sum + x.rank, 0);
            const n1 = group1.length;
            const n2 = group2.length;
            
            const u1 = r1 - n1 * (n1 + 1) / 2;
            const u2 = n1 * n2 - u1;
            const u = Math.min(u1, u2);
            
            // Normal approximation for p-value
            const meanU = n1 * n2 / 2;
            const sdU = Math.sqrt(n1 * n2 * (n1 + n2 + 1) / 12);
            const z = (u - meanU) / sdU;
            const pValue = 2 * (1 - normalCDF(Math.abs(z)));
            
            return { u1, u2, u, pValue, z };
        }

        function median(data) {
            const sorted = [...data].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }

        function percentile(data, p) {
            const sorted = [...data].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function getScenarioInfo(scenario) {
            const scenarios = {
                pain: { 
                    description: "Comparing pain scores before/after intervention",
                    outcome: "Visual Analog Scale (0-10)"
                },
                biomarker: { 
                    description: "Biomarker levels in patient vs control groups",
                    outcome: "Inflammatory marker concentration"
                },
                qol: { 
                    description: "Quality of life assessment in clinical trial",
                    outcome: "SF-36 Physical Component Score"
                },
                los: { 
                    description: "Hospital length of stay comparison",
                    outcome: "Days in hospital"
                }
            };
            return scenarios[scenario];
        }

        function checkTTestAssumptions(distribution) {
            switch (distribution) {
                case 'normal': return 'Met (normal distribution)';
                case 'skewed': return 'Violated (non-normal distribution)';
                case 'outliers': return 'Questionable (outliers present)';
                case 'ordinal': return 'Violated (ordinal scale)';
                default: return 'Check normality';
            }
        }

        function checkMannWhitneyAssumptions() {
            return 'Met (only requires independent groups)';
        }

        function getTestRecommendation(distribution, tP, mannP) {
            if (distribution === 'normal') {
                return 't-test preferred (assumptions met, more powerful)';
            } else {
                return 'Mann-Whitney U preferred (robust to assumption violations)';
            }
        }

        function getRegulatory(scenario) {
            const regulatory = {
                pain: 'Pain assessment tools require Health Canada validation',
                biomarker: 'Biomarker qualification through Health Canada guidance',
                qol: 'Quality of life instruments for regulatory endpoints',
                los: 'Healthcare utilization metrics for health economics'
            };
            return regulatory[scenario] || 'Standard regulatory considerations apply';
        }

        function interpretClinicalSignificance(scenarioInfo, effectSize) {
            if (effectSize >= 0.5) return 'Large clinical impact expected';
            if (effectSize >= 0.3) return 'Moderate clinical impact';
            return 'Small clinical impact';
        }

        function simulateDiagnosticTest() {
            const prevalence = parseFloat(document.getElementById('prevalence').value) / 100;
            const n = parseInt(document.getElementById('diagnostic-n').value);
            const performance = document.getElementById('test-performance').value;
            const setting = document.getElementById('clinical-setting').value;

            // Set performance characteristics based on test quality
            const performanceParams = {
                excellent: { sensitivity: 0.92, specificity: 0.95 },
                good: { sensitivity: 0.85, specificity: 0.88 },
                moderate: { sensitivity: 0.75, specificity: 0.78 },
                poor: { sensitivity: 0.65, specificity: 0.68 }
            };

            const { sensitivity, specificity } = performanceParams[performance];
            
            // Calculate sample composition
            const diseased = Math.round(n * prevalence);
            const healthy = n - diseased;
            
            // Calculate confusion matrix
            const tp = Math.round(diseased * sensitivity);
            const fn = diseased - tp;
            const tn = Math.round(healthy * specificity);
            const fp = healthy - tn;
            
            // Calculate performance metrics
            const ppv = tp / (tp + fp);
            const npv = tn / (tn + fn);
            const accuracy = (tp + tn) / n;
            const lrPositive = sensitivity / (1 - specificity);
            const lrNegative = (1 - sensitivity) / specificity;
            const diagnosticOR = lrPositive / lrNegative;
            
            // Calculate AUC (approximation based on sensitivity/specificity)
            const auc = (sensitivity + specificity) / 2;
            
            // Generate ROC points
            const rocPoints = generateROCPoints(sensitivity, specificity);
            
            // Clinical interpretation
            const settingInfo = getSettingInfo(setting);

            document.getElementById('diagnostic-results').style.display = 'block';
            document.getElementById('diagnostic-results').innerHTML = `
                <h4>Diagnostic Test Performance Analysis</h4>
                
                <p><strong>Study Characteristics:</strong></p>
                <p>‚Ä¢ Clinical setting: ${settingInfo.name}</p>
                <p>‚Ä¢ Sample size: ${n} patients</p>
                <p>‚Ä¢ Disease prevalence: ${(prevalence * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Test performance level: ${performance}</p>
                
                <p><strong>2√ó2 Diagnostic Table:</strong></p>
                <table>
                    <tr><th></th><th>Disease +</th><th>Disease -</th><th>Total</th></tr>
                    <tr><td><strong>Test +</strong></td><td>${tp} (TP)</td><td>${fp} (FP)</td><td>${tp + fp}</td></tr>
                    <tr><td><strong>Test -</strong></td><td>${fn} (FN)</td><td>${tn} (TN)</td><td>${fn + tn}</td></tr>
                    <tr><td><strong>Total</strong></td><td>${diseased}</td><td>${healthy}</td><td>${n}</td></tr>
                </table>

                <p><strong>Primary Performance Metrics:</strong></p>
                <table>
                    <tr><th>Metric</th><th>Value</th><th>95% CI</th><th>Interpretation</th></tr>
                    <tr>
                        <td>Sensitivity</td>
                        <td>${(sensitivity * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tp, diseased)}</td>
                        <td>Probability of positive test given disease</td>
                    </tr>
                    <tr>
                        <td>Specificity</td>
                        <td>${(specificity * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tn, healthy)}</td>
                        <td>Probability of negative test given no disease</td>
                    </tr>
                    <tr>
                        <td>PPV</td>
                        <td>${(ppv * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tp, tp + fp)}</td>
                        <td>Probability of disease given positive test</td>
                    </tr>
                    <tr>
                        <td>NPV</td>
                        <td>${(npv * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tn, tn + fn)}</td>
                        <td>Probability of no disease given negative test</td>
                    </tr>
                </table>

                <p><strong>Advanced Metrics:</strong></p>
                <p>‚Ä¢ Overall accuracy: ${(accuracy * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Positive likelihood ratio: ${lrPositive.toFixed(2)}</p>
                <p>‚Ä¢ Negative likelihood ratio: ${lrNegative.toFixed(3)}</p>
                <p>‚Ä¢ Diagnostic odds ratio: ${diagnosticOR.toFixed(1)}</p>
                <p>‚Ä¢ <span class="highlight">Area Under ROC Curve: ${auc.toFixed(3)}</span></p>

                <p><strong>Clinical Utility Assessment:</strong></p>
                <p>‚Ä¢ Test quality: ${interpretAUC(auc)}</p>
                <p>‚Ä¢ Clinical application: ${settingInfo.application}</p>
                <p>‚Ä¢ Key consideration: ${getKeyConsideration(setting, ppv, npv)}</p>
                <p>‚Ä¢ Regulatory pathway: ${getRegulatoryPathway(setting, accuracy)}</p>

                <p><strong>Economic Impact (per 1000 tests):</strong></p>
                <p>‚Ä¢ True positives identified: ${Math.round(tp * 1000 / n)}</p>
                <p>‚Ä¢ False positives (unnecessary follow-up): ${Math.round(fp * 1000 / n)}</p>
                <p>‚Ä¢ False negatives (missed cases): ${Math.round(fn * 1000 / n)}</p>
                <p>‚Ä¢ Estimated cost per correct diagnosis: CAD $${calculateCostPerDiagnosis(settingInfo, accuracy)}</p>
            `;

            createDiagnosticVisualization(rocPoints, auc, performance);
        }

        function generateROCPoints(baseSens, baseSpec) {
            const points = [];
            for (let threshold = 0; threshold <= 1; threshold += 0.05) {
                // Approximate sensitivity/specificity at different thresholds
                const sens = baseSens * (1 - threshold * 0.3);
                const spec = baseSpec * (0.5 + threshold * 0.5);
                const fpr = 1 - Math.max(0, Math.min(1, spec));
                const tpr = Math.max(0, Math.min(1, sens));
                points.push({ x: fpr, y: tpr });
            }
            return points.sort((a, b) => a.x - b.x);
        }

        function calculateCI(successes, total) {
            const p = successes / total;
            const se = Math.sqrt(p * (1 - p) / total);
            const margin = 1.96 * se;
            const lower = Math.max(0, p - margin);
            const upper = Math.min(1, p + margin);
            return `[${(lower * 100).toFixed(1)}%, ${(upper * 100).toFixed(1)}%]`;
        }

        function getSettingInfo(setting) {
            const settings = {
                screening: {
                    name: 'Population Screening',
                    application: 'High sensitivity preferred to minimize false negatives'
                },
                diagnostic: {
                    name: 'Diagnostic Workup',
                    application: 'Balance between sensitivity and specificity'
                },
                monitoring: {
                    name: 'Disease Monitoring',
                    application: 'High specificity to avoid false alarms'
                },
                research: {
                    name: 'Research Biomarker',
                    application: 'High discriminatory ability required'
                }
            };
            return settings[setting];
        }

        function interpretAUC(auc) {
            if (auc >= 0.9) return 'Excellent discrimination';
            if (auc >= 0.8) return 'Good discrimination';
            if (auc >= 0.7) return 'Fair discrimination';
            if (auc >= 0.6) return 'Poor discrimination';
            return 'No discriminatory ability';
        }

        function getKeyConsideration(setting, ppv, npv) {
            if (setting === 'screening') {
                return `High NPV (${(npv * 100).toFixed(1)}%) critical for ruling out disease`;
            } else if (setting === 'diagnostic') {
                return `Balanced PPV (${(ppv * 100).toFixed(1)}%) and NPV (${(npv * 100).toFixed(1)}%) needed`;
            }
            return `PPV (${(ppv * 100).toFixed(1)}%) depends on disease prevalence in population`;
        }

        function getRegulatoryPathway(setting, accuracy) {
            if (accuracy >= 0.85) {
                return 'Health Canada Class II - moderate risk medical device';
            } else if (accuracy >= 0.75) {
                return 'Health Canada Class I - low risk, enhanced oversight required';
            } else {
                return 'Performance insufficient for regulatory approval';
            }
        }

        function calculateCostPerDiagnosis(settingInfo, accuracy) {
            const baseCosts = {
                'Population Screening': 150,
                'Diagnostic Workup': 250,
                'Disease Monitoring': 200,
                'Research Biomarker': 500
            };
            const baseCost = baseCosts[settingInfo.name] || 200;
            return Math.round(baseCost / accuracy);
        }

        function designEquivalenceStudy() {
            const studyType = document.getElementById('equivalence-type').value;
            const margin = parseFloat(document.getElementById('equivalence-margin').value);
            const trueDifference = parseFloat(document.getElementById('true-difference').value);
            const sd = parseFloat(document.getElementById('equiv-sd').value);
            const regulatory = document.getElementById('regulatory-context').value;

            // Calculate sample size for equivalence/non-inferiority
            const alpha = studyType === 'superiority' ? 0.05 : 0.025; // One-sided for equivalence components
            const power = 0.8;
            const zAlpha = studyType === 'superiority' ? 1.96 : 2.24; // Adjusted for two one-sided tests
            const zBeta = 0.84; // 80% power
            
            let requiredN;
            if (studyType === 'equivalence') {
                // Equivalence requires testing both directions
                requiredN = Math.ceil(2 * Math.pow((zAlpha + zBeta) * sd / margin, 2));
            } else if (studyType === 'non-inferiority') {
                // Non-inferiority single direction
                requiredN = Math.ceil(2 * Math.pow((zAlpha + zBeta) * sd / margin, 2) * 0.8);
            } else {
                // Superiority
                requiredN = Math.ceil(2 * Math.pow((1.96 + zBeta) * sd / trueDifference, 2));
            }

            // Simulate study results
            const finalN = Math.max(requiredN, 50);
            const group1Data = generateNormalData(finalN, 120, sd); // Reference treatment
            const group2Data = generateNormalData(finalN, 120 - trueDifference, sd); // Test treatment
            
            const mean1 = mean(group1Data);
            const mean2 = mean(group2Data);
            const observedDiff = mean1 - mean2;
            const pooledSD = Math.sqrt((variance(group1Data) + variance(group2Data)) / 2);
            const se = pooledSD * Math.sqrt(2 / finalN);
            
            // Calculate confidence intervals
            const ci90Lower = observedDiff - 1.645 * se;
            const ci90Upper = observedDiff + 1.645 * se;
            const ci95Lower = observedDiff - 1.96 * se;
            const ci95Upper = observedDiff + 1.96 * se;

            // Determine study conclusion
            let conclusion, ciToUse, conclusionReasoning;
            
            if (studyType === 'equivalence') {
                ciToUse = `90% CI: [${ci90Lower.toFixed(2)}, ${ci90Upper.toFixed(2)}]`;
                const equivalent = ci90Lower > -margin && ci90Upper < margin;
                conclusion = equivalent ? 'Equivalence demonstrated' : 'Equivalence not demonstrated';
                conclusionReasoning = equivalent ? 
                    `90% CI entirely within equivalence margins (¬±${margin})` :
                    `90% CI extends beyond equivalence margins`;
            } else if (studyType === 'non-inferiority') {
                ciToUse = `95% CI: [${ci95Lower.toFixed(2)}, ${ci95Upper.toFixed(2)}]`;
                const nonInferior = ci95Lower > -margin;
                conclusion = nonInferior ? 'Non-inferiority demonstrated' : 'Non-inferiority not demonstrated';
                conclusionReasoning = nonInferior ?
                    `95% CI lower bound > non-inferiority margin (-${margin})` :
                    `95% CI lower bound ‚â§ non-inferiority margin`;
            } else {
                ciToUse = `95% CI: [${ci95Lower.toFixed(2)}, ${ci95Upper.toFixed(2)}]`;
                const superior = ci95Lower > 0;
                conclusion = superior ? 'Superiority demonstrated' : 'Superiority not demonstrated';
                conclusionReasoning = superior ?
                    '95% CI excludes zero (favors test treatment)' :
                    '95% CI includes zero';
            }

            const regulatoryInfo = getRegulatoryInfo(regulatory);

            document.getElementById('equivalence-results').style.display = 'block';
            document.getElementById('equivalence-results').innerHTML = `
                <h4>${studyType.charAt(0).toUpperCase() + studyType.slice(1)} Study Design & Results</h4>
                
                <p><strong>Study Design Parameters:</strong></p>
                <p>‚Ä¢ Study type: ${studyType.replace('-', ' ')}</p>
                <p>‚Ä¢ Clinical margin: ¬±${margin} units</p>
                <p>‚Ä¢ True difference: ${trueDifference} units</p>
                <p>‚Ä¢ Population SD: ${sd} units</p>
                <p>‚Ä¢ Regulatory context: ${regulatoryInfo.name}</p>

                <p><strong>Sample Size Calculation:</strong></p>
                <p>‚Ä¢ Required sample size: ${requiredN} per group</p>
                <p>‚Ä¢ Actual study size: ${finalN} per group</p>
                <p>‚Ä¢ Total patients: ${finalN * 2}</p>
                <p>‚Ä¢ Power achieved: ${requiredN <= finalN ? '‚â•80%' : '<80% (underpowered)'}</p>

                <p><strong>Study Results:</strong></p>
                <table>
                    <tr><th>Group</th><th>N</th><th>Mean</th><th>SD</th></tr>
                    <tr><td>Reference Treatment</td><td>${finalN}</td><td>${mean1.toFixed(2)}</td><td>${Math.sqrt(variance(group1Data)).toFixed(2)}</td></tr>
                    <tr><td>Test Treatment</td><td>${finalN}</td><td>${mean2.toFixed(2)}</td><td>${Math.sqrt(variance(group2Data)).toFixed(2)}</td></tr>
                </table>

                <p><strong>Primary Analysis:</strong></p>
                <p>‚Ä¢ Observed difference (Ref - Test): ${observedDiff.toFixed(2)} units</p>
                <p>‚Ä¢ Standard error: ${se.toFixed(3)}</p>
                <p>‚Ä¢ ${ciToUse}</p>
                
                <p><strong>Statistical Conclusion:</strong></p>
                <p>‚Ä¢ <span class="highlight">${conclusion}</span></p>
                <p>‚Ä¢ Reasoning: ${conclusionReasoning}</p>
                
                <p><strong>Regulatory Implications:</strong></p>
                <p>‚Ä¢ Regulatory pathway: ${regulatoryInfo.pathway}</p>
                <p>‚Ä¢ Margin justification: ${getMarginJustification(studyType, margin)}</p>
                <p>‚Ä¢ Next steps: ${getNextSteps(conclusion, regulatory)}</p>
                <p>‚Ä¢ Submission timeline: ${regulatoryInfo.timeline}</p>

                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ Clinical significance: ${interpretClinicalEquivalence(studyType, observedDiff, margin)}</p>
                <p>‚Ä¢ Safety considerations: ${getSafetyConsiderations(regulatory)}</p>
                <p>‚Ä¢ Market access: ${getMarketAccess(conclusion, regulatory)}</p>
                <p>‚Ä¢ Cost implications: ${getCostImplications(studyType, conclusion)}</p>
            `;

            createEquivalenceVisualization(observedDiff, ci90Lower, ci90Upper, ci95Lower, ci95Upper, margin, studyType);
        }

        function getRegulatoryInfo(regulatory) {
            const info = {
                generic: {
                    name: 'Generic Drug (Health Canada)',
                    pathway: 'Abbreviated New Drug Submission (ANDS)',
                    timeline: '12-18 months post-submission'
                },
                biosimilar: {
                    name: 'Biosimilar (Health Canada)', 
                    pathway: 'New Drug Submission (NDS) - biosimilar',
                    timeline: '18-24 months post-submission'
                },
                device: {
                    name: 'Medical Device (Health Canada)',
                    pathway: 'Medical Device License (MDL)',
                    timeline: '6-12 months post-submission'
                },
                fda: {
                    name: 'US FDA Comparison',
                    pathway: 'FDA Abbreviated New Drug Application (ANDA)',
                    timeline: '10-15 months post-submission'
                }
            };
            return info[regulatory];
        }

        function getMarginJustification(studyType, margin) {
            if (studyType === 'equivalence') {
                return `¬±${margin} units represents clinically acceptable difference range`;
            } else {
                return `-${margin} units preserves substantial portion of reference treatment benefit`;
            }
        }

        function getNextSteps(conclusion, regulatory) {
            if (conclusion.includes('demonstrated')) {
                return regulatory === 'generic' ? 'Prepare bioequivalence submission' :
                       regulatory === 'biosimilar' ? 'Proceed with comprehensive biosimilar dossier' :
                       'Complete regulatory submission package';
            } else {
                return 'Study redesign required - consider larger sample size or revised margins';
            }
        }

        function interpretClinicalEquivalence(studyType, diff, margin) {
            const absDiff = Math.abs(diff);
            if (studyType === 'equivalence') {
                if (absDiff < margin * 0.5) return 'Strong clinical equivalence';
                if (absDiff < margin) return 'Clinical equivalence within acceptable range';
                return 'Clinically meaningful difference detected';
            } else {
                if (diff < margin * 0.5) return 'Non-inferiority with strong evidence';
                if (diff < margin) return 'Non-inferiority demonstrated';
                return 'Inferiority cannot be ruled out';
            }
        }

        function getSafetyConsiderations(regulatory) {
            if (regulatory === 'generic') return 'Bioequivalence implies therapeutic equivalence';
            if (regulatory === 'biosimilar') return 'Additional immunogenicity and safety monitoring required';
            return 'Safety profile similar to reference product expected';
        }

        function getMarketAccess(conclusion, regulatory) {
            if (conclusion.includes('demonstrated')) {
                return regulatory === 'generic' ? 'Provincial formulary listing expected' :
                       'Health technology assessment required for reimbursement';
            } else {
                return 'Market access unlikely without successful equivalence demonstration';
            }
        }

        function getCostImplications(studyType, conclusion) {
            if (conclusion.includes('demonstrated')) {
                return studyType === 'equivalence' ? 'Cost savings through generic competition' :
                       'Potential cost savings with similar efficacy profile';
            } else {
                return 'Additional development costs for study redesign';
            }
        }

        function simulateSurvivalStudy() {
            const design = document.getElementById('survival-design').value;
            const nPerGroup = parseInt(document.getElementById('survival-n').value);
            const followupTime = parseInt(document.getElementById('followup-time').value);
            const hazardRatio = parseFloat(document.getElementById('hazard-ratio').value);
            const censoringRate = parseFloat(document.getElementById('censoring-rate').value) / 100;
            const context = document.getElementById('survival-context').value;

            // Generate survival data for two groups
            const group1Data = generateSurvivalData(nPerGroup, followupTime, 1.0, censoringRate); // Control/reference
            const group2Data = generateSurvivalData(nPerGroup, followupTime, hazardRatio, censoringRate); // Treatment/test
            
            // Calculate Kaplan-Meier estimates
            const km1 = calculateKaplanMeier(group1Data);
            const km2 = calculateKaplanMeier(group2Data);
            
            // Log-rank test
            const logRankTest = performLogRankTest(group1Data, group2Data);
            
            // Summary statistics
            const median1 = calculateMedianSurvival(km1);
            const median2 = calculateMedianSurvival(km2);
            const survival1At12 = getSurvivalAtTime(km1, 12);
            const survival2At12 = getSurvivalAtTime(km2, 12);
            
            // Event counts
            const events1 = group1Data.filter(p => p.event === 1).length;
            const events2 = group2Data.filter(p => p.event === 1).length;
            const censored1 = nPerGroup - events1;
            const censored2 = nPerGroup - events2;

            const contextInfo = getContextInfo(context);

            document.getElementById('survival-results').style.display = 'block';
            document.getElementById('survival-results').innerHTML = `
                <h4>Survival Analysis: ${contextInfo.title}</h4>
                
                <p><strong>Study Design:</strong></p>
                <p>‚Ä¢ Clinical context: ${contextInfo.description}</p>
                <p>‚Ä¢ Sample size per group: ${nPerGroup}</p>
                <p>‚Ä¢ Follow-up duration: ${followupTime} months</p>
                <p>‚Ä¢ Expected hazard ratio: ${hazardRatio}</p>
                <p>‚Ä¢ Primary endpoint: ${contextInfo.endpoint}</p>

                <p><strong>Study Population Summary:</strong></p>
                <table>
                    <tr><th>Group</th><th>N</th><th>Events</th><th>Censored</th><th>Event Rate</th></tr>
                    <tr>
                        <td>${contextInfo.group1}</td>
                        <td>${nPerGroup}</td>
                        <td>${events1}</td>
                        <td>${censored1}</td>
                        <td>${(events1/nPerGroup*100).toFixed(1)}%</td>
                    </tr>
                    <tr>
                        <td>${contextInfo.group2}</td>
                        <td>${nPerGroup}</td>
                        <td>${events2}</td>
                        <td>${censored2}</td>
                        <td>${(events2/nPerGroup*100).toFixed(1)}%</td>
                    </tr>
                </table>

                <p><strong>Kaplan-Meier Survival Estimates:</strong></p>
                <table>
                    <tr><th>Endpoint</th><th>${contextInfo.group1}</th><th>${contextInfo.group2}</th><th>Difference</th></tr>
                    <tr>
                        <td>Median survival (months)</td>
                        <td>${median1 ? median1.toFixed(1) : 'Not reached'}</td>
                        <td>${median2 ? median2.toFixed(1) : 'Not reached'}</td>
                        <td>${median1 && median2 ? (median2 - median1).toFixed(1) : 'N/A'}</td>
                    </tr>
                    <tr>
                        <td>12-month survival</td>
                        <td>${(survival1At12 * 100).toFixed(1)}%</td>
                        <td>${(survival2At12 * 100).toFixed(1)}%</td>
                        <td>${((survival2At12 - survival1At12) * 100).toFixed(1)}%</td>
                    </tr>
                </table>

                <p><strong>Log-rank Test Results:</strong></p>
                <p>‚Ä¢ Chi-square statistic: ${logRankTest.chiSquare.toFixed(3)}</p>
                <p>‚Ä¢ <span class="highlight">p-value: ${logRankTest.pValue.toFixed(4)}</span></p>
                <p>‚Ä¢ Degrees of freedom: 1</p>
                <p>‚Ä¢ Statistical conclusion: ${logRankTest.pValue < 0.05 ? 'Significant difference between groups' : 'No significant difference detected'}</p>

                <p><strong>Effect Size Estimation:</strong></p>
                <p>‚Ä¢ Observed hazard ratio: ${logRankTest.observedHR.toFixed(2)}</p>
                <p>‚Ä¢ HR interpretation: ${interpretHazardRatio(logRankTest.observedHR)}</p>
                <p>‚Ä¢ Risk reduction: ${((1 - logRankTest.observedHR) * 100).toFixed(1)}% ${logRankTest.observedHR < 1 ? 'reduction' : 'increase'}</p>

                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ Clinical significance: ${interpretClinicalSurvival(contextInfo, logRankTest.observedHR, logRankTest.pValue)}</p>
                <p>‚Ä¢ Number needed to treat: ${calculateNNT(survival1At12, survival2At12)}</p>
                <p>‚Ä¢ Years of life gained: ${calculateLifeYearsGained(median1, median2)}</p>
                
                <p><strong>Regulatory Considerations:</strong></p>
                <p>‚Ä¢ Primary analysis: ${getAnalysisComment(logRankTest.pValue, events1 + events2)}</p>
                <p>‚Ä¢ Censoring assessment: ${getCensoringComment(censoringRate)}</p>
                <p>‚Ä¢ Follow-up adequacy: ${getFollowupComment(followupTime, median1, median2)}</p>
                <p>‚Ä¢ Regulatory pathway: ${getRegulatoryComment(context, logRankTest.pValue)}</p>

                <p><strong>Study Limitations:</strong></p>
                <p>‚Ä¢ Proportional hazards assumption: ${checkProportionalHazards(hazardRatio)}</p>
                <p>‚Ä¢ Competing risks: ${getCompetingRisks(context)}</p>
                <p>‚Ä¢ Missing data impact: ${getMissingDataImpact(censoringRate)}</p>
            `;

            createSurvivalVisualization(km1, km2, contextInfo);
        }

        function generateSurvivalData(n, maxTime, hazardRatio, censorRate) {
            const data = [];
            for (let i = 0; i < n; i++) {
                // Exponential survival times with hazard adjustment
                const baseHazard = 0.02; // Monthly hazard
                const hazard = baseHazard * hazardRatio;
                const timeToEvent = -Math.log(Math.random()) / hazard;
                
                // Censoring time
                const censorTime = Math.random() < censorRate ? Math.random() * maxTime : maxTime;
                
                // Observed time and event indicator
                const observedTime = Math.min(timeToEvent, censorTime);
                const event = timeToEvent <= censorTime ? 1 : 0;
                
                data.push({
                    id: i + 1,
                    time: observedTime,
                    event: event
                });
            }
            
            return data.sort((a, b) => a.time - b.time);
        }

        function calculateKaplanMeier(data) {
            const times = [...new Set(data.filter(d => d.event === 1).map(d => d.time))].sort((a, b) => a - b);
            const kmEstimates = [];
            let survival = 1.0;
            
            for (const time of times) {
                const atRisk = data.filter(d => d.time >= time).length;
                const events = data.filter(d => d.time === time && d.event === 1).length;
                
                if (atRisk > 0) {
                    survival *= (1 - events / atRisk);
                }
                
                kmEstimates.push({
                    time: time,
                    survival: survival,
                    atRisk: atRisk,
                    events: events
                });
            }
            
            return kmEstimates;
        }

        function performLogRankTest(group1, group2) {
            const combinedData = [
                ...group1.map(d => ({...d, group: 1})),
                ...group2.map(d => ({...d, group: 2}))
            ].sort((a, b) => a.time - b.time);

            const uniqueTimes = [...new Set(combinedData.filter(d => d.event === 1).map(d => d.time))];
            
            let observedMinusExpected = 0;
            let variance = 0;
            
            for (const time of uniqueTimes) {
                const atRisk1 = combinedData.filter(d => d.time >= time && d.group === 1).length;
                const atRisk2 = combinedData.filter(d => d.time >= time && d.group === 2).length;
                const totalAtRisk = atRisk1 + atRisk2;
                
                const events1 = combinedData.filter(d => d.time === time && d.event === 1 && d.group === 1).length;
                const events2 = combinedData.filter(d => d.time === time && d.event === 1 && d.group === 2).length;
                const totalEvents = events1 + events2;
                
                if (totalAtRisk > 0 && totalEvents > 0) {
                    const expected1 = atRisk1 * totalEvents / totalAtRisk;
                    const varComponent = atRisk1 * atRisk2 * totalEvents * (totalAtRisk - totalEvents) / 
                                       (Math.pow(totalAtRisk, 2) * (totalAtRisk - 1));
                    
                    observedMinusExpected += events1 - expected1;
                    variance += varComponent;
                }
            }
            
            const chiSquare = variance > 0 ? Math.pow(observedMinusExpected, 2) / variance : 0;
            const pValue = variance > 0 ? 1 - chiSquareCDF(chiSquare, 1) : 1;
            
            // Estimate hazard ratio
            const events1 = group1.filter(d => d.event === 1).length;
            const events2 = group2.filter(d => d.event === 1).length;
            const totalTime1 = group1.reduce((sum, d) => sum + d.time, 0);
            const totalTime2 = group2.reduce((sum, d) => sum + d.time, 0);
            
            const hazardRate1 = events1 / totalTime1;
            const hazardRate2 = events2 / totalTime2;
            const observedHR = hazardRate2 / hazardRate1;
            
            return {
                chiSquare: chiSquare,
                pValue: pValue,
                observedHR: observedHR
            };
        }

        function calculateMedianSurvival(kmData) {
            const medianPoint = kmData.find(point => point.survival <= 0.5);
            return medianPoint ? medianPoint.time : null;
        }

        function getSurvivalAtTime(kmData, targetTime) {
            if (kmData.length === 0) return 1.0;
            
            // Find the last time point <= targetTime
            let survival = 1.0;
            for (const point of kmData) {
                if (point.time <= targetTime) {
                    survival = point.survival;
                } else {
                    break;
                }
            }
            return survival;
        }

        function getContextInfo(context) {
            const contexts = {
                cancer: {
                    title: 'Cancer Treatment Trial',
                    description: 'Comparing overall survival between treatment regimens',
                    endpoint: 'Overall survival (death from any cause)',
                    group1: 'Standard therapy',
                    group2: 'Experimental therapy'
                },
                cardiovascular: {
                    title: 'Cardiovascular Prevention Study',
                    description: 'Primary prevention of major cardiovascular events',
                    endpoint: 'Time to first major cardiovascular event',
                    group1: 'Placebo',
                    group2: 'Active treatment'
                },
                'chronic-disease': {
                    title: 'Chronic Disease Management',
                    description: 'Comparing disease progression between treatments',
                    endpoint: 'Time to disease progression',
                    group1: 'Standard care',
                    group2: 'Intensive management'
                },
                device: {
                    title: 'Medical Device Study',
                    description: 'Device failure time comparison',
                    endpoint: 'Time to device failure or replacement',
                    group1: 'Standard device',
                    group2: 'New device'
                }
            };
            return contexts[context];
        }

        function interpretHazardRatio(hr) {
            if (hr < 0.5) return 'Large reduction in hazard';
            if (hr < 0.75) return 'Moderate reduction in hazard';
            if (hr < 0.9) return 'Small reduction in hazard';
            if (hr < 1.1) return 'No meaningful difference';
            if (hr < 1.3) return 'Small increase in hazard';
            if (hr < 1.5) return 'Moderate increase in hazard';
            return 'Large increase in hazard';
        }

        function interpretClinicalSurvival(contextInfo, hr, pValue) {
            if (pValue >= 0.05) return 'No statistically significant survival benefit detected';
            
            if (contextInfo.title.includes('Cancer')) {
                if (hr < 0.8) return 'Clinically meaningful survival benefit for cancer patients';
                return 'Modest survival benefit - clinical significance unclear';
            } else if (contextInfo.title.includes('Cardiovascular')) {
                if (hr < 0.85) return 'Clinically important cardiovascular risk reduction';
                return 'Modest risk reduction - consider number needed to treat';
            }
            
            return hr < 0.85 ? 'Clinically significant improvement' : 'Modest benefit of unclear clinical importance';
        }

        function calculateNNT(control12mo, treatment12mo) {
            const absoluteRiskReduction = treatment12mo - control12mo;
            if (Math.abs(absoluteRiskReduction) < 0.01) return 'Cannot calculate (very small difference)';
            return Math.round(1 / Math.abs(absoluteRiskReduction));
        }

        function calculateLifeYearsGained(median1, median2) {
            if (!median1 || !median2) return 'Cannot calculate (median not reached)';
            const monthsGained = median2 - median1;
            const yearsGained = monthsGained / 12;
            return `${yearsGained.toFixed(1)} years`;
        }

        function getAnalysisComment(pValue, totalEvents) {
            if (totalEvents < 50) return 'Low event count - consider longer follow-up';
            if (pValue < 0.001) return 'Highly significant result suitable for regulatory submission';
            if (pValue < 0.05) return 'Statistically significant - adequate for primary analysis';
            return 'Non-significant result - consider alternative endpoints';
        }

        function getCensoringComment(rate) {
            if (rate < 0.1) return 'Low censoring rate - robust analysis';
            if (rate < 0.3) return 'Moderate censoring - check for informative censoring';
            return 'High censoring rate - assess impact on results validity';
        }

        function getFollowupComment(followup, median1, median2) {
            const maxMedian = Math.max(median1 || 0, median2 || 0);
            if (followup > maxMedian * 1.5) return 'Adequate follow-up for mature survival data';
            if (followup > maxMedian) return 'Reasonable follow-up - consider extended monitoring';
            return 'Limited follow-up - longer duration recommended';
        }

        function getRegulatoryComment(context, pValue) {
            if (context === 'cancer') {
                return pValue < 0.05 ? 'Eligible for Health Canada oncology review' : 
                       'Insufficient evidence for regulatory approval';
            }
            return pValue < 0.05 ? 'Supportive evidence for Health Canada submission' :
                   'Additional studies likely required';
        }

        function checkProportionalHazards(trueHR) {
            return trueHR > 0.5 && trueHR < 2.0 ? 
                   'Likely maintained (moderate hazard ratio)' :
                   'May be violated (extreme hazard ratio) - consider time-varying effects';
        }

        function getCompetingRisks(context) {
            if (context === 'cancer') return 'Consider competing mortality risks';
            if (context === 'cardiovascular') return 'Multiple cardiovascular events possible';
            return 'Assess for competing events in analysis';
        }

        function getMissingDataImpact(rate) {
            if (rate < 0.1) return 'Minimal impact expected';
            if (rate < 0.3) return 'Moderate impact - assess sensitivity';
            return 'High impact - comprehensive sensitivity analysis required';
        }
    </script>
</body>
</html>
