<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foundation Series: Hypothesis Testing in Medicine & Clinical Research</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f8fffe;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #20b2aa;
        }
        h1 {
            color: #dc143c;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        h2 {
            color: #dc143c;
            border-bottom: 3px solid #dc143c;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        h3 {
            color: #2f8b8b;
            margin-top: 25px;
        }
        .subtitle {
            text-align: center;
            color: #2f8b8b;
            font-size: 1.1em;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .foundation-badge {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            text-align: center;
            margin: 20px auto;
            display: inline-block;
            font-size: 0.9em;
        }
        .section {
            background: #f0ffff;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #2f8b8b;
        }
        .concept-intro {
            background: linear-gradient(to right, #e6f3ff, #f0f8ff);
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #4169e1;
            border-left: 6px solid #4169e1;
        }
        .concept {
            background: #e8fffe;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #20b2aa;
        }
        .controls {
            background: #f8ffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #20b2aa;
        }
        button {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .results {
            background: #ffffff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .chart-container {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #20b2aa;
            height: 400px;
            position: relative;
        }
        select, input {
            padding: 8px;
            margin: 5px;
            border: 2px solid #20b2aa;
            border-radius: 4px;
            background: white;
        }
        .formula {
            background: #f0f8ff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #2f8b8b;
            font-size: 0.95em;
        }
        .key-concept {
            background: #fff5ee;
            border: 2px solid #ff6347;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border-left: 6px solid #ff6347;
        }
        .clinical-context {
            background: linear-gradient(to right, #ffe8e8, #fff0f0);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .regulatory-box {
            background: linear-gradient(to right, #f0f8ff, #e6f3ff);
            border: 2px solid #4169e1;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .navigation {
            background: #e8fffe;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            border: 1px solid #20b2aa;
        }
        .nav-button {
            background: #2f8b8b;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .nav-button:hover {
            background: #20b2aa;
        }
        .section-content {
            display: none;
        }
        .section-content.active {
            display: block;
        }
        .power-visual {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #20b2aa;
            padding: 8px;
            text-align: left;
        }
        th {
            background: #2f8b8b;
            color: white;
        }
        tr:nth-child(even) {
            background: #f8fffe;
        }
        .highlight {
            background: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .assessment {
            background: linear-gradient(to right, #f0ffff, #e8fffe);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .question {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #20b2aa;
        }
        .when-to-use {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .assumptions-box {
            background: #fff8e1;
            border: 2px solid #ffa726;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Foundation Series: Hypothesis Testing in Medicine & Clinical Research</h1>
        <div class="subtitle">Statistical Inference for Evidence-Based Healthcare</div>
        
        <div class="foundation-badge">üî¨ FOUNDATION SERIES: From Research Questions to Statistical Evidence</div>

        <div class="navigation">
            <h3>Navigate Hypothesis Testing Foundations</h3>
            <button class="nav-button" onclick="showSection('framework')">Hypothesis Framework</button>
            <button class="nav-button" onclick="showSection('errors')">Errors & Power</button>
            <button class="nav-button" onclick="showSection('pvalues')">P-values & Significance</button>
            <button class="nav-button" onclick="showSection('means')">Comparing Means</button>
            <button class="nav-button" onclick="showSection('categorical')">Categorical Data</button>
            <button class="nav-button" onclick="showSection('nonparametric')">Non-parametric Tests</button>
            <button class="nav-button" onclick="showSection('diagnostic')">Diagnostic Tests</button>
            <button class="nav-button" onclick="showSection('equivalence')">Equivalence Testing</button>
            <button class="nav-button" onclick="showSection('survival')">Survival Analysis Intro</button>
            <button class="nav-button" onclick="showSection('assessment')">Assessment</button>
        </div>

        <!-- Section 1: Hypothesis Testing Framework (keeping original content) -->
        <div id="framework-section" class="section-content active">
            <div class="section">
                <h2>üéØ Hypothesis Testing Framework in Clinical Research</h2>
                
                <div class="concept-intro">
                    <h3>üìö What is Hypothesis Testing?</h3>
                    <p><strong>Hypothesis testing is the statistical method used to make decisions about populations based on sample data.</strong> In clinical research, it helps us answer questions like "Does this new treatment work better than standard care?" or "Is there a relationship between smoking and lung disease?"</p>
                    
                    <p><strong>Why it matters in healthcare:</strong> Medical decisions affect lives, so we need rigorous statistical evidence to distinguish real treatment effects from random chance. Hypothesis testing provides the framework for making these evidence-based decisions.</p>
                </div>

                <div class="concept">
                    <h3>Formulating Hypotheses: The Foundation of Scientific Inquiry</h3>
                    
                    <div class="key-concept">
                        <h4>üîç Key Concepts:</h4>
                        <p><strong>Null Hypothesis (H‚ÇÄ):</strong> "No effect" or "no difference" - what we assume is true unless proven otherwise</p>
                        <p><strong>Alternative Hypothesis (H‚ÇÅ or H‚Çê):</strong> What we want to demonstrate - the research claim</p>
                        <p><strong>PICO Framework:</strong> Patient/Population, Intervention, Comparison, Outcome - structures clinical questions</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Clinical Research Example:</h4>
                        <p><strong>Research Question:</strong> "Does the new antihypertensive drug reduce blood pressure more than standard treatment?"</p>
                        <p><strong>H‚ÇÄ:</strong> Œº_new - Œº_standard = 0 (no difference in mean blood pressure reduction)</p>
                        <p><strong>H‚ÇÅ:</strong> Œº_new - Œº_standard ‚â† 0 (there is a difference in mean reduction)</p>
                    </div>

                    <div class="controls">
                        <h4>Interactive Hypothesis Builder</h4>
                        <label>Research Area: 
                            <select id="research-area">
                                <option value="treatment">Treatment Effectiveness</option>
                                <option value="diagnosis">Diagnostic Accuracy</option>
                                <option value="prevention">Disease Prevention</option>
                                <option value="risk-factor">Risk Factor Association</option>
                            </select>
                        </label><br>
                        <label>Study Design: 
                            <select id="study-design">
                                <option value="rct">Randomized Controlled Trial</option>
                                <option value="cohort">Cohort Study</option>
                                <option value="case-control">Case-Control Study</option>
                                <option value="cross-sectional">Cross-sectional Study</option>
                            </select>
                        </label><br>
                        <label>Test Type: 
                            <select id="test-type">
                                <option value="two-sided">Two-sided (‚â†)</option>
                                <option value="one-sided-greater">One-sided (>)</option>
                                <option value="one-sided-less">One-sided (<)</option>
                            </select>
                        </label><br>
                        <button onclick="buildHypothesis()">Build Hypothesis Statement</button>
                    </div>

                    <div id="framework-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 2: Statistical Errors & Power -->
        <div id="errors-section" class="section-content">
            <div class="section">
                <h2>‚öñÔ∏è Statistical Errors & Power Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Understanding Statistical Errors</h3>
                    <p><strong>Statistical errors are inevitable in hypothesis testing because we're making decisions about populations based on samples.</strong> Understanding these errors is crucial for designing studies and interpreting results responsibly.</p>
                    
                    <p><strong>Why it matters in healthcare:</strong> Type I errors can lead to approving ineffective treatments, while Type II errors can prevent beneficial treatments from reaching patients. Both have serious consequences for public health.</p>
                </div>

                <div class="concept">
                    <h3>Types of Statistical Errors & Their Clinical Consequences</h3>
                    
                    <div class="key-concept">
                        <h4>üö® Error Types:</h4>
                        <p><strong>Type I Error (Œ±):</strong> Rejecting a true null hypothesis - "false positive"</p>
                        <p><strong>Type II Error (Œ≤):</strong> Failing to reject a false null hypothesis - "false negative"</p>
                        <p><strong>Statistical Power (1-Œ≤):</strong> Probability of correctly rejecting a false null hypothesis</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Clinical Consequences:</h4>
                        <p><strong>Type I Error in Drug Trials:</strong> Approving an ineffective drug ‚Üí Patients get false hope, healthcare costs increase, delay in finding real treatments</p>
                        <p><strong>Type II Error in Drug Trials:</strong> Missing an effective treatment ‚Üí Patients continue to suffer, beneficial therapy delayed</p>
                    </div>

                    <table style="margin: 15px 0;">
                        <tr><th>Reality \ Decision</th><th>Reject H‚ÇÄ</th><th>Fail to Reject H‚ÇÄ</th></tr>
                        <tr><td>H‚ÇÄ is True</td><td style="background: #ffe8e8;">Type I Error (Œ±)</td><td style="background: #e8ffe8;">Correct Decision</td></tr>
                        <tr><td>H‚ÇÄ is False</td><td style="background: #e8ffe8;">Correct Decision (Power)</td><td style="background: #ffe8e8;">Type II Error (Œ≤)</td></tr>
                    </table>

                    <div class="controls">
                        <h4>Interactive Power Analysis Calculator</h4>
                        <label>Effect Size (Cohen's d): <input type="number" id="effect-size" value="0.5" min="0.1" max="2.0" step="0.1"></label><br>
                        <label>Sample Size per Group: <input type="number" id="sample-size" value="50" min="10" max="200" step="5"></label><br>
                        <label>Significance Level (Œ±): <input type="number" id="alpha-level" value="0.05" min="0.01" max="0.10" step="0.01"></label><br>
                        <label>Clinical Context: 
                            <select id="clinical-context">
                                <option value="efficacy">Drug Efficacy Trial</option>
                                <option value="safety">Safety Study</option>
                                <option value="bioequivalence">Bioequivalence Study</option>
                                <option value="screening">Screening Test</option>
                            </select>
                        </label><br>
                        <button onclick="calculatePower()">Calculate Power & Sample Size</button>
                    </div>

                    <div id="errors-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="power-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Health Canada Guidelines:</h4>
                        <p>‚Ä¢ Standard significance level: Œ± = 0.05 (two-sided)</p>
                        <p>‚Ä¢ Minimum power requirement: 80% for pivotal trials</p>
                        <p>‚Ä¢ Sample size justification required in protocols</p>
                        <p>‚Ä¢ Interim analysis adjustments for multiple looks</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: P-values & Statistical Significance -->
        <div id="pvalues-section" class="section-content">
            <div class="section">
                <h2>üìä P-values & Statistical Significance</h2>
                
                <div class="concept-intro">
                    <h3>üìö Understanding P-values</h3>
                    <p><strong>A p-value is the probability of observing data as extreme or more extreme than what we observed, assuming the null hypothesis is true.</strong> It's NOT the probability that the null hypothesis is true, or that the results occurred by chance.</p>
                    
                    <p><strong>Why proper interpretation matters:</strong> Misunderstanding p-values leads to poor clinical decisions. P-values don't measure effect size, clinical importance, or the probability that a treatment works.</p>
                </div>

                <div class="concept">
                    <h3>P-value Interpretation & Multiple Testing</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Correct P-value Interpretation:</h4>
                        <p><strong>p < 0.05 means:</strong> If the null hypothesis were true, we'd see data this extreme or more extreme less than 5% of the time</p>
                        <p><strong>p < 0.05 does NOT mean:</strong> The null hypothesis has only 5% chance of being true, or the result has 95% chance of being "real"</p>
                        <p><strong>Clinical vs Statistical Significance:</strong> A tiny, clinically meaningless difference can be statistically significant with large samples</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Multiple Testing Problem:</h4>
                        <p><strong>The Problem:</strong> Testing multiple endpoints increases chance of false positive findings</p>
                        <p><strong>Example:</strong> Testing 20 safety parameters at Œ±=0.05 ‚Üí Expected 1 false positive even if drug is completely safe</p>
                        <p><strong>Solutions:</strong> Bonferroni correction, False Discovery Rate (FDR), pre-specified primary endpoints</p>
                    </div>

                    <div class="formula">
                        Multiple Testing Corrections:
                        <br>Bonferroni: Œ±_adjusted = Œ± / number_of_tests
                        <br>Holm-Bonferroni: Sequential adjustment starting with smallest p-value
                        <br>FDR (Benjamini-Hochberg): Controls proportion of false discoveries
                    </div>

                    <div class="controls">
                        <h4>P-value Simulation & Multiple Testing</h4>
                        <label>Number of Comparisons: <input type="number" id="num-comparisons" value="10" min="1" max="50" step="1"></label><br>
                        <label>True Effect Present: 
                            <select id="true-effect">
                                <option value="none">No Real Effects (All H‚ÇÄ True)</option>
                                <option value="some">Some Real Effects (Mixed)</option>
                                <option value="all">All Real Effects (All H‚ÇÄ False)</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Test: <input type="number" id="pvalue-sample" value="100" min="20" max="500" step="20"></label><br>
                        <label>Correction Method: 
                            <select id="correction-method">
                                <option value="none">No Correction</option>
                                <option value="bonferroni">Bonferroni</option>
                                <option value="holm">Holm-Bonferroni</option>
                                <option value="fdr">False Discovery Rate</option>
                            </select>
                        </label><br>
                        <button onclick="simulateMultipleTesting()">Simulate Multiple Testing</button>
                    </div>

                    <div id="pvalues-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="pvalue-chart"></canvas>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è P-hacking Prevention:</h4>
                        <p>‚Ä¢ Pre-register primary hypotheses and analysis plans</p>
                        <p>‚Ä¢ Distinguish exploratory vs confirmatory analyses</p>
                        <p>‚Ä¢ Report all tested comparisons, not just significant ones</p>
                        <p>‚Ä¢ Use appropriate multiple testing corrections</p>
                        <p>‚Ä¢ Focus on effect sizes and confidence intervals alongside p-values</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Comparing Means -->
        <div id="means-section" class="section-content">
            <div class="section">
                <h2>üìà Comparing Means in Clinical Research</h2>
                
                <div class="concept-intro">
                    <h3>üìö When Do We Compare Means?</h3>
                    <p><strong>Comparing means is fundamental in clinical research when our outcome is continuous</strong> (blood pressure, cholesterol levels, quality of life scores, biomarker concentrations). We use different tests depending on study design and data characteristics.</p>
                    
                    <p><strong>Clinical applications:</strong> Drug efficacy trials comparing treatment groups, before/after treatment analysis, dose-response studies, multi-center trials with site effects.</p>
                </div>

                <div class="concept">
                    <h3>t-Tests and ANOVA for Clinical Data</h3>
                    
                    <div class="key-concept">
                        <h4>üî¨ Test Selection Guide:</h4>
                        <p><strong>One-sample t-test:</strong> Compare sample mean to known standard (e.g., normal lab values)</p>
                        <p><strong>Two-sample t-test:</strong> Compare two independent groups (treatment vs control)</p>
                        <p><strong>Paired t-test:</strong> Compare before/after measurements on same patients</p>
                        <p><strong>ANOVA:</strong> Compare three or more groups simultaneously</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è Assumptions for t-tests:</h4>
                        <p>‚Ä¢ <strong>Normality:</strong> Data approximately normally distributed (or large sample)</p>
                        <p>‚Ä¢ <strong>Independence:</strong> Observations independent of each other</p>
                        <p>‚Ä¢ <strong>Equal variances:</strong> Similar variability in both groups (for two-sample)</p>
                        <p>‚Ä¢ <strong>What if violated?</strong> Use non-parametric alternatives or data transformations</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Canadian Clinical Trial Example:</h4>
                        <p><strong>Study:</strong> Health Canada-approved diabetes medication trial across 5 Canadian centers</p>
                        <p><strong>Design:</strong> Randomized, double-blind, placebo-controlled</p>
                        <p><strong>Primary outcome:</strong> Change in HbA1c from baseline to 12 weeks</p>
                        <p><strong>Analysis:</strong> Two-sample t-test comparing mean change between groups</p>
                    </div>

                    <div class="controls">
                        <h4>Interactive Clinical Trial Analyzer</h4>
                        <label>Study Type: 
                            <select id="study-type">
                                <option value="independent">Two Independent Groups</option>
                                <option value="paired">Before/After (Paired)</option>
                                <option value="anova">Multiple Groups (ANOVA)</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="means-sample-size" value="80" min="20" max="200" step="10"></label><br>
                        <label>Expected Effect Size: <input type="number" id="means-effect" value="0.5" min="0.1" max="1.5" step="0.1"></label><br>
                        <label>Clinical Outcome: 
                            <select id="clinical-outcome">
                                <option value="hba1c">HbA1c Change (%)</option>
                                <option value="bp">Blood Pressure (mmHg)</option>
                                <option value="cholesterol">LDL Cholesterol (mg/dL)</option>
                                <option value="pain">Pain Score (0-10)</option>
                            </select>
                        </label><br>
                        <button onclick="simulateMeansTest()">Simulate Clinical Trial</button>
                    </div>

                    <div id="means-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="means-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Regulatory Considerations:</h4>
                        <p>‚Ä¢ <strong>Primary endpoint:</strong> Must be pre-specified and clinically meaningful</p>
                        <p>‚Ä¢ <strong>Minimal clinically important difference:</strong> Define before study start</p>
                        <p>‚Ä¢ <strong>Missing data handling:</strong> Intent-to-treat vs per-protocol analysis</p>
                        <p>‚Ä¢ <strong>Non-inferiority margins:</strong> Must be justified if testing non-inferiority</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 5: Categorical Data Analysis -->
        <div id="categorical-section" class="section-content">
            <div class="section">
                <h2>üìã Categorical Data Analysis in Healthcare</h2>
                
                <div class="concept-intro">
                    <h3>üìö Working with Categorical Outcomes</h3>
                    <p><strong>Many medical outcomes are categorical rather than continuous</strong> - cure/no cure, adverse event/no event, disease/no disease, treatment response categories. These require different statistical approaches than continuous data.</p>
                    
                    <p><strong>Clinical importance:</strong> Safety analysis (counting adverse events), efficacy studies with binary outcomes, risk factor identification, diagnostic test evaluation.</p>
                </div>

                <div class="concept">
                    <h3>Chi-square Tests & Exact Methods</h3>
                    
                    <div class="key-concept">
                        <h4>üßÆ Test Selection for Categorical Data:</h4>
                        <p><strong>Chi-square test of independence:</strong> Test association between two categorical variables</p>
                        <p><strong>Fisher's exact test:</strong> Exact p-values when sample sizes are small</p>
                        <p><strong>McNemar's test:</strong> For paired/matched data (before/after, matched case-control)</p>
                        <p><strong>Chi-square goodness of fit:</strong> Test if data follows expected distribution</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è When to Use Each Test:</h4>
                        <p>‚Ä¢ <strong>Chi-square test:</strong> Expected frequency ‚â•5 in all cells</p>
                        <p>‚Ä¢ <strong>Fisher's exact:</strong> Small samples or sparse tables</p>
                        <p>‚Ä¢ <strong>McNemar's test:</strong> Paired binary data (same subjects measured twice)</p>
                        <p>‚Ä¢ <strong>Cochran-Mantel-Haenszel:</strong> Controlling for confounding variables</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Healthcare Examples:</h4>
                        <p><strong>Safety Analysis:</strong> Compare adverse event rates between treatment and placebo</p>
                        <p><strong>Case-Control Study:</strong> Association between smoking history and lung cancer</p>
                        <p><strong>Matched Pairs:</strong> Treatment response before and after intervention</p>
                        <p><strong>Diagnostic Study:</strong> Agreement between two diagnostic methods</p>
                    </div>

                    <div class="formula">
                        2x2 Contingency Table Analysis:
                        <br>Chi-square = Œ£[(Observed - Expected)¬≤ / Expected]
                        <br>Odds Ratio = (ad)/(bc) where a,b,c,d are cell counts
                        <br>Fisher's exact p-value uses hypergeometric distribution
                        <br>McNemar's test = (|b-c|-1)¬≤/(b+c) for discordant pairs
                    </div>

                    <div class="controls">
                        <h4>Categorical Data Analysis Simulator</h4>
                        <label>Study Design: 
                            <select id="categorical-design">
                                <option value="independent">Two Independent Groups</option>
                                <option value="case-control">Case-Control Study</option>
                                <option value="matched">Matched Pairs</option>
                                <option value="dose-response">Dose-Response (Trend)</option>
                            </select>
                        </label><br>
                        <label>Sample Size: <input type="number" id="categorical-n" value="200" min="50" max="1000" step="50"></label><br>
                        <label>Effect Size (OR): <input type="number" id="categorical-or" value="2.0" min="0.5" max="5.0" step="0.2"></label><br>
                        <label>Outcome Type: 
                            <select id="categorical-outcome">
                                <option value="adverse-event">Adverse Events</option>
                                <option value="treatment-response">Treatment Response</option>
                                <option value="disease-risk">Disease Risk Factor</option>
                                <option value="diagnostic-test">Diagnostic Test Result</option>
                            </select>
                        </label><br>
                        <button onclick="analyzeCategoricalData()">Analyze Categorical Data</button>
                    </div>

                    <div id="categorical-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="categorical-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° Clinical Decision Guidelines:</h4>
                        <p>‚Ä¢ <strong>Risk ratios:</strong> Better for common outcomes (>10%)</p>
                        <p>‚Ä¢ <strong>Odds ratios:</strong> Approximate risk ratios for rare outcomes</p>
                        <p>‚Ä¢ <strong>Number needed to treat:</strong> 1/absolute risk reduction for clinical interpretation</p>
                        <p>‚Ä¢ <strong>Consider confounders:</strong> Age, sex, comorbidities often affect relationships</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 6: Non-parametric Tests -->
        <div id="nonparametric-section" class="section-content">
            <div class="section">
                <h2>üìä Non-parametric Tests: When Assumptions Fail</h2>
                
                <div class="concept-intro">
                    <h3>üìö Why Non-parametric Methods?</h3>
                    <p><strong>Medical data often violates the assumptions required for standard t-tests and ANOVA</strong> - data may be skewed, have outliers, or be measured on ordinal scales. Non-parametric tests make fewer assumptions about data distribution.</p>
                    
                    <p><strong>Common in healthcare:</strong> Pain scores, quality of life measures, biomarker levels with extreme outliers, time-to-event data, small sample sizes where normality can't be assumed.</p>
                </div>

                <div class="concept">
                    <h3>Distribution-Free Statistical Methods</h3>
                    
                    <div class="key-concept">
                        <h4>üîß Non-parametric Test Arsenal:</h4>
                        <p><strong>Mann-Whitney U (Wilcoxon rank-sum):</strong> Two independent groups (alternative to t-test)</p>
                        <p><strong>Wilcoxon signed-rank:</strong> Paired data (alternative to paired t-test)</p>
                        <p><strong>Kruskal-Wallis:</strong> Three or more groups (alternative to ANOVA)</p>
                        <p><strong>Spearman correlation:</strong> Monotonic relationships (alternative to Pearson)</p>
                    </div>

                    <div class="assumptions-box">
                        <h4>‚ö†Ô∏è When to Use Non-parametric Tests:</h4>
                        <p>‚Ä¢ <strong>Skewed data:</strong> Cannot be normalized by transformation</p>
                        <p>‚Ä¢ <strong>Ordinal scales:</strong> Data measured on ranking scales</p>
                        <p>‚Ä¢ <strong>Small samples:</strong> Cannot verify normality assumption</p>
                        <p>‚Ä¢ <strong>Outliers:</strong> Extreme values that shouldn't be excluded</p>
                        <p>‚Ä¢ <strong>Trade-off:</strong> Robust but less powerful than parametric tests when assumptions are met</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Healthcare Applications:</h4>
                        <p><strong>Pain Studies:</strong> Visual analog scale scores (0-10) often skewed</p>
                        <p><strong>Quality of Life:</strong> SF-36 scores with ceiling/floor effects</p>
                        <p><strong>Biomarkers:</strong> Inflammatory markers with log-normal distribution</p>
                        <p><strong>Time Measurements:</strong> Hospital length of stay with extreme outliers</p>
                    </div>

                    <div class="formula">
                        Non-parametric Test Statistics:
                        <br>Mann-Whitney U: U = n‚ÇÅn‚ÇÇ + n‚ÇÅ(n‚ÇÅ+1)/2 - R‚ÇÅ
                        <br>Wilcoxon signed-rank: W = sum of positive ranks
                        <br>Kruskal-Wallis: H = [12/N(N+1)] Œ£(R¬≤·µ¢/n·µ¢) - 3(N+1)
                        <br>All based on ranks rather than actual values
                    </div>

                    <div class="controls">
                        <h4>Non-parametric Test Comparison Tool</h4>
                        <label>Data Distribution: 
                            <select id="data-distribution">
                                <option value="normal">Normal (for comparison)</option>
                                <option value="skewed">Right-skewed</option>
                                <option value="outliers">Normal with outliers</option>
                                <option value="ordinal">Ordinal scale</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="nonpar-sample" value="50" min="10" max="200" step="10"></label><br>
                        <label>True Effect Size: <input type="number" id="nonpar-effect" value="0.5" min="0" max="1.5" step="0.1"></label><br>
                        <label>Clinical Scenario: 
                            <select id="nonpar-scenario">
                                <option value="pain">Pain Score Comparison</option>
                                <option value="biomarker">Biomarker Levels</option>
                                <option value="qol">Quality of Life Assessment</option>
                                <option value="los">Hospital Length of Stay</option>
                            </select>
                        </label><br>
                        <button onclick="compareParametricNonparametric()">Compare Test Methods</button>
                    </div>

                    <div id="nonparametric-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="nonparametric-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° Decision Framework:</h4>
                        <p>‚Ä¢ <strong>First choice:</strong> Check assumptions for parametric tests</p>
                        <p>‚Ä¢ <strong>Transformation:</strong> Try log, square root, or other transformations</p>
                        <p>‚Ä¢ <strong>Non-parametric:</strong> When transformations don't help</p>
                        <p>‚Ä¢ <strong>Report both:</strong> If borderline, show parametric and non-parametric results</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 7: Diagnostic Test Evaluation -->
        <div id="diagnostic-section" class="section-content">
            <div class="section">
                <h2>üî¨ Diagnostic Test Evaluation & ROC Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Evaluating Medical Tests</h3>
                    <p><strong>Diagnostic tests are fundamental tools in medicine, but no test is perfect.</strong> We need statistical methods to quantify how well tests discriminate between diseased and healthy patients, and to establish optimal cut-points for clinical decision-making.</p>
                    
                    <p><strong>Clinical importance:</strong> Laboratory test validation, imaging interpretation, screening program development, clinical decision support tools, biomarker discovery.</p>
                </div>

                <div class="concept">
                    <h3>Sensitivity, Specificity & ROC Curves</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Diagnostic Performance Measures:</h4>
                        <p><strong>Sensitivity:</strong> Proportion of diseased patients correctly identified (true positive rate)</p>
                        <p><strong>Specificity:</strong> Proportion of healthy patients correctly identified (true negative rate)</p>
                        <p><strong>Positive Predictive Value (PPV):</strong> Probability disease is present given positive test</p>
                        <p><strong>Negative Predictive Value (NPV):</strong> Probability disease is absent given negative test</p>
                    </div>

                    <div class="clinical-context">
                        <h4>The 2x2 Diagnostic Table:</h4>
                        <table style="margin: 15px 0;">
                            <tr><th></th><th>Disease +</th><th>Disease -</th><th>Total</th></tr>
                            <tr><th>Test +</th><td>a (TP)</td><td>b (FP)</td><td>a+b</td></tr>
                            <tr><th>Test -</th><td>c (FN)</td><td>d (TN)</td><td>c+d</td></tr>
                            <tr><th>Total</th><td>a+c</td><td>b+d</td><td>n</td></tr>
                        </table>
                        <p><strong>Sensitivity = a/(a+c)</strong> | <strong>Specificity = d/(b+d)</strong></p>
                        <p><strong>PPV = a/(a+b)</strong> | <strong>NPV = d/(c+d)</strong></p>
                    </div>

                    <div class="formula">
                        ROC Analysis:
                        <br>ROC Curve: Plot Sensitivity vs (1-Specificity) for all cut-points
                        <br>AUC: Area Under ROC Curve (0.5 = random, 1.0 = perfect)
                        <br>Likelihood Ratio +: Sensitivity / (1-Specificity)
                        <br>Likelihood Ratio -: (1-Sensitivity) / Specificity
                        <br>DOR (Diagnostic Odds Ratio): LR+ / LR-
                    </div>

                    <div class="controls">
                        <h4>Diagnostic Test Simulator</h4>
                        <label>Disease Prevalence (%): <input type="number" id="prevalence" value="20" min="1" max="50" step="1"></label><br>
                        <label>Total Sample Size: <input type="number" id="diagnostic-n" value="500" min="100" max="2000" step="100"></label><br>
                        <label>Test Performance: 
                            <select id="test-performance">
                                <option value="excellent">Excellent (AUC ~0.9)</option>
                                <option value="good">Good (AUC ~0.8)</option>
                                <option value="moderate">Moderate (AUC ~0.7)</option>
                                <option value="poor">Poor (AUC ~0.6)</option>
                            </select>
                        </label><br>
                        <label>Clinical Setting: 
                            <select id="clinical-setting">
                                <option value="screening">Population Screening</option>
                                <option value="diagnostic">Diagnostic Workup</option>
                                <option value="monitoring">Disease Monitoring</option>
                                <option value="research">Research Biomarker</option>
                            </select>
                        </label><br>
                        <button onclick="simulateDiagnosticTest()">Simulate Diagnostic Study</button>
                    </div>

                    <div id="diagnostic-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="diagnostic-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Regulatory Requirements:</h4>
                        <p>‚Ä¢ <strong>Health Canada Class II/III devices:</strong> Clinical validation required</p>
                        <p>‚Ä¢ <strong>Companion diagnostics:</strong> Co-development with therapeutic</p>
                        <p>‚Ä¢ <strong>Laboratory standards:</strong> ISO 15189 quality management</p>
                        <p>‚Ä¢ <strong>Clinical utility:</strong> Must demonstrate impact on patient outcomes</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 8: Equivalence & Non-inferiority Testing - FIXED -->
        <div id="equivalence-section" class="section-content">
            <div class="section">
                <h2>‚öñÔ∏è Equivalence & Non-inferiority Testing</h2>
                
                <div class="concept-intro">
                    <h3>üìö When "No Difference" is the Goal</h3>
                    <p><strong>Sometimes we want to show that treatments are equivalent or that a new treatment is "not worse" than standard care.</strong> This requires different statistical approaches because we're trying to demonstrate similarity rather than difference.</p>
                    
                    <p><strong>Clinical applications:</strong> Generic drug approval, biosimilar studies, showing new treatment has similar efficacy with better safety profile, device comparisons, cost-effectiveness when treatments are clinically equivalent.</p>
                </div>

                <div class="concept">
                    <h3>Equivalence vs Non-inferiority Designs</h3>
                    
                    <div class="key-concept">
                        <h4>üéØ Design Types:</h4>
                        <p><strong>Equivalence:</strong> Show treatments are clinically similar (within equivalence margins)</p>
                        <p><strong>Non-inferiority:</strong> Show new treatment is not worse than reference by more than margin</p>
                        <p><strong>Superiority:</strong> Show new treatment is better than reference (traditional approach)</p>
                        <p><strong>Key insight:</strong> Must define clinically meaningful margins BEFORE study</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Canadian Examples:</h4>
                        <p><strong>Generic Drugs:</strong> Bioequivalence studies showing 80-125% of reference drug exposure</p>
                        <p><strong>Biosimilars:</strong> Non-inferiority for efficacy, equivalence for safety</p>
                        <p><strong>Medical Devices:</strong> New device not inferior to predicate device</p>
                        <p><strong>Cost Considerations:</strong> New treatment similar efficacy but lower cost</p>
                    </div>

                    <div class="formula">
                        Equivalence Testing:
                        <br>H‚ÇÄ: |Œº‚ÇÅ - Œº‚ÇÇ| ‚â• Œ¥ (treatments differ by ‚â• margin)
                        <br>H‚ÇÅ: |Œº‚ÇÅ - Œº‚ÇÇ| < Œ¥ (treatments equivalent)
                        <br><br>
                        Non-inferiority Testing:
                        <br>H‚ÇÄ: Œº‚ÇÅ - Œº‚ÇÇ ‚â§ -Œ¥ (new treatment inferior)
                        <br>H‚ÇÅ: Œº‚ÇÅ - Œº‚ÇÇ > -Œ¥ (new treatment non-inferior)
                    </div>

                    <div class="controls">
                        <h4>Equivalence Study Designer</h4>
                        <label>Study Type: 
                            <select id="equivalence-type">
                                <option value="equivalence">Equivalence (Generic Drug)</option>
                                <option value="non-inferiority">Non-inferiority (Biosimilar)</option>
                                <option value="superiority">Superiority (for comparison)</option>
                            </select>
                        </label><br>
                        <label>Equivalence Margin: <input type="number" id="equivalence-margin" value="5" min="1" max="20" step="1"> (clinical units)</label><br>
                        <label>True Difference: <input type="number" id="true-difference" value="2" min="0" max="10" step="0.5"> (actual difference)</label><br>
                        <label>Standard Deviation: <input type="number" id="equiv-sd" value="15" min="5" max="30" step="1"></label><br>
                        <label>Regulatory Context: 
                            <select id="regulatory-context">
                                <option value="generic">Generic Drug (Health Canada)</option>
                                <option value="biosimilar">Biosimilar (Health Canada)</option>
                                <option value="device">Medical Device (Health Canada)</option>
                                <option value="fda">US FDA Comparison</option>
                            </select>
                        </label><br>
                        <button onclick="designEquivalenceStudy()">Design Equivalence Study</button>
                    </div>

                    <div id="equivalence-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="equivalence-chart"></canvas>
                    </div>

                    <div class="regulatory-box">
                        <h4>üá®üá¶ Health Canada Guidelines:</h4>
                        <p>‚Ä¢ <strong>Bioequivalence:</strong> 90% CI for ratio must be within 80-125%</p>
                        <p>‚Ä¢ <strong>Biosimilars:</strong> Stepwise approach starting with analytical similarity</p>
                        <p>‚Ä¢ <strong>Margin justification:</strong> Must preserve substantial portion of active control effect</p>
                        <p>‚Ä¢ <strong>Intent-to-treat:</strong> Primary analysis for non-inferiority</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 9: Survival Analysis Introduction - FIXED -->
        <div id="survival-section" class="section-content">
            <div class="section">
                <h2>‚è±Ô∏è Introduction to Survival Analysis</h2>
                
                <div class="concept-intro">
                    <h3>üìö Time-to-Event Data in Medicine</h3>
                    <p><strong>Many medical outcomes are defined by when they occur, not just if they occur.</strong> Survival analysis handles time-to-event data where we track patients until they experience an event (death, disease recurrence, treatment failure) or are lost to follow-up.</p>
                    
                    <p><strong>Why special methods needed:</strong> Standard statistical methods can't handle censored data (incomplete observations where we only know the event hadn't occurred by last follow-up).</p>
                </div>

                <div class="concept">
                    <h3>Kaplan-Meier Estimation & Log-rank Test</h3>
                    
                    <div class="key-concept">
                        <h4>‚è∞ Key Survival Concepts:</h4>
                        <p><strong>Event:</strong> Outcome of interest (death, relapse, cure, adverse event)</p>
                        <p><strong>Censoring:</strong> Incomplete observations (lost to follow-up, study ends, competing events)</p>
                        <p><strong>Survival function S(t):</strong> Probability of surviving beyond time t</p>
                        <p><strong>Hazard function h(t):</strong> Instantaneous risk of event at time t</p>
                    </div>

                    <div class="clinical-context">
                        <h4>Medical Applications:</h4>
                        <p><strong>Oncology:</strong> Overall survival, progression-free survival, time to treatment failure</p>
                        <p><strong>Cardiology:</strong> Time to first cardiac event, device failure time</p>
                        <p><strong>Infectious Disease:</strong> Time to cure, time to viral clearance</p>
                        <p><strong>Chronic Disease:</strong> Time to disease progression, medication adherence duration</p>
                    </div>

                    <div class="formula">
                        Kaplan-Meier Estimator:
                        <br>≈ú(t) = ‚àè[t·µ¢‚â§t] (1 - d·µ¢/n·µ¢)
                        <br>where d·µ¢ = events at time t·µ¢, n·µ¢ = at risk at time t·µ¢
                        <br><br>
                        Log-rank Test:
                        <br>Compares survival curves between groups
                        <br>Chi-square test on observed vs expected events
                    </div>

                    <div class="controls">
                        <h4>Survival Analysis Simulator</h4>
                        <label>Study Design: 
                            <select id="survival-design">
                                <option value="treatment-comparison">Treatment vs Control</option>
                                <option value="prognostic-factor">Prognostic Factor Study</option>
                                <option value="dose-response">Dose-Response Analysis</option>
                                <option value="quality-study">Quality of Life Impact</option>
                            </select>
                        </label><br>
                        <label>Sample Size per Group: <input type="number" id="survival-n" value="100" min="50" max="500" step="25"></label><br>
                        <label>Follow-up Duration (months): <input type="number" id="followup-time" value="24" min="6" max="60" step="6"></label><br>
                        <label>Hazard Ratio: <input type="number" id="hazard-ratio" value="0.7" min="0.3" max="2.0" step="0.1"></label><br>
                        <label>Censoring Rate (%): <input type="number" id="censoring-rate" value="20" min="5" max="50" step="5"></label><br>
                        <label>Clinical Context: 
                            <select id="survival-context">
                                <option value="cancer">Cancer Treatment Trial</option>
                                <option value="cardiovascular">Cardiovascular Prevention</option>
                                <option value="chronic-disease">Chronic Disease Management</option>
                                <option value="device">Medical Device Study</option>
                            </select>
                        </label><br>
                        <button onclick="simulateSurvivalStudy()">Simulate Survival Study</button>
                    </div>

                    <div id="survival-results" class="results" style="display:none;">
                        <!-- Results populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="survival-chart"></canvas>
                    </div>

                    <div class="when-to-use">
                        <h4>üí° When to Use Survival Analysis:</h4>
                        <p>‚Ä¢ <strong>Time matters:</strong> Not just if event occurs, but when</p>
                        <p>‚Ä¢ <strong>Censored data:</strong> Some patients haven't experienced event by study end</p>
                        <p>‚Ä¢ <strong>Competing risks:</strong> Multiple possible outcomes</p>
                        <p>‚Ä¢ <strong>Advanced methods:</strong> Cox regression for multiple covariates</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Assessment Section - FIXED -->
        <div id="assessment-section" class="section-content">
            <div class="assessment">
                <h2>üß† Hypothesis Testing Assessment</h2>
                <p>Test your understanding of hypothesis testing concepts in clinical research. Questions rotate each session.</p>
                <button onclick="generateHypothesisQuestions()">Generate New Questions</button>
                
                <div id="hypothesis-questions-container">
                    <!-- Questions will be populated by JavaScript -->
                </div>
                
                <button onclick="checkHypothesisAnswers()" id="hypothesis-check-btn" style="display:none;">Check Answers</button>
                <div id="hypothesis-assessment-results"></div>
            </div>
        </div>
    </div>

    <script>
        let currentHypothesisQuestions = [];
        let charts = {};
        
        // Navigation functionality
        function showSection(sectionName) {
            const sections = document.querySelectorAll('.section-content');
            sections.forEach(section => {
                section.classList.remove('active');
            });
            
            const selectedSection = document.getElementById(sectionName + '-section');
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
        }

        // Utility functions
        function generateNormalData(n, mean, sd) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const u = Math.random();
                const v = Math.random();
                const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
                data.push(mean + z * sd);
            }
            return data;
        }

        function mean(data) {
            return data.reduce((a, b) => a + b, 0) / data.length;
        }

        function variance(data) {
            const m = mean(data);
            return data.reduce((sum, x) => sum + Math.pow(x - m, 2), 0) / (data.length - 1);
        }

        function normalCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function erf(x) {
            const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
            const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        function chiSquareCDF(x, df) {
            if (df === 1) return 2 * normalCDF(Math.sqrt(x)) - 1;
            if (df === 2) return 1 - Math.exp(-x / 2);
            return 1 - Math.exp(-x / 2);
        }

        // Section 1: Build Hypothesis
        function buildHypothesis() {
            const researchArea = document.getElementById('research-area').value;
            const studyDesign = document.getElementById('study-design').value;
            const testType = document.getElementById('test-type').value;

            const scenarios = {
                treatment: {
                    rct: {
                        question: "Does the new antihypertensive medication reduce systolic blood pressure more than placebo?",
                        population: "Adults with stage 1 hypertension (SBP 130-139 mmHg)",
                        intervention: "New ACE inhibitor (study drug)",
                        comparison: "Matching placebo",
                        outcome: "Change in systolic BP from baseline to 12 weeks"
                    }
                }
            };

            const scenario = scenarios[researchArea]?.[studyDesign] || scenarios.treatment.rct;
            
            let nullHypothesis, altHypothesis, statisticalTest;
            
            switch (testType) {
                case 'two-sided':
                    nullHypothesis = "H‚ÇÄ: There is no difference between intervention and comparison groups";
                    altHypothesis = "H‚ÇÅ: There is a difference between intervention and comparison groups";
                    statisticalTest = "Two-sided test (Œ± = 0.05)";
                    break;
                case 'one-sided-greater':
                    nullHypothesis = "H‚ÇÄ: Intervention is not superior to comparison";
                    altHypothesis = "H‚ÇÅ: Intervention is superior to comparison";
                    statisticalTest = "One-sided superiority test (Œ± = 0.05)";
                    break;
                case 'one-sided-less':
                    nullHypothesis = "H‚ÇÄ: Intervention is not inferior to comparison";
                    altHypothesis = "H‚ÇÅ: Intervention is non-inferior to comparison";
                    statisticalTest = "One-sided non-inferiority test (Œ± = 0.025)";
                    break;
            }

            document.getElementById('framework-results').style.display = 'block';
            document.getElementById('framework-results').innerHTML = `
                <h4>Research Hypothesis Framework</h4>
                
                <p><strong>PICO Framework:</strong></p>
                <p><strong>P (Population):</strong> ${scenario.population}</p>
                <p><strong>I (Intervention):</strong> ${scenario.intervention}</p>
                <p><strong>C (Comparison):</strong> ${scenario.comparison}</p>
                <p><strong>O (Outcome):</strong> ${scenario.outcome}</p>
                
                <p><strong>Research Question:</strong></p>
                <p>${scenario.question}</p>
                
                <p><strong>Statistical Hypotheses:</strong></p>
                <p><strong>${nullHypothesis}</strong></p>
                <p><strong>${altHypothesis}</strong></p>
                
                <p><strong>Analysis Plan:</strong></p>
                <p>‚Ä¢ Statistical test: ${statisticalTest}</p>
                <p>‚Ä¢ Study design: ${studyDesign.toUpperCase()}</p>
                <p>‚Ä¢ Primary endpoint: ${scenario.outcome}</p>
                <p>‚Ä¢ Regulatory pathway: Health Canada New Drug Submission (NDS)</p>
            `;
        }

        // Equivalence Testing Functions - IMPLEMENTED
        function designEquivalenceStudy() {
            console.log('üöÄ Starting equivalence study design...');
            
            try {
                const studyType = document.getElementById('equivalence-type')?.value || 'equivalence';
                const margin = parseFloat(document.getElementById('equivalence-margin')?.value) || 5;
                const trueDifference = parseFloat(document.getElementById('true-difference')?.value) || 2;
                const sd = parseFloat(document.getElementById('equiv-sd')?.value) || 15;
                const regulatory = document.getElementById('regulatory-context')?.value || 'generic';

                console.log('üìä Equivalence parameters:', { studyType, margin, trueDifference, sd, regulatory });

                // Calculate sample size
                const alpha = studyType === 'superiority' ? 0.05 : 0.025;
                const zAlpha = studyType === 'superiority' ? 1.96 : 2.24;
                const zBeta = 0.84; // 80% power
                
                let requiredN;
                if (studyType === 'equivalence') {
                    requiredN = Math.ceil(2 * Math.pow((zAlpha + zBeta) * sd / margin, 2));
                } else if (studyType === 'non-inferiority') {
                    requiredN = Math.ceil(2 * Math.pow((zAlpha + zBeta) * sd / margin, 2) * 0.8);
                } else {
                    requiredN = Math.ceil(2 * Math.pow((1.96 + zBeta) * sd / trueDifference, 2));
                }

                // Simulate study results
                const finalN = Math.max(requiredN, 50);
                const group1Data = generateNormalData(finalN, 120, sd);
                const group2Data = generateNormalData(finalN, 120 - trueDifference, sd);
                
                const mean1 = mean(group1Data);
                const mean2 = mean(group2Data);
                const observedDiff = mean1 - mean2;
                const pooledSD = Math.sqrt((variance(group1Data) + variance(group2Data)) / 2);
                const se = pooledSD * Math.sqrt(2 / finalN);
                
                const ci90Lower = observedDiff - 1.645 * se;
                const ci90Upper = observedDiff + 1.645 * se;
                const ci95Lower = observedDiff - 1.96 * se;
                const ci95Upper = observedDiff + 1.96 * se;

                // Determine conclusion
                let conclusion, ciToUse;
                
                if (studyType === 'equivalence') {
                    ciToUse = `90% CI: [${ci90Lower.toFixed(2)}, ${ci90Upper.toFixed(2)}]`;
                    const equivalent = ci90Lower > -margin && ci90Upper < margin;
                    conclusion = equivalent ? 'Equivalence demonstrated' : 'Equivalence not demonstrated';
                } else if (studyType === 'non-inferiority') {
                    ciToUse = `95% CI: [${ci95Lower.toFixed(2)}, ${ci95Upper.toFixed(2)}]`;
                    const nonInferior = ci95Lower > -margin;
                    conclusion = nonInferior ? 'Non-inferiority demonstrated' : 'Non-inferiority not demonstrated';
                } else {
                    ciToUse = `95% CI: [${ci95Lower.toFixed(2)}, ${ci95Upper.toFixed(2)}]`;
                    const superior = ci95Lower > 0;
                    conclusion = superior ? 'Superiority demonstrated' : 'Superiority not demonstrated';
                }

                document.getElementById('equivalence-results').style.display = 'block';
                document.getElementById('equivalence-results').innerHTML = `
                    <h4>${studyType.charAt(0).toUpperCase() + studyType.slice(1)} Study Results</h4>
                    
                    <p><strong>Study Parameters:</strong></p>
                    <p>‚Ä¢ Study type: ${studyType.replace('-', ' ')}</p>
                    <p>‚Ä¢ Margin: ¬±${margin} units</p>
                    <p>‚Ä¢ True difference: ${trueDifference} units</p>
                    <p>‚Ä¢ Sample size: ${finalN} per group</p>
                    <p>‚Ä¢ Regulatory context: ${regulatory.replace('-', ' ')}</p>

                    <p><strong>Results:</strong></p>
                    <p>‚Ä¢ Observed difference: ${observedDiff.toFixed(2)} units</p>
                    <p>‚Ä¢ ${ciToUse}</p>
                    <p>‚Ä¢ <span class="highlight">Conclusion: ${conclusion}</span></p>

                    <p><strong>Regulatory Implications:</strong></p>
                    <p>‚Ä¢ Pathway: ${getRegPathway(regulatory)}</p>
                    <p>‚Ä¢ Clinical significance: ${getClinSignificance(studyType, observedDiff, margin)}</p>
                `;

                createEquivalenceVisualization(observedDiff, ci90Lower, ci90Upper, ci95Lower, ci95Upper, margin, studyType);
                
                console.log('üéâ Equivalence study completed successfully!');
                
            } catch (error) {
                console.error('‚ùå Error in designEquivalenceStudy:', error);
                showEquivalenceError(error.message);
            }
        }

        function createEquivalenceVisualization(observedDiff, ci90Lower, ci90Upper, ci95Lower, ci95Upper, margin, studyType) {
            console.log('üìä Creating equivalence visualization...');
            
            const ctx = document.getElementById('equivalence-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;
            
            if (charts.equivalence) {
                charts.equivalence.destroy();
                delete charts.equivalence;
            }

            const datasets = [{
                label: 'Observed Difference',
                data: [{x: observedDiff, y: 1}],
                backgroundColor: '#2f8b8b',
                borderColor: '#2f8b8b',
                pointRadius: 10
            }];

            if (studyType === 'equivalence') {
                datasets.push({
                    label: '90% CI',
                    data: [{x: ci90Lower, y: 1}, {x: ci90Upper, y: 1}],
                    borderColor: '#dc143c',
                    borderWidth: 4,
                    pointRadius: 8,
                    showLine: true,
                    fill: false
                });
            } else {
                datasets.push({
                    label: '95% CI',
                    data: [{x: ci95Lower, y: 1}, {x: ci95Upper, y: 1}],
                    borderColor: '#dc143c',
                    borderWidth: 4,
                    pointRadius: 8,
                    showLine: true,
                    fill: false
                });
            }

            // Margin lines
            datasets.push({
                label: 'Margin',
                data: [{x: -margin, y: 0.5}, {x: -margin, y: 1.5}],
                borderColor: '#ff6b6b',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                showLine: true,
                fill: false
            });

            if (studyType === 'equivalence') {
                datasets.push({
                    label: '',
                    data: [{x: margin, y: 0.5}, {x: margin, y: 1.5}],
                    borderColor: '#ff6b6b',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    showLine: true,
                    fill: false
                });
            }

            try {
                charts.equivalence = new Chart(chartCtx, {
                    type: 'scatter',
                    data: { datasets: datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${studyType.charAt(0).toUpperCase() + studyType.slice(1)} Analysis`,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Treatment Difference'
                                }
                            },
                            y: {
                                min: 0.3,
                                max: 1.7,
                                ticks: { display: false }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating equivalence chart:', error);
            }
        }

        // Survival Analysis Functions - IMPLEMENTED
        function simulateSurvivalStudy() {
            console.log('üöÄ Starting survival study simulation...');
            
            try {
                const design = document.getElementById('survival-design')?.value || 'treatment-comparison';
                const nPerGroup = parseInt(document.getElementById('survival-n')?.value) || 100;
                const followupTime = parseInt(document.getElementById('followup-time')?.value) || 24;
                const hazardRatio = parseFloat(document.getElementById('hazard-ratio')?.value) || 0.7;
                const censoringRate = parseFloat(document.getElementById('censoring-rate')?.value) / 100 || 0.2;
                const context = document.getElementById('survival-context')?.value || 'cancer';

                console.log('üìä Survival parameters:', { design, nPerGroup, followupTime, hazardRatio, censoringRate, context });

                // Generate survival data
                const group1Data = generateSurvivalData(nPerGroup, followupTime, 1.0, censoringRate);
                const group2Data = generateSurvivalData(nPerGroup, followupTime, hazardRatio, censoringRate);
                
                // Calculate Kaplan-Meier estimates
                const km1 = calculateKaplanMeier(group1Data);
                const km2 = calculateKaplanMeier(group2Data);
                
                // Log-rank test
                const logRankTest = performLogRankTest(group1Data, group2Data);
                
                // Summary statistics
                const median1 = calculateMedianSurvival(km1);
                const median2 = calculateMedianSurvival(km2);
                const survival1At12 = getSurvivalAtTime(km1, 12);
                const survival2At12 = getSurvivalAtTime(km2, 12);
                
                // Event counts
                const events1 = group1Data.filter(p => p.event === 1).length;
                const events2 = group2Data.filter(p => p.event === 1).length;

                const contextInfo = getSurvivalContext(context);

                document.getElementById('survival-results').style.display = 'block';
                document.getElementById('survival-results').innerHTML = `
                    <h4>Survival Analysis: ${contextInfo.title}</h4>
                    
                    <p><strong>Study Summary:</strong></p>
                    <p>‚Ä¢ Context: ${contextInfo.description}</p>
                    <p>‚Ä¢ Sample size per group: ${nPerGroup}</p>
                    <p>‚Ä¢ Follow-up: ${followupTime} months</p>
                    <p>‚Ä¢ Hazard ratio: ${hazardRatio}</p>

                    <p><strong>Event Summary:</strong></p>
                    <table>
                        <tr><th>Group</th><th>Events</th><th>Event Rate</th></tr>
                        <tr><td>${contextInfo.group1}</td><td>${events1}</td><td>${(events1/nPerGroup*100).toFixed(1)}%</td></tr>
                        <tr><td>${contextInfo.group2}</td><td>${events2}</td><td>${(events2/nPerGroup*100).toFixed(1)}%</td></tr>
                    </table>

                    <p><strong>Survival Estimates:</strong></p>
                    <p>‚Ä¢ Median survival: ${median1 ? median1.toFixed(1) : 'Not reached'} vs ${median2 ? median2.toFixed(1) : 'Not reached'} months</p>
                    <p>‚Ä¢ 12-month survival: ${(survival1At12 * 100).toFixed(1)}% vs ${(survival2At12 * 100).toFixed(1)}%</p>

                    <p><strong>Log-rank Test:</strong></p>
                    <p>‚Ä¢ Chi-square: ${logRankTest.chiSquare.toFixed(3)}</p>
                    <p>‚Ä¢ <span class="highlight">p-value: ${logRankTest.pValue.toFixed(4)}</span></p>
                    <p>‚Ä¢ Observed HR: ${logRankTest.observedHR.toFixed(2)}</p>
                    <p>‚Ä¢ Conclusion: ${logRankTest.pValue < 0.05 ? 'Significant survival difference' : 'No significant difference'}</p>

                    <p><strong>Clinical Impact:</strong></p>
                    <p>‚Ä¢ HR interpretation: ${interpretHR(logRankTest.observedHR)}</p>
                    <p>‚Ä¢ Clinical significance: ${interpretSurvivalClinical(contextInfo, logRankTest.observedHR, logRankTest.pValue)}</p>
                `;

                createSurvivalVisualization(km1, km2, contextInfo);
                
                console.log('üéâ Survival study completed successfully!');
                
            } catch (error) {
                console.error('‚ùå Error in simulateSurvivalStudy:', error);
                showSurvivalError(error.message);
            }
        }

        function generateSurvivalData(n, maxTime, hazardRatio, censorRate) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const baseHazard = 0.02;
                const hazard = baseHazard * hazardRatio;
                const timeToEvent = -Math.log(Math.random()) / hazard;
                const censorTime = Math.random() < censorRate ? Math.random() * maxTime : maxTime;
                const observedTime = Math.min(timeToEvent, censorTime);
                const event = timeToEvent <= censorTime ? 1 : 0;
                
                data.push({
                    id: i + 1,
                    time: observedTime,
                    event: event
                });
            }
            return data.sort((a, b) => a.time - b.time);
        }

        function calculateKaplanMeier(data) {
            const times = [...new Set(data.filter(d => d.event === 1).map(d => d.time))].sort((a, b) => a - b);
            const kmEstimates = [];
            let survival = 1.0;
            
            for (const time of times) {
                const atRisk = data.filter(d => d.time >= time).length;
                const events = data.filter(d => d.time === time && d.event === 1).length;
                
                if (atRisk > 0) {
                    survival *= (1 - events / atRisk);
                }
                
                kmEstimates.push({
                    time: time,
                    survival: survival,
                    atRisk: atRisk,
                    events: events
                });
            }
            return kmEstimates;
        }

        function performLogRankTest(group1, group2) {
            const combinedData = [
                ...group1.map(d => ({...d, group: 1})),
                ...group2.map(d => ({...d, group: 2}))
            ].sort((a, b) => a.time - b.time);

            const uniqueTimes = [...new Set(combinedData.filter(d => d.event === 1).map(d => d.time))];
            
            let observedMinusExpected = 0;
            let variance = 0;
            
            for (const time of uniqueTimes) {
                const atRisk1 = combinedData.filter(d => d.time >= time && d.group === 1).length;
                const atRisk2 = combinedData.filter(d => d.time >= time && d.group === 2).length;
                const totalAtRisk = atRisk1 + atRisk2;
                
                const events1 = combinedData.filter(d => d.time === time && d.event === 1 && d.group === 1).length;
                const events2 = combinedData.filter(d => d.time === time && d.event === 1 && d.group === 2).length;
                const totalEvents = events1 + events2;
                
                if (totalAtRisk > 0 && totalEvents > 0) {
                    const expected1 = atRisk1 * totalEvents / totalAtRisk;
                    const varComponent = atRisk1 * atRisk2 * totalEvents * (totalAtRisk - totalEvents) / 
                                       (Math.pow(totalAtRisk, 2) * Math.max(1, totalAtRisk - 1));
                    
                    observedMinusExpected += events1 - expected1;
                    variance += varComponent;
                }
            }
            
            const chiSquare = variance > 0 ? Math.pow(observedMinusExpected, 2) / variance : 0;
            const pValue = variance > 0 ? 1 - chiSquareCDF(chiSquare, 1) : 1;
            
            // Estimate hazard ratio
            const events1 = group1.filter(d => d.event === 1).length;
            const events2 = group2.filter(d => d.event === 1).length;
            const totalTime1 = group1.reduce((sum, d) => sum + d.time, 0);
            const totalTime2 = group2.reduce((sum, d) => sum + d.time, 0);
            
            const hazardRate1 = Math.max(0.001, events1 / Math.max(1, totalTime1));
            const hazardRate2 = Math.max(0.001, events2 / Math.max(1, totalTime2));
            const observedHR = hazardRate2 / hazardRate1;
            
            return { chiSquare, pValue, observedHR };
        }

        function createSurvivalVisualization(km1, km2, contextInfo) {
            const ctx = document.getElementById('survival-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.survival) {
                charts.survival.destroy();
                delete charts.survival;
            }

            // Convert KM data to chart format
            const km1Data = [{x: 0, y: 1}].concat(km1.map(point => ({x: point.time, y: point.survival})));
            const km2Data = [{x: 0, y: 1}].concat(km2.map(point => ({x: point.time, y: point.survival})));

            try {
                charts.survival = new Chart(chartCtx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: contextInfo.group1,
                            data: km1Data,
                            borderColor: '#ff6b6b',
                            borderWidth: 3,
                            stepped: true,
                            pointRadius: 0,
                            fill: false
                        }, {
                            label: contextInfo.group2,
                            data: km2Data,
                            borderColor: '#2f8b8b',
                            borderWidth: 3,
                            stepped: true,
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `Kaplan-Meier Survival Curves: ${contextInfo.title}`,
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time (months)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Survival Probability'
                                },
                                min: 0,
                                max: 1
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating survival chart:', error);
            }
        }

        // Assessment Functions - IMPLEMENTED AND FIXED
        const hypothesisQuestionPools = {
            framework: [
                {
                    question: "A clinical trial tests whether a new diabetes drug reduces HbA1c more than placebo. What is the appropriate null hypothesis?",
                    options: [
                        "H‚ÇÄ: New drug reduces HbA1c by at least 0.5%",
                        "H‚ÇÄ: There is no difference in HbA1c reduction between new drug and placebo",
                        "H‚ÇÄ: New drug is superior to placebo",
                        "H‚ÇÄ: Patients prefer the new drug over placebo"
                    ],
                    correct: 1,
                    explanation: "The null hypothesis always states 'no effect' or 'no difference.' We assume no difference until evidence proves otherwise."
                },
                {
                    question: "In a non-inferiority trial, what does the alternative hypothesis state?",
                    options: [
                        "The new treatment is better than standard care",
                        "The new treatment is not worse than standard care by more than a specified margin",
                        "The new treatment is equivalent to standard care",
                        "The new treatment is different from standard care"
                    ],
                    correct: 1,
                    explanation: "Non-inferiority trials test whether a new treatment is not unacceptably worse than standard care within a pre-specified margin."
                }
            ],
            power: [
                {
                    question: "A study has 60% power to detect a clinically important difference. What does this mean?",
                    options: [
                        "There's a 60% chance the null hypothesis is true",
                        "There's a 40% chance of making a Type I error",
                        "If a true effect exists, there's a 60% chance of detecting it",
                        "60% of similar studies would show statistical significance"
                    ],
                    correct: 2,
                    explanation: "Power is the probability of correctly rejecting a false null hypothesis - i.e., detecting a true effect when it exists."
                },
                {
                    question: "What happens to statistical power when sample size increases?",
                    options: [
                        "Power decreases because variance increases",
                        "Power increases because variance decreases",
                        "Power remains constant regardless of sample size",
                        "Power only increases if the effect size is large"
                    ],
                    correct: 1,
                    explanation: "Larger sample sizes reduce sampling variability, making it easier to detect true effects, thus increasing statistical power."
                }
            ],
            pvalues: [
                {
                    question: "A study reports p=0.03. This means:",
                    options: [
                        "There's a 3% chance the null hypothesis is true",
                        "There's a 97% chance the treatment works",
                        "If null hypothesis were true, we'd see data this extreme 3% of the time",
                        "The treatment effect is clinically significant"
                    ],
                    correct: 2,
                    explanation: "P-value is the probability of observing data as extreme or more extreme than observed, assuming the null hypothesis is true."
                },
                {
                    question: "What is the main problem with multiple testing without correction?",
                    options: [
                        "It reduces statistical power",
                        "It increases the chance of Type I errors (false positives)",
                        "It makes p-values harder to calculate",
                        "It requires larger sample sizes"
                    ],
                    correct: 1,
                    explanation: "Testing multiple hypotheses increases the probability of finding at least one false positive result by chance alone."
                }
            ],
            tests: [
                {
                    question: "You want to compare pain scores (0-10 scale) before and after treatment in the same 30 patients. Data are skewed. Which test is most appropriate?",
                    options: [
                        "Paired t-test",
                        "Two-sample t-test", 
                        "Wilcoxon signed-rank test",
                        "Mann-Whitney U test"
                    ],
                    correct: 2,
                    explanation: "Wilcoxon signed-rank test is the non-parametric equivalent of paired t-test, appropriate for skewed paired data."
                },
                {
                    question: "When comparing survival times between two treatment groups with censored data, which test is most appropriate?",
                    options: [
                        "Two-sample t-test",
                        "Chi-square test",
                        "Log-rank test",
                        "ANOVA"
                    ],
                    correct: 2,
                    explanation: "The log-rank test is specifically designed for comparing survival distributions when censoring is present."
                }
            ]
        };

        function generateHypothesisQuestions() {
            console.log('üß† Generating hypothesis testing questions...');
            
            try {
                currentHypothesisQuestions = [];
                const pools = Object.keys(hypothesisQuestionPools);
                
                pools.forEach(pool => {
                    const questions = hypothesisQuestionPools[pool];
                    const randomQ = questions[Math.floor(Math.random() * questions.length)];
                    currentHypothesisQuestions.push(randomQ);
                });

                displayHypothesisQuestions();
                console.log('‚úÖ Generated hypothesis testing questions successfully');
                
            } catch (error) {
                console.error('‚ùå Error generating hypothesis questions:', error);
                showAssessmentError(error.message);
            }
        }

        function displayHypothesisQuestions() {
            const container = document.getElementById('hypothesis-questions-container');
            let html = '';
            
            if (currentHypothesisQuestions.length === 0) {
                html = '<p>No questions available. Click "Generate New Questions" to create assessment.</p>';
            } else {
                currentHypothesisQuestions.forEach((q, index) => {
                    const shuffledOptions = [...q.options];
                    const correctAnswer = shuffledOptions[q.correct];
                    
                    // Shuffle options
                    for (let i = shuffledOptions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                    }
                    
                    const newCorrectIndex = shuffledOptions.indexOf(correctAnswer);
                    
                    html += `
                        <div class="question">
                            <h4>Question ${index + 1}</h4>
                            <p><strong>${q.question}</strong></p>
                            ${shuffledOptions.map((option, i) => `
                                <label style="display: block; margin: 5px 0;">
                                    <input type="radio" name="hq${index}" value="${i}" data-correct="${i === newCorrectIndex}">
                                    ${String.fromCharCode(65 + i)}. ${option}
                                </label>
                            `).join('')}
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
            
            const checkBtn = document.getElementById('hypothesis-check-btn');
            if (checkBtn) {
                checkBtn.style.display = currentHypothesisQuestions.length > 0 ? 'block' : 'none';
            }
        }

        function checkHypothesisAnswers() {
            console.log('üìù Checking hypothesis testing answers...');
            
            try {
                let correct = 0;
                let total = currentHypothesisQuestions.length;
                let results = '<h4>Hypothesis Testing Assessment Results</h4>';
                
                currentHypothesisQuestions.forEach((q, index) => {
                    const selected = document.querySelector(`input[name="hq${index}"]:checked`);
                    const isCorrect = selected && selected.dataset.correct === 'true';
                    
                    if (isCorrect) correct++;
                    
                    results += `
                        <p><strong>Question ${index + 1}:</strong> ${isCorrect ? '‚úì Correct' : '‚úó Incorrect'}</p>
                        <p><em>Explanation:</em> ${q.explanation}</p>
                    `;
                });
                
                const percentage = (correct / total * 100).toFixed(1);
                results = `<p><strong>Score: ${correct}/${total} (${percentage}%)</strong></p>` + results;
                
                if (correct === total) {
                    results += '<p><span style="color: #2f8b8b; font-weight: bold;">üéì Excellent! You have mastered hypothesis testing fundamentals!</span></p>';
                } else if (percentage >= 70) {
                    results += '<p><span style="color: #ff9800; font-weight: bold;">üìö Good work! Review the explanations for missed questions.</span></p>';
                } else {
                    results += '<p><span style="color: #dc143c; font-weight: bold;">üìñ Keep studying! Focus on the fundamental concepts.</span></p>';
                }
                
                document.getElementById('hypothesis-assessment-results').innerHTML = results;
                
                console.log('‚úÖ Assessment checked successfully:', { correct, total, percentage });
                
            } catch (error) {
                console.error('‚ùå Error checking answers:', error);
                showAssessmentError('Error checking answers: ' + error.message);
            }
        }

        // Section 2: Power Analysis - IMPLEMENTED
        function calculatePower() {
            console.log('‚ö° Calculating power analysis...');
            
            try {
                const effectSize = parseFloat(document.getElementById('effect-size')?.value) || 0.5;
                const sampleSize = parseInt(document.getElementById('sample-size')?.value) || 50;
                const alpha = parseFloat(document.getElementById('alpha-level')?.value) || 0.05;
                const context = document.getElementById('clinical-context')?.value || 'efficacy';

                // Calculate power (simplified Cohen's approach)
                const delta = effectSize * Math.sqrt(sampleSize / 2);
                const criticalValue = getZCritical(alpha);
                const power = 1 - normalCDF(criticalValue - delta) + normalCDF(-criticalValue - delta);

                // Calculate required sample size for 80% power
                const powerTarget = 0.80;
                const zBeta = getZCritical(1 - powerTarget);
                const requiredN = Math.ceil(2 * Math.pow((criticalValue + zBeta) / effectSize, 2));

                // Clinical consequences
                const consequences = getClinicalConsequences(context, alpha, 1 - power);

                document.getElementById('errors-results').style.display = 'block';
                document.getElementById('errors-results').innerHTML = `
                    <h4>Power Analysis Results</h4>
                    
                    <p><strong>Study Parameters:</strong></p>
                    <p>‚Ä¢ Effect size (Cohen's d): ${effectSize}</p>
                    <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                    <p>‚Ä¢ Significance level (Œ±): ${alpha}</p>
                    <p>‚Ä¢ Clinical context: ${context.replace('-', ' ')}</p>
                    
                    <p><strong>Statistical Power Analysis:</strong></p>
                    <p>‚Ä¢ <span class="highlight">Current power: ${(power * 100).toFixed(1)}%</span></p>
                    <p>‚Ä¢ Type II error rate (Œ≤): ${((1 - power) * 100).toFixed(1)}%</p>
                    <p>‚Ä¢ Required sample size for 80% power: ${requiredN} per group</p>
                    
                    <p><strong>Clinical Interpretation:</strong></p>
                    <p>‚Ä¢ Probability of detecting true effect: ${(power * 100).toFixed(1)}%</p>
                    <p>‚Ä¢ Risk of missing true effect: ${((1 - power) * 100).toFixed(1)}%</p>
                    <p>‚Ä¢ Power adequacy: ${power >= 0.8 ? 'Adequate' : 'Inadequate - increase sample size'}</p>
                    
                    <p><strong>Clinical Consequences:</strong></p>
                    <p>‚Ä¢ Type I error impact: ${consequences.typeI}</p>
                    <p>‚Ä¢ Type II error impact: ${consequences.typeII}</p>
                    <p>‚Ä¢ Cost per additional patient: ${consequences.cost}</p>
                `;

                createPowerCurve(effectSize, alpha, sampleSize, power);
                console.log('‚úÖ Power analysis completed successfully');

            } catch (error) {
                console.error('‚ùå Error in calculatePower:', error);
                showErrorMessage('errors-results', 'Power calculation error: ' + error.message);
            }
        }

        function getClinicalConsequences(context, alpha, beta) {
            const consequences = {
                efficacy: {
                    typeI: 'Approving ineffective treatment - patients receive no benefit, healthcare costs increase',
                    typeII: 'Missing effective treatment - patients continue to suffer from untreated condition',
                    cost: 'CAD $15,000-25,000 per patient'
                },
                safety: {
                    typeI: 'False safety signal - unnecessary treatment restrictions, patient access reduced',
                    typeII: 'Missing real safety issue - patients exposed to preventable harm',
                    cost: 'CAD $8,000-15,000 per patient'
                },
                bioequivalence: {
                    typeI: 'Concluding non-equivalence when equivalent - generic drug unnecessarily rejected',
                    typeII: 'Missing non-equivalence - potentially inferior generic approved',
                    cost: 'CAD $5,000-10,000 per patient'
                },
                screening: {
                    typeI: 'False positive screening - unnecessary anxiety and procedures',
                    typeII: 'Missing disease cases - delayed treatment and worse outcomes',
                    cost: 'CAD $3,000-8,000 per patient'
                }
            };
            return consequences[context] || consequences.efficacy;
        }

        function createPowerCurve(baseEffect, alpha, currentN, currentPower) {
            const ctx = document.getElementById('power-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.power) {
                charts.power.destroy();
                delete charts.power;
            }

            // Generate power curve across effect sizes
            const effectSizes = [];
            const powers = [];
            
            for (let d = 0; d <= 1.5; d += 0.05) {
                const delta = d * Math.sqrt(currentN / 2);
                const criticalValue = getZCritical(alpha);
                const power = 1 - normalCDF(criticalValue - delta) + normalCDF(-criticalValue - delta);
                effectSizes.push(d);
                powers.push(power * 100);
            }

            try {
                charts.power = new Chart(chartCtx, {
                    type: 'line',
                    data: {
                        labels: effectSizes.map(d => d.toFixed(2)),
                        datasets: [{
                            label: 'Statistical Power (%)',
                            data: powers,
                            borderColor: '#2f8b8b',
                            backgroundColor: 'rgba(47, 139, 139, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4
                        }, {
                            label: 'Minimum Power (80%)',
                            data: Array(effectSizes.length).fill(80),
                            borderColor: '#dc143c',
                            borderDash: [10, 5],
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        }, {
                            label: `Current Study (d=${baseEffect})`,
                            data: [{x: baseEffect.toFixed(2), y: currentPower * 100}],
                            type: 'scatter',
                            backgroundColor: '#ff6b6b',
                            borderColor: '#ff6b6b',
                            pointRadius: 8,
                            showLine: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Power Curve: Power vs Effect Size'
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Effect Size (Cohen\'s d)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Statistical Power (%)'
                                },
                                min: 0,
                                max: 100
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating power chart:', error);
            }
        }

        function getZCritical(alpha) {
            // Approximate critical values
            if (alpha <= 0.01) return 2.58;
            if (alpha <= 0.05) return 1.96;
            return 1.645;
        }

        // Section 3: Multiple Testing - IMPLEMENTED
        function simulateMultipleTesting() {
            console.log('üßÆ Simulating multiple testing...');
            
            try {
                const numTests = parseInt(document.getElementById('num-comparisons')?.value) || 10;
                const trueEffect = document.getElementById('true-effect')?.value || 'none';
                const sampleSize = parseInt(document.getElementById('pvalue-sample')?.value) || 100;
                const correction = document.getElementById('correction-method')?.value || 'none';

                // Simulate p-values
                const results = [];
                const rawPValues = [];

                for (let i = 0; i < numTests; i++) {
                    let pValue;
                    if (trueEffect === 'none') {
                        // All null hypotheses true - p-values uniform [0,1]
                        pValue = Math.random();
                    } else if (trueEffect === 'some') {
                        // Half have true effects
                        if (i < numTests / 2) {
                            // True effect present - lower p-values
                            pValue = Math.random() * 0.3;
                        } else {
                            // No effect - uniform p-values
                            pValue = Math.random();
                        }
                    } else {
                        // All have true effects
                        pValue = Math.random() * 0.2;
                    }
                    
                    rawPValues.push(pValue);
                    
                    results.push({
                        test: i + 1,
                        rawP: pValue,
                        significant: pValue < 0.05,
                        truePositive: (trueEffect === 'all') || (trueEffect === 'some' && i < numTests / 2)
                    });
                }

                // Apply correction
                const adjustedPValues = applyCorrection(rawPValues, correction);
                
                // Update results with adjusted p-values
                results.forEach((result, i) => {
                    result.adjustedP = adjustedPValues[i];
                    result.sigAfterCorrection = adjustedPValues[i] < 0.05;
                });

                // Calculate error rates
                const sigBefore = results.filter(r => r.significant).length;
                const sigAfter = results.filter(r => r.sigAfterCorrection).length;
                const falsePositives = results.filter(r => r.sigAfterCorrection && !r.truePositive).length;
                const truePositives = results.filter(r => r.sigAfterCorrection && r.truePositive).length;

                document.getElementById('pvalues-results').style.display = 'block';
                document.getElementById('pvalues-results').innerHTML = `
                    <h4>Multiple Testing Simulation Results</h4>
                    
                    <p><strong>Study Setup:</strong></p>
                    <p>‚Ä¢ Number of tests: ${numTests}</p>
                    <p>‚Ä¢ True effects: ${trueEffect === 'none' ? 'None (all null true)' : trueEffect === 'some' ? 'Some (mixed)' : 'All tests have true effects'}</p>
                    <p>‚Ä¢ Correction method: ${correction === 'none' ? 'No correction' : correction.toUpperCase()}</p>
                    
                    <p><strong>Results Summary:</strong></p>
                    <table>
                        <tr><th>Measure</th><th>Before Correction</th><th>After Correction</th></tr>
                        <tr><td>Significant tests</td><td>${sigBefore}</td><td>${sigAfter}</td></tr>
                        <tr><td>False positives</td><td>${results.filter(r => r.significant && !r.truePositive).length}</td><td>${falsePositives}</td></tr>
                        <tr><td>True positives</td><td>${results.filter(r => r.significant && r.truePositive).length}</td><td>${truePositives}</td></tr>
                        <tr><td>Family-wise error rate</td><td>${results.filter(r => r.significant && !r.truePositive).length > 0 ? 'Yes' : 'No'}</td><td>${falsePositives > 0 ? 'Yes' : 'No'}</td></tr>
                    </table>
                    
                    <p><strong>Clinical Interpretation:</strong></p>
                    <p>‚Ä¢ <span class="highlight">Correction effectiveness: ${(((sigBefore - sigAfter) / Math.max(1, sigBefore)) * 100).toFixed(0)}% reduction in significant findings</span></p>
                    <p>‚Ä¢ Type I error control: ${falsePositives === 0 ? 'Excellent' : falsePositives <= 1 ? 'Good' : 'Inadequate'}</p>
                    <p>‚Ä¢ Power preservation: ${truePositives}/${results.filter(r => r.truePositive).length} true effects detected</p>
                    
                    <div style="max-height: 200px; overflow-y: auto;">
                        <table style="font-size: 0.9em;">
                            <tr><th>Test</th><th>Raw p</th><th>Adjusted p</th><th>Significant</th></tr>
                            ${results.slice(0, 10).map(r => `
                                <tr style="background-color: ${r.sigAfterCorrection ? '#e8ffe8' : '#f8f8f8'}">
                                    <td>${r.test}</td>
                                    <td>${r.rawP.toFixed(4)}</td>
                                    <td>${r.adjustedP.toFixed(4)}</td>
                                    <td>${r.sigAfterCorrection ? '‚úì' : '‚úó'}</td>
                                </tr>
                            `).join('')}
                            ${results.length > 10 ? '<tr><td colspan="4">... (showing first 10 tests)</td></tr>' : ''}
                        </table>
                    </div>
                `;

                createPValueHistogram(rawPValues, adjustedPValues, correction);
                console.log('‚úÖ Multiple testing simulation completed');

            } catch (error) {
                console.error('‚ùå Error in simulateMultipleTesting:', error);
                showErrorMessage('pvalues-results', 'Multiple testing error: ' + error.message);
            }
        }

        function applyCorrection(rawPValues, correction) {
            const numTests = rawPValues.length;
            let adjustedPValues = new Array(numTests);

            if (correction === 'bonferroni') {
                for (let i = 0; i < numTests; i++) {
                    adjustedPValues[i] = Math.min(1, rawPValues[i] * numTests);
                }
            } else if (correction === 'holm') {
                // Holm-Bonferroni step-down
                const sorted = rawPValues.map((p, i) => ({p, index: i}))
                                        .sort((a, b) => a.p - b.p);
                
                for (let i = 0; i < numTests; i++) {
                    const adjustedP = Math.min(1, sorted[i].p * (numTests - i));
                    adjustedPValues[sorted[i].index] = adjustedP;
                }
            } else if (correction === 'fdr') {
                // Benjamini-Hochberg FDR
                const sorted = rawPValues.map((p, i) => ({p, index: i}))
                                        .sort((a, b) => a.p - b.p);
                
                for (let i = 0; i < numTests; i++) {
                    const adjustedP = Math.min(1, sorted[i].p * numTests / (i + 1));
                    adjustedPValues[sorted[i].index] = adjustedP;
                }
            } else {
                // No correction
                adjustedPValues = [...rawPValues];
            }

            return adjustedPValues;
        }

        function createPValueHistogram(rawPValues, adjustedPValues, correction) {
            const ctx = document.getElementById('pvalue-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.pvalue) {
                charts.pvalue.destroy();
                delete charts.pvalue;
            }

            // Create histograms
            const bins = [0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.1, 0.2, 0.5, 1.0];
            const rawCounts = new Array(bins.length - 1).fill(0);
            const adjCounts = new Array(bins.length - 1).fill(0);

            rawPValues.forEach(p => {
                for (let i = 0; i < bins.length - 1; i++) {
                    if (p >= bins[i] && p < bins[i + 1]) {
                        rawCounts[i]++;
                        break;
                    }
                }
            });

            adjustedPValues.forEach(p => {
                for (let i = 0; i < bins.length - 1; i++) {
                    if (p >= bins[i] && p < bins[i + 1]) {
                        adjCounts[i]++;
                        break;
                    }
                }
            });

            try {
                charts.pvalue = new Chart(chartCtx, {
                    type: 'bar',
                    data: {
                        labels: bins.slice(0, -1).map((b, i) => `${b}-${bins[i + 1]}`),
                        datasets: [{
                            label: 'Raw P-values',
                            data: rawCounts,
                            backgroundColor: 'rgba(47, 139, 139, 0.7)',
                            borderColor: '#2f8b8b',
                            borderWidth: 2
                        }, {
                            label: 'Adjusted P-values',
                            data: adjCounts,
                            backgroundColor: 'rgba(220, 20, 60, 0.7)',
                            borderColor: '#dc143c',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `P-value Distribution: ${correction === 'none' ? 'No Correction' : correction.toUpperCase()}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'P-value Range'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Number of Tests'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating p-value chart:', error);
            }
        }

        // Section 4: Means Testing - IMPLEMENTED
        function simulateMeansTest() {
            console.log('üìä Simulating means test...');
            
            try {
                const studyType = document.getElementById('study-type')?.value || 'independent';
                const sampleSize = parseInt(document.getElementById('means-sample-size')?.value) || 80;
                const effectSize = parseFloat(document.getElementById('means-effect')?.value) || 0.5;
                const outcome = document.getElementById('clinical-outcome')?.value || 'hba1c';

                const outcomeParams = {
                    'hba1c': { name: 'HbA1c Change', unit: '%', baseline: 8.5, sd: 1.2, clinicalThreshold: 0.5 },
                    'bp': { name: 'Systolic BP', unit: 'mmHg', baseline: 145, sd: 15, clinicalThreshold: 5 },
                    'cholesterol': { name: 'LDL Cholesterol', unit: 'mg/dL', baseline: 150, sd: 30, clinicalThreshold: 10 },
                    'pain': { name: 'Pain Score', unit: '(0-10)', baseline: 6.5, sd: 2.0, clinicalThreshold: 1.0 }
                };

                const params = outcomeParams[outcome];
                let results = {};

                if (studyType === 'independent') {
                    // Two independent groups
                    const controlGroup = generateNormalData(sampleSize, params.baseline, params.sd);
                    const treatmentGroup = generateNormalData(sampleSize, params.baseline - effectSize * params.sd, params.sd);
                    
                    const controlMean = mean(controlGroup);
                    const treatmentMean = mean(treatmentGroup);
                    const pooledSD = Math.sqrt((variance(controlGroup) + variance(treatmentGroup)) / 2);
                    const se = pooledSD * Math.sqrt(2 / sampleSize);
                    const tStat = (controlMean - treatmentMean) / se;
                    const df = 2 * sampleSize - 2;
                    const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
                    
                    results = {
                        type: 'Two-sample t-test',
                        controlMean: controlMean,
                        treatmentMean: treatmentMean,
                        difference: controlMean - treatmentMean,
                        se: se,
                        tStat: tStat,
                        df: df,
                        pValue: pValue,
                        clinicallySig: Math.abs(controlMean - treatmentMean) >= params.clinicalThreshold
                    };
                    
                } else if (studyType === 'paired') {
                    // Paired data (before/after)
                    const beforeData = generateNormalData(sampleSize, params.baseline, params.sd);
                    const afterData = beforeData.map(x => x - effectSize * params.sd + (Math.random() - 0.5) * params.sd * 0.5);
                    const differences = beforeData.map((x, i) => x - afterData[i]);
                    
                    const meanDiff = mean(differences);
                    const sdDiff = Math.sqrt(variance(differences));
                    const se = sdDiff / Math.sqrt(sampleSize);
                    const tStat = meanDiff / se;
                    const df = sampleSize - 1;
                    const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
                    
                    results = {
                        type: 'Paired t-test',
                        beforeMean: mean(beforeData),
                        afterMean: mean(afterData),
                        difference: meanDiff,
                        se: se,
                        tStat: tStat,
                        df: df,
                        pValue: pValue,
                        clinicallySig: Math.abs(meanDiff) >= params.clinicalThreshold
                    };
                } else {
                    // ANOVA (3 groups)
                    const group1 = generateNormalData(sampleSize, params.baseline, params.sd);
                    const group2 = generateNormalData(sampleSize, params.baseline - effectSize * params.sd * 0.5, params.sd);
                    const group3 = generateNormalData(sampleSize, params.baseline - effectSize * params.sd, params.sd);
                    
                    const allData = [...group1, ...group2, ...group3];
                    const grandMean = mean(allData);
                    const groupMeans = [mean(group1), mean(group2), mean(group3)];
                    
                    // Calculate F-statistic
                    const msb = sampleSize * groupMeans.reduce((sum, gm) => sum + Math.pow(gm - grandMean, 2), 0) / 2;
                    const msw = (variance(group1) + variance(group2) + variance(group3)) / 3;
                    const fStat = msb / msw;
                    const pValue = 1 - fCDF(fStat, 2, 3 * sampleSize - 3);
                    
                    results = {
                        type: 'One-way ANOVA',
                        groupMeans: groupMeans,
                        fStat: fStat,
                        pValue: pValue,
                        grandMean: grandMean,
                        clinicallySig: Math.max(...groupMeans) - Math.min(...groupMeans) >= params.clinicalThreshold
                    };
                }

                displayMeansResults(results, params, sampleSize, effectSize);
                createMeansVisualization(results, studyType, params);
                
                console.log('‚úÖ Means test simulation completed');

            } catch (error) {
                console.error('‚ùå Error in simulateMeansTest:', error);
                showErrorMessage('means-results', 'Means test error: ' + error.message);
            }
        }

        function displayMeansResults(results, params, sampleSize, effectSize) {
            document.getElementById('means-results').style.display = 'block';
            document.getElementById('means-results').innerHTML = `
                <h4>${results.type}: ${params.name} Analysis</h4>
                
                <p><strong>Study Design:</strong></p>
                <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                <p>‚Ä¢ Expected effect size: ${effectSize} (Cohen's d)</p>
                <p>‚Ä¢ Primary outcome: ${params.name} (${params.unit})</p>
                <p>‚Ä¢ Clinical threshold: ${params.clinicalThreshold} ${params.unit}</p>
                
                <p><strong>Results:</strong></p>
                ${getResultsDisplay(results, params)}
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Statistical significance: ${results.pValue < 0.05 ? 'Yes' : 'No'} (p = ${results.pValue.toFixed(4)})</span></p>
                <p>‚Ä¢ Clinical significance: ${results.clinicallySig ? 'Yes' : 'No'} (‚â•${params.clinicalThreshold} ${params.unit})</p>
                <p>‚Ä¢ Effect size interpretation: ${interpretEffectSize(effectSize)}</p>
                <p>‚Ä¢ Regulatory implication: ${getRegImplication(results.pValue < 0.05, results.clinicallySig)}</p>
            `;
        }

        function getResultsDisplay(results, params) {
            if (results.type.includes('ANOVA')) {
                return `
                    <table>
                        <tr><th>Group</th><th>Mean (${params.unit})</th></tr>
                        <tr><td>Group 1 (Control)</td><td>${results.groupMeans[0].toFixed(2)}</td></tr>
                        <tr><td>Group 2 (Low Dose)</td><td>${results.groupMeans[1].toFixed(2)}</td></tr>
                        <tr><td>Group 3 (High Dose)</td><td>${results.groupMeans[2].toFixed(2)}</td></tr>
                    </table>
                    <p>‚Ä¢ F-statistic: ${results.fStat.toFixed(2)}</p>
                    <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                `;
            } else {
                return `
                    <table>
                        <tr><th>Group</th><th>Mean (${params.unit})</th></tr>
                        ${results.controlMean ? `<tr><td>Control</td><td>${results.controlMean.toFixed(2)}</td></tr>` : ''}
                        ${results.treatmentMean ? `<tr><td>Treatment</td><td>${results.treatmentMean.toFixed(2)}</td></tr>` : ''}
                        ${results.beforeMean ? `<tr><td>Before</td><td>${results.beforeMean.toFixed(2)}</td></tr>` : ''}
                        ${results.afterMean ? `<tr><td>After</td><td>${results.afterMean.toFixed(2)}</td></tr>` : ''}
                    </table>
                    <p>‚Ä¢ Mean difference: ${results.difference.toFixed(2)} ${params.unit}</p>
                    <p>‚Ä¢ Standard error: ${results.se.toFixed(3)}</p>
                    <p>‚Ä¢ t-statistic: ${results.tStat.toFixed(2)} (df = ${results.df})</p>
                    <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                `;
            }
        }

        function interpretEffectSize(d) {
            const abs_d = Math.abs(d);
            if (abs_d < 0.2) return 'Small effect';
            if (abs_d < 0.5) return 'Small to medium effect';
            if (abs_d < 0.8) return 'Medium effect';
            return 'Large effect';
        }

        function getRegImplication(statSig, clinSig) {
            if (statSig && clinSig) return 'Strong evidence for regulatory approval';
            if (statSig && !clinSig) return 'Statistically significant but questionable clinical benefit';
            if (!statSig && clinSig) return 'Clinically relevant but insufficient statistical evidence';
            return 'Insufficient evidence for regulatory approval';
        }

        function tCDF(t, df) {
            // Approximate t-distribution CDF
            if (df >= 30) return normalCDF(t);
            return 0.5 + 0.5 * Math.sign(t) * Math.pow(1 - 1 / (1 + t * t / df), df / 2);
        }

        function fCDF(f, df1, df2) {
            // Very rough F-distribution approximation
            if (f < 0) return 0;
            if (f > 10) return 1;
            return 1 - Math.exp(-f / 2);
        }

        function createMeansVisualization(results, studyType, params) {
            const ctx = document.getElementById('means-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.means) {
                charts.means.destroy();
                delete charts.means;
            }

            if (studyType === 'anova') {
                try {
                    charts.means = new Chart(chartCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Control', 'Low Dose', 'High Dose'],
                            datasets: [{
                                label: `${params.name} (${params.unit})`,
                                data: results.groupMeans,
                                backgroundColor: ['rgba(255, 107, 107, 0.8)', 'rgba(255, 193, 7, 0.8)', 'rgba(47, 139, 139, 0.8)'],
                                borderColor: ['#ff6b6b', '#ffc107', '#2f8b8b'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'ANOVA: Group Means Comparison'
                                }
                            },
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `${params.name} (${params.unit})`
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('‚ùå Error creating ANOVA chart:', error);
                }
            } else {
                const labels = studyType === 'paired' ? ['Before', 'After'] : ['Control', 'Treatment'];
                const data = studyType === 'paired' ? 
                    [results.beforeMean, results.afterMean] :
                    [results.controlMean, results.treatmentMean];

                try {
                    charts.means = new Chart(chartCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: `${params.name} (${params.unit})`,
                                data: data,
                                backgroundColor: ['rgba(255, 107, 107, 0.8)', 'rgba(47, 139, 139, 0.8)'],
                                borderColor: ['#ff6b6b', '#2f8b8b'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: `${results.type}: Mean Comparison`
                                }
                            },
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: `${params.name} (${params.unit})`
                                    }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('‚ùå Error creating means chart:', error);
                }
            }
        }

        // Section 5: Categorical Data Analysis - IMPLEMENTED
        function analyzeCategoricalData() {
            console.log('üìã Analyzing categorical data...');
            
            try {
                const design = document.getElementById('categorical-design')?.value || 'independent';
                const n = parseInt(document.getElementById('categorical-n')?.value) || 200;
                const or = parseFloat(document.getElementById('categorical-or')?.value) || 2.0;
                const outcome = document.getElementById('categorical-outcome')?.value || 'adverse-event';

                let results = {};

                if (design === 'independent') {
                    // 2x2 contingency table
                    const p1 = 0.2; // baseline event rate
                    const p2 = p1 * or / (1 + p1 * (or - 1)); // adjusted for odds ratio
                    
                    const events1 = Math.round(n * p1);
                    const events2 = Math.round(n * p2);
                    const noEvents1 = n - events1;
                    const noEvents2 = n - events2;
                    
                    const chiSq = calculateChiSquare([[events1, noEvents1], [events2, noEvents2]]);
                    const observedOR = (events1 * noEvents2) / (events2 * noEvents1);
                    const rr = p1 / p2;
                    
                    results = {
                        type: 'Chi-square test of independence',
                        table: [[events1, noEvents1], [events2, noEvents2]],
                        chiSq: chiSq.statistic,
                        pValue: chiSq.pValue,
                        or: observedOR,
                        rr: rr,
                        nnt: Math.abs(1 / (p1 - p2))
                    };
                } else if (design === 'case-control') {
                    // Case-control design
                    const exposureRate = 0.3;
                    const cases = n / 2;
                    const controls = n / 2;
                    
                    const exposedCases = Math.round(cases * exposureRate * or / (1 + exposureRate * (or - 1)));
                    const unexposedCases = cases - exposedCases;
                    const exposedControls = Math.round(controls * exposureRate);
                    const unexposedControls = controls - exposedControls;
                    
                    const observedOR = (exposedCases * unexposedControls) / (unexposedCases * exposedControls);
                    const chiSq = calculateChiSquare([[exposedCases, unexposedCases], [exposedControls, unexposedControls]]);
                    
                    results = {
                        type: 'Case-control study (Chi-square test)',
                        table: [[exposedCases, unexposedCases], [exposedControls, unexposedControls]],
                        chiSq: chiSq.statistic,
                        pValue: chiSq.pValue,
                        or: observedOR
                    };
                }

                displayCategoricalResults(results, outcome, n, or);
                createCategoricalVisualization(results, outcome);
                
                console.log('‚úÖ Categorical data analysis completed');

            } catch (error) {
                console.error('‚ùå Error in analyzeCategoricalData:', error);
                showErrorMessage('categorical-results', 'Categorical analysis error: ' + error.message);
            }
        }

        function calculateChiSquare(table) {
            const a = table[0][0], b = table[0][1];
            const c = table[1][0], d = table[1][1];
            const n = a + b + c + d;
            
            const expected = [
                [(a + b) * (a + c) / n, (a + b) * (b + d) / n],
                [(c + d) * (a + c) / n, (c + d) * (b + d) / n]
            ];
            
            let chiSq = 0;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    chiSq += Math.pow(table[i][j] - expected[i][j], 2) / expected[i][j];
                }
            }
            
            const pValue = 1 - chiSquareCDF(chiSq, 1);
            return { statistic: chiSq, pValue: pValue };
        }

        function displayCategoricalResults(results, outcome, n, or) {
            document.getElementById('categorical-results').style.display = 'block';
            document.getElementById('categorical-results').innerHTML = `
                <h4>${results.type}: ${outcome.replace('-', ' ')} Analysis</h4>
                
                <p><strong>Study Design:</strong></p>
                <p>‚Ä¢ Total sample size: ${n}</p>
                <p>‚Ä¢ Expected odds ratio: ${or}</p>
                <p>‚Ä¢ Analysis: ${results.type}</p>
                
                <p><strong>2x2 Contingency Table:</strong></p>
                <table>
                    <tr><th></th><th>Event +</th><th>Event -</th><th>Total</th></tr>
                    <tr><td>Group 1</td><td>${results.table[0][0]}</td><td>${results.table[0][1]}</td><td>${results.table[0][0] + results.table[0][1]}</td></tr>
                    <tr><td>Group 2</td><td>${results.table[1][0]}</td><td>${results.table[1][1]}</td><td>${results.table[1][0] + results.table[1][1]}</td></tr>
                </table>
                
                <p><strong>Statistical Results:</strong></p>
                <p>‚Ä¢ Chi-square statistic: ${results.chiSq.toFixed(2)}</p>
                <p>‚Ä¢ p-value: ${results.pValue.toFixed(4)}</p>
                <p>‚Ä¢ <span class="highlight">Odds ratio: ${results.or.toFixed(2)}</span></p>
                ${results.rr ? `<p>‚Ä¢ Risk ratio: ${results.rr.toFixed(2)}</p>` : ''}
                ${results.nnt ? `<p>‚Ä¢ Number needed to treat: ${results.nnt.toFixed(0)}</p>` : ''}
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ Statistical significance: ${results.pValue < 0.05 ? 'Significant association' : 'No significant association'}</p>
                <p>‚Ä¢ Effect magnitude: ${interpretOR(results.or)}</p>
                <p>‚Ä¢ Clinical relevance: ${getClinicalRelevance(outcome, results.or)}</p>
            `;
        }

        function interpretOR(or) {
            if (or > 2.0) return 'Strong positive association';
            if (or > 1.5) return 'Moderate positive association';
            if (or > 1.1) return 'Weak positive association';
            if (or > 0.9) return 'No meaningful association';
            if (or > 0.67) return 'Weak negative association';
            if (or > 0.5) return 'Moderate negative association';
            return 'Strong negative association';
        }

        function getClinicalRelevance(outcome, or) {
            if (outcome.includes('adverse')) {
                return or > 1.5 ? 'Clinically important safety signal' : 'Acceptable safety profile';
            } else if (outcome.includes('treatment')) {
                return or > 1.5 ? 'Clinically meaningful treatment benefit' : 'Limited treatment benefit';
            }
            return 'Requires clinical context for interpretation';
        }

        function createCategoricalVisualization(results, outcome) {
            const ctx = document.getElementById('categorical-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.categorical) {
                charts.categorical.destroy();
                delete charts.categorical;
            }

            try {
                charts.categorical = new Chart(chartCtx, {
                    type: 'bar',
                    data: {
                        labels: ['Group 1', 'Group 2'],
                        datasets: [{
                            label: 'Events',
                            data: [results.table[0][0], results.table[1][0]],
                            backgroundColor: 'rgba(220, 20, 60, 0.8)',
                            borderColor: '#dc143c',
                            borderWidth: 2
                        }, {
                            label: 'No Events',
                            data: [results.table[0][1], results.table[1][1]],
                            backgroundColor: 'rgba(47, 139, 139, 0.8)',
                            borderColor: '#2f8b8b',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `${outcome.replace('-', ' ')} Analysis`
                            }
                        },
                        scales: {
                            x: {
                                stacked: true
                            },
                            y: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Number of Patients'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating categorical chart:', error);
            }
        }

        // Section 6: Non-parametric Tests - IMPLEMENTED
        function compareParametricNonparametric() {
            console.log('üìä Comparing parametric vs non-parametric tests...');
            
            try {
                const distribution = document.getElementById('data-distribution')?.value || 'normal';
                const sampleSize = parseInt(document.getElementById('nonpar-sample')?.value) || 50;
                const effectSize = parseFloat(document.getElementById('nonpar-effect')?.value) || 0.5;
                const scenario = document.getElementById('nonpar-scenario')?.value || 'pain';

                // Generate data based on distribution type
                let group1Data, group2Data;
                const baseValue = 50;
                
                switch (distribution) {
                    case 'normal':
                        group1Data = generateNormalData(sampleSize, baseValue, 15);
                        group2Data = generateNormalData(sampleSize, baseValue + effectSize * 15, 15);
                        break;
                    case 'skewed':
                        group1Data = generateSkewedData(sampleSize, baseValue, 0.5);
                        group2Data = generateSkewedData(sampleSize, baseValue + effectSize * 15, 0.5);
                        break;
                    case 'outliers':
                        group1Data = generateDataWithOutliers(sampleSize, baseValue, 15);
                        group2Data = generateDataWithOutliers(sampleSize, baseValue + effectSize * 15, 15);
                        break;
                    case 'ordinal':
                        group1Data = generateOrdinalData(sampleSize, baseValue);
                        group2Data = generateOrdinalData(sampleSize, baseValue + effectSize * 2);
                        break;
                }

                // Parametric test (t-test)
                const tTestResults = performTTest(group1Data, group2Data);
                
                // Non-parametric test (Mann-Whitney U)
                const mannWhitneyResults = performMannWhitney(group1Data, group2Data);
                
                // Effect size calculations
                const cohenD = (mean(group2Data) - mean(group1Data)) / Math.sqrt((variance(group1Data) + variance(group2Data)) / 2);
                const rankBiserial = mannWhitneyResults.u1 / (sampleSize * sampleSize);

                const scenarioInfo = getScenarioInfo(scenario);

                displayNonparametricResults(distribution, sampleSize, effectSize, scenarioInfo, 
                                           tTestResults, mannWhitneyResults, cohenD, rankBiserial, group1Data, group2Data);
                
                console.log('‚úÖ Non-parametric comparison completed');

            } catch (error) {
                console.error('‚ùå Error in compareParametricNonparametric:', error);
                showErrorMessage('nonparametric-results', 'Non-parametric test error: ' + error.message);
            }
        }

        function generateSkewedData(n, mean, skew) {
            const data = [];
            for (let i = 0; i < n; i++) {
                const normalValue = generateNormalData(1, mean, 10)[0];
                // Apply skewness transformation
                data.push(Math.exp(normalValue / 20));
            }
            return data;
        }

        function generateDataWithOutliers(n, mean, sd) {
            const data = generateNormalData(Math.floor(n * 0.9), mean, sd);
            const outliers = Math.floor(n * 0.1);
            for (let i = 0; i < outliers; i++) {
                data.push(mean + (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2) * sd);
            }
            return data.sort((a, b) => a - b);
        }

        function generateOrdinalData(n, baseValue) {
            const data = [];
            const scale = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            const center = Math.max(1, Math.min(10, Math.round(baseValue / 10)));
            
            for (let i = 0; i < n; i++) {
                const random = Math.random();
                if (random < 0.3) data.push(center);
                else if (random < 0.6) data.push(Math.max(1, center + (Math.random() > 0.5 ? 1 : -1)));
                else data.push(scale[Math.floor(Math.random() * scale.length)]);
            }
            return data;
        }

        function performTTest(group1, group2) {
            const mean1 = mean(group1);
            const mean2 = mean(group2);
            const var1 = variance(group1);
            const var2 = variance(group2);
            const n1 = group1.length;
            const n2 = group2.length;
            
            const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);
            const se = Math.sqrt(pooledVar * (1/n1 + 1/n2));
            const tStat = (mean2 - mean1) / se;
            const df = n1 + n2 - 2;
            const pValue = 2 * (1 - tCDF(Math.abs(tStat), df));
            
            return { tStat, pValue, df, se };
        }

        function performMannWhitney(group1, group2) {
            const combined = [...group1.map((x, i) => ({value: x, group: 1, index: i})), 
                             ...group2.map((x, i) => ({value: x, group: 2, index: i}))];
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks
            let rank = 1;
            for (let i = 0; i < combined.length; i++) {
                let j = i;
                while (j < combined.length - 1 && combined[j].value === combined[j + 1].value) {
                    j++;
                }
                const avgRank = (rank + rank + (j - i)) / 2;
                for (let k = i; k <= j; k++) {
                    combined[k].rank = avgRank;
                }
                rank = j + 2;
            }
            
            const r1 = combined.filter(x => x.group === 1).reduce((sum, x) => sum + x.rank, 0);
            const n1 = group1.length;
            const n2 = group2.length;
            
            const u1 = r1 - n1 * (n1 + 1) / 2;
            const u2 = n1 * n2 - u1;
            const u = Math.min(u1, u2);
            
            // Normal approximation for p-value
            const meanU = n1 * n2 / 2;
            const sdU = Math.sqrt(n1 * n2 * (n1 + n2 + 1) / 12);
            const z = (u - meanU) / sdU;
            const pValue = 2 * (1 - normalCDF(Math.abs(z)));
            
            return { u1, u2, u, pValue, z };
        }

        function getScenarioInfo(scenario) {
            const scenarios = {
                pain: { 
                    description: "Comparing pain scores before/after intervention",
                    outcome: "Visual Analog Scale (0-10)"
                },
                biomarker: { 
                    description: "Biomarker levels in patient vs control groups",
                    outcome: "Inflammatory marker concentration"
                },
                qol: { 
                    description: "Quality of life assessment in clinical trial",
                    outcome: "SF-36 Physical Component Score"
                },
                los: { 
                    description: "Hospital length of stay comparison",
                    outcome: "Days in hospital"
                }
            };
            return scenarios[scenario] || scenarios.pain;
        }

        function displayNonparametricResults(distribution, sampleSize, effectSize, scenarioInfo, 
                                           tTestResults, mannWhitneyResults, cohenD, rankBiserial, group1Data, group2Data) {
            document.getElementById('nonparametric-results').style.display = 'block';
            document.getElementById('nonparametric-results').innerHTML = `
                <h4>Parametric vs Non-parametric Test Comparison</h4>
                
                <p><strong>Clinical Scenario:</strong> ${scenarioInfo.description}</p>
                <p><strong>Data Characteristics:</strong></p>
                <p>‚Ä¢ Distribution: ${distribution}</p>
                <p>‚Ä¢ Sample size per group: ${sampleSize}</p>
                <p>‚Ä¢ True effect size: ${effectSize}</p>
                <p>‚Ä¢ Outcome measure: ${scenarioInfo.outcome}</p>
                
                <p><strong>Descriptive Statistics:</strong></p>
                <table>
                    <tr><th>Group</th><th>Mean</th><th>Median</th><th>SD</th><th>IQR</th></tr>
                    <tr>
                        <td>Group 1</td>
                        <td>${mean(group1Data).toFixed(2)}</td>
                        <td>${median(group1Data).toFixed(2)}</td>
                        <td>${Math.sqrt(variance(group1Data)).toFixed(2)}</td>
                        <td>${(percentile(group1Data, 75) - percentile(group1Data, 25)).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Group 2</td>
                        <td>${mean(group2Data).toFixed(2)}</td>
                        <td>${median(group2Data).toFixed(2)}</td>
                        <td>${Math.sqrt(variance(group2Data)).toFixed(2)}</td>
                        <td>${(percentile(group2Data, 75) - percentile(group2Data, 25)).toFixed(2)}</td>
                    </tr>
                </table>

                <p><strong>Statistical Test Comparison:</strong></p>
                <table>
                    <tr><th>Test Type</th><th>Test Statistic</th><th>p-value</th><th>Effect Size</th><th>Interpretation</th></tr>
                    <tr style="background-color: ${tTestResults.pValue < 0.05 ? '#e8ffe8' : '#ffe8e8'}">
                        <td>Two-sample t-test</td>
                        <td>t = ${tTestResults.tStat.toFixed(2)}</td>
                        <td>${tTestResults.pValue.toFixed(4)}</td>
                        <td>d = ${cohenD.toFixed(3)}</td>
                        <td>${tTestResults.pValue < 0.05 ? 'Significant' : 'Not significant'}</td>
                    </tr>
                    <tr style="background-color: ${mannWhitneyResults.pValue < 0.05 ? '#e8ffe8' : '#ffe8e8'}">
                        <td>Mann-Whitney U</td>
                        <td>U = ${mannWhitneyResults.u1.toFixed(0)}</td>
                        <td>${mannWhitneyResults.pValue.toFixed(4)}</td>
                        <td>r = ${rankBiserial.toFixed(3)}</td>
                        <td>${mannWhitneyResults.pValue < 0.05 ? 'Significant' : 'Not significant'}</td>
                    </tr>
                </table>

                <p><strong>Test Assumptions:</strong></p>
                <p>‚Ä¢ <strong>t-test assumptions:</strong> ${checkTTestAssumptions(distribution)}</p>
                <p>‚Ä¢ <strong>Mann-Whitney assumptions:</strong> ${checkMannWhitneyAssumptions()}</p>
                
                <p><strong>Recommendation:</strong></p>
                <p>‚Ä¢ <span class="highlight">${getTestRecommendation(distribution, tTestResults.pValue, mannWhitneyResults.pValue)}</span></p>
                <p>‚Ä¢ Clinical significance: ${interpretClinicalSignificance(scenarioInfo, effectSize)}</p>
                <p>‚Ä¢ Regulatory consideration: ${getRegulatory(scenarioInfo.description.includes('pain') ? 'pain' : scenarioInfo.description.includes('biomarker') ? 'biomarker' : scenarioInfo.description.includes('quality') ? 'qol' : 'los')}</p>
            `;
        }

        function median(data) {
            const sorted = [...data].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }

        function percentile(data, p) {
            const sorted = [...data].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function checkTTestAssumptions(distribution) {
            switch (distribution) {
                case 'normal': return 'Met (normal distribution)';
                case 'skewed': return 'Violated (non-normal distribution)';
                case 'outliers': return 'Questionable (outliers present)';
                case 'ordinal': return 'Violated (ordinal scale)';
                default: return 'Check normality';
            }
        }

        function checkMannWhitneyAssumptions() {
            return 'Met (only requires independent groups)';
        }

        function getTestRecommendation(distribution, tP, mannP) {
            if (distribution === 'normal') {
                return 't-test preferred (assumptions met, more powerful)';
            } else {
                return 'Mann-Whitney U preferred (robust to assumption violations)';
            }
        }

        function interpretClinicalSignificance(scenarioInfo, effectSize) {
            if (effectSize >= 0.5) return 'Large clinical impact expected';
            if (effectSize >= 0.3) return 'Moderate clinical impact';
            return 'Small clinical impact';
        }

        function getRegulatory(setting) {
            const regulatory = {
                pain: 'Pain assessment tools require Health Canada validation',
                biomarker: 'Biomarker qualification through Health Canada guidance',
                qol: 'Quality of life instruments for regulatory endpoints',
                los: 'Healthcare utilization metrics for health economics'
            };
            return regulatory[setting] || 'Standard regulatory considerations apply';
        }

        // Section 7: Diagnostic Test Evaluation - IMPLEMENTED
        function simulateDiagnosticTest() {
            console.log('üî¨ Simulating diagnostic test...');
            
            try {
                const prevalence = parseFloat(document.getElementById('prevalence')?.value) / 100 || 0.2;
                const n = parseInt(document.getElementById('diagnostic-n')?.value) || 500;
                const performance = document.getElementById('test-performance')?.value || 'good';
                const setting = document.getElementById('clinical-setting')?.value || 'screening';

                // Set performance characteristics based on test quality
                const performanceParams = {
                    excellent: { sensitivity: 0.92, specificity: 0.95 },
                    good: { sensitivity: 0.85, specificity: 0.88 },
                    moderate: { sensitivity: 0.75, specificity: 0.78 },
                    poor: { sensitivity: 0.65, specificity: 0.68 }
                };

                const { sensitivity, specificity } = performanceParams[performance];
                
                // Calculate sample composition
                const diseased = Math.round(n * prevalence);
                const healthy = n - diseased;
                
                // Calculate confusion matrix
                const tp = Math.round(diseased * sensitivity);
                const fn = diseased - tp;
                const tn = Math.round(healthy * specificity);
                const fp = healthy - tn;
                
                // Calculate performance metrics
                const ppv = tp / (tp + fp);
                const npv = tn / (tn + fn);
                const accuracy = (tp + tn) / n;
                const lrPositive = sensitivity / (1 - specificity);
                const lrNegative = (1 - sensitivity) / specificity;
                const diagnosticOR = lrPositive / lrNegative;
                
                // Calculate AUC (approximation based on sensitivity/specificity)
                const auc = (sensitivity + specificity) / 2;
                
                // Generate ROC points
                const rocPoints = generateROCPoints(sensitivity, specificity);
                
                // Clinical interpretation
                const settingInfo = getSettingInfo(setting);

                displayDiagnosticResults(n, prevalence, performance, setting, settingInfo, tp, fp, fn, tn, 
                                      ppv, npv, accuracy, lrPositive, lrNegative, diagnosticOR, auc);

                createDiagnosticVisualization(rocPoints, auc, performance);
                
                console.log('‚úÖ Diagnostic test simulation completed');

            } catch (error) {
                console.error('‚ùå Error in simulateDiagnosticTest:', error);
                showErrorMessage('diagnostic-results', 'Diagnostic test error: ' + error.message);
            }
        }

        function generateROCPoints(baseSens, baseSpec) {
            const points = [];
            for (let threshold = 0; threshold <= 1; threshold += 0.05) {
                // Approximate sensitivity/specificity at different thresholds
                const sens = baseSens * (1 - threshold * 0.3);
                const spec = baseSpec * (0.5 + threshold * 0.5);
                const fpr = 1 - Math.max(0, Math.min(1, spec));
                const tpr = Math.max(0, Math.min(1, sens));
                points.push({ x: fpr, y: tpr });
            }
            return points.sort((a, b) => a.x - b.x);
        }

        function displayDiagnosticResults(n, prevalence, performance, setting, settingInfo, tp, fp, fn, tn, 
                                        ppv, npv, accuracy, lrPositive, lrNegative, diagnosticOR, auc) {
            const sensitivity = tp / (tp + fn);
            const specificity = tn / (tn + fp);
            const diseased = tp + fn;
            const healthy = tn + fp;
            
            document.getElementById('diagnostic-results').style.display = 'block';
            document.getElementById('diagnostic-results').innerHTML = `
                <h4>Diagnostic Test Performance Analysis</h4>
                
                <p><strong>Study Characteristics:</strong></p>
                <p>‚Ä¢ Clinical setting: ${settingInfo.name}</p>
                <p>‚Ä¢ Sample size: ${n} patients</p>
                <p>‚Ä¢ Disease prevalence: ${(prevalence * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Test performance level: ${performance}</p>
                
                <p><strong>2√ó2 Diagnostic Table:</strong></p>
                <table>
                    <tr><th></th><th>Disease +</th><th>Disease -</th><th>Total</th></tr>
                    <tr><td><strong>Test +</strong></td><td>${tp} (TP)</td><td>${fp} (FP)</td><td>${tp + fp}</td></tr>
                    <tr><td><strong>Test -</strong></td><td>${fn} (FN)</td><td>${tn} (TN)</td><td>${fn + tn}</td></tr>
                    <tr><td><strong>Total</strong></td><td>${diseased}</td><td>${healthy}</td><td>${n}</td></tr>
                </table>

                <p><strong>Primary Performance Metrics:</strong></p>
                <table>
                    <tr><th>Metric</th><th>Value</th><th>95% CI</th><th>Interpretation</th></tr>
                    <tr>
                        <td>Sensitivity</td>
                        <td>${(sensitivity * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tp, diseased)}</td>
                        <td>Probability of positive test given disease</td>
                    </tr>
                    <tr>
                        <td>Specificity</td>
                        <td>${(specificity * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tn, healthy)}</td>
                        <td>Probability of negative test given no disease</td>
                    </tr>
                    <tr>
                        <td>PPV</td>
                        <td>${(ppv * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tp, tp + fp)}</td>
                        <td>Probability of disease given positive test</td>
                    </tr>
                    <tr>
                        <td>NPV</td>
                        <td>${(npv * 100).toFixed(1)}%</td>
                        <td>${calculateCI(tn, tn + fn)}</td>
                        <td>Probability of no disease given negative test</td>
                    </tr>
                </table>

                <p><strong>Advanced Metrics:</strong></p>
                <p>‚Ä¢ Overall accuracy: ${(accuracy * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Positive likelihood ratio: ${lrPositive.toFixed(2)}</p>
                <p>‚Ä¢ Negative likelihood ratio: ${lrNegative.toFixed(3)}</p>
                <p>‚Ä¢ Diagnostic odds ratio: ${diagnosticOR.toFixed(1)}</p>
                <p>‚Ä¢ <span class="highlight">Area Under ROC Curve: ${auc.toFixed(3)}</span></p>

                <p><strong>Clinical Utility Assessment:</strong></p>
                <p>‚Ä¢ Test quality: ${interpretAUC(auc)}</p>
                <p>‚Ä¢ Clinical application: ${settingInfo.application}</p>
                <p>‚Ä¢ Key consideration: ${getKeyConsideration(setting, ppv, npv)}</p>
                <p>‚Ä¢ Regulatory pathway: ${getRegulatoryPathway(setting, accuracy)}</p>

                <p><strong>Economic Impact (per 1000 tests):</strong></p>
                <p>‚Ä¢ True positives identified: ${Math.round(tp * 1000 / n)}</p>
                <p>‚Ä¢ False positives (unnecessary follow-up): ${Math.round(fp * 1000 / n)}</p>
                <p>‚Ä¢ False negatives (missed cases): ${Math.round(fn * 1000 / n)}</p>
                <p>‚Ä¢ Estimated cost per correct diagnosis: CAD $${calculateCostPerDiagnosis(settingInfo, accuracy)}</p>
            `;
        }

        function calculateCI(successes, total) {
            const p = successes / total;
            const se = Math.sqrt(p * (1 - p) / total);
            const margin = 1.96 * se;
            const lower = Math.max(0, p - margin);
            const upper = Math.min(1, p + margin);
            return `[${(lower * 100).toFixed(1)}%, ${(upper * 100).toFixed(1)}%]`;
        }

        function getSettingInfo(setting) {
            const settings = {
                screening: {
                    name: 'Population Screening',
                    application: 'High sensitivity preferred to minimize false negatives'
                },
                diagnostic: {
                    name: 'Diagnostic Workup',
                    application: 'Balance between sensitivity and specificity'
                },
                monitoring: {
                    name: 'Disease Monitoring',
                    application: 'High specificity to avoid false alarms'
                },
                research: {
                    name: 'Research Biomarker',
                    application: 'High discriminatory ability required'
                }
            };
            return settings[setting] || settings.screening;
        }

        function interpretAUC(auc) {
            if (auc >= 0.9) return 'Excellent discrimination';
            if (auc >= 0.8) return 'Good discrimination';
            if (auc >= 0.7) return 'Fair discrimination';
            if (auc >= 0.6) return 'Poor discrimination';
            return 'No discriminatory ability';
        }

        function getKeyConsideration(setting, ppv, npv) {
            if (setting === 'screening') {
                return `High NPV (${(npv * 100).toFixed(1)}%) critical for ruling out disease`;
            } else if (setting === 'diagnostic') {
                return `Balanced PPV (${(ppv * 100).toFixed(1)}%) and NPV (${(npv * 100).toFixed(1)}%) needed`;
            }
            return `PPV (${(ppv * 100).toFixed(1)}%) depends on disease prevalence in population`;
        }

        function getRegulatoryPathway(setting, accuracy) {
            if (accuracy >= 0.85) {
                return 'Health Canada Class II - moderate risk medical device';
            } else if (accuracy >= 0.75) {
                return 'Health Canada Class I - low risk, enhanced oversight required';
            } else {
                return 'Performance insufficient for regulatory approval';
            }
        }

        function calculateCostPerDiagnosis(settingInfo, accuracy) {
            const baseCosts = {
                'Population Screening': 150,
                'Diagnostic Workup': 250,
                'Disease Monitoring': 200,
                'Research Biomarker': 500
            };
            const baseCost = baseCosts[settingInfo.name] || 200;
            return Math.round(baseCost / accuracy);
        }

        function createDiagnosticVisualization(rocPoints, auc, performance) {
            const ctx = document.getElementById('diagnostic-chart');
            if (!ctx) return;
            
            const chartCtx = ctx.getContext('2d');
            if (!chartCtx) return;

            if (charts.diagnostic) {
                charts.diagnostic.destroy();
                delete charts.diagnostic;
            }

            try {
                charts.diagnostic = new Chart(chartCtx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: `ROC Curve (AUC = ${auc.toFixed(3)})`,
                            data: rocPoints,
                            borderColor: '#2f8b8b',
                            backgroundColor: 'rgba(47, 139, 139, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }, {
                            label: 'Random Chance (AUC = 0.5)',
                            data: [{x: 0, y: 0}, {x: 1, y: 1}],
                            borderColor: '#999',
                            borderWidth: 2,
                            borderDash: [10, 5],
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `ROC Curve Analysis - ${performance} Performance`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'False Positive Rate (1 - Specificity)'
                                },
                                min: 0,
                                max: 1
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'True Positive Rate (Sensitivity)'
                                },
                                min: 0,
                                max: 1
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå Error creating diagnostic chart:', error);
            }
        }

        // Generic error display function
        function showErrorMessage(containerId, message) {
            const container = document.getElementById(containerId);
            if (container) {
                container.style.display = 'block';
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #dc143c; border: 2px solid #dc143c; border-radius: 8px;">
                        <h4>‚ö†Ô∏è Error</h4>
                        <p>${message}</p>
                        <button onclick="location.reload()">üîÑ Refresh Page</button>
                    </div>
                `;
            }
        }
        function getRegPathway(regulatory) {
            const pathways = {
                generic: 'Health Canada ANDS (Abbreviated New Drug Submission)',
                biosimilar: 'Health Canada NDS - Biosimilar pathway',
                device: 'Health Canada MDL (Medical Device License)',
                fda: 'US FDA ANDA (Abbreviated New Drug Application)'
            };
            return pathways[regulatory] || 'Standard regulatory pathway';
        }

        function getClinSignificance(studyType, diff, margin) {
            const absDiff = Math.abs(diff);
            if (studyType === 'equivalence') {
                if (absDiff < margin * 0.5) return 'Strong clinical equivalence';
                if (absDiff < margin) return 'Clinical equivalence within acceptable range';
                return 'Clinically meaningful difference detected';
            }
            return diff < margin ? 'Non-inferiority with clinical relevance' : 'Clinical inferiority possible';
        }

        function calculateMedianSurvival(kmData) {
            const medianPoint = kmData.find(point => point.survival <= 0.5);
            return medianPoint ? medianPoint.time : null;
        }

        function getSurvivalAtTime(kmData, targetTime) {
            if (kmData.length === 0) return 1.0;
            let survival = 1.0;
            for (const point of kmData) {
                if (point.time <= targetTime) {
                    survival = point.survival;
                } else {
                    break;
                }
            }
            return survival;
        }

        function getSurvivalContext(context) {
            const contexts = {
                cancer: {
                    title: 'Cancer Treatment Trial',
                    description: 'Comparing overall survival between treatment regimens',
                    group1: 'Standard therapy',
                    group2: 'Experimental therapy'
                },
                cardiovascular: {
                    title: 'Cardiovascular Prevention Study',
                    description: 'Primary prevention of major cardiovascular events',
                    group1: 'Placebo',
                    group2: 'Active treatment'
                },
                'chronic-disease': {
                    title: 'Chronic Disease Management',
                    description: 'Comparing disease progression between treatments',
                    group1: 'Standard care',
                    group2: 'Intensive management'
                },
                device: {
                    title: 'Medical Device Study',
                    description: 'Device failure time comparison',
                    group1: 'Standard device',
                    group2: 'New device'
                }
            };
            return contexts[context] || contexts.cancer;
        }

        function interpretHR(hr) {
            if (hr < 0.5) return 'Large reduction in hazard';
            if (hr < 0.75) return 'Moderate reduction in hazard';
            if (hr < 0.9) return 'Small reduction in hazard';
            if (hr < 1.1) return 'No meaningful difference';
            return 'Increase in hazard';
        }

        function interpretSurvivalClinical(contextInfo, hr, pValue) {
            if (pValue >= 0.05) return 'No statistically significant survival benefit detected';
            if (hr < 0.8) return 'Clinically meaningful survival benefit';
            return 'Modest survival benefit - clinical significance unclear';
        }

        // Error handling functions
        function showEquivalenceError(message) {
            const resultsDiv = document.getElementById('equivalence-results');
            if (resultsDiv) {
                resultsDiv.style.display = 'block';
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #dc143c; border: 2px solid #dc143c; border-radius: 8px;">
                        <h4>‚ö†Ô∏è Equivalence Study Error</h4>
                        <p>${message}</p>
                        <button onclick="designEquivalenceStudy()">üîÑ Try Again</button>
                    </div>
                `;
            }
        }

        function showSurvivalError(message) {
            const resultsDiv = document.getElementById('survival-results');
            if (resultsDiv) {
                resultsDiv.style.display = 'block';
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #dc143c; border: 2px solid #dc143c; border-radius: 8px;">
                        <h4>‚ö†Ô∏è Survival Study Error</h4>
                        <p>${message}</p>
                        <button onclick="simulateSurvivalStudy()">üîÑ Try Again</button>
                    </div>
                `;
            }
        }

        function showAssessmentError(message) {
            const container = document.getElementById('hypothesis-questions-container');
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #dc143c; border: 2px solid #dc143c; border-radius: 8px;">
                        <h4>‚ö†Ô∏è Assessment Error</h4>
                        <p>${message}</p>
                        <button onclick="generateHypothesisQuestions()">üîÑ Try Again</button>
                    </div>
                `;
            }
        }

        // Initialize
        window.onload = function() {
            console.log('üî¨ Hypothesis Testing Tool Loaded');
            generateHypothesisQuestions();
            showSection('framework');
        };
    </script>
</body>
</html>
