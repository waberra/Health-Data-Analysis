<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Foundation Series: Descriptive Medical Statistics & Healthcare Data Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f8fffe;
            color: #2c3e50;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #20b2aa;
        }
        h1 {
            color: #dc143c;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        h2 {
            color: #dc143c;
            border-bottom: 3px solid #dc143c;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        h3 {
            color: #2f8b8b;
            margin-top: 25px;
        }
        .subtitle {
            text-align: center;
            color: #2f8b8b;
            font-size: 1.1em;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .foundation-badge {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: bold;
            text-align: center;
            margin: 20px auto;
            display: inline-block;
            font-size: 0.9em;
        }
        .section {
            background: #f0ffff;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #2f8b8b;
        }
        .concept {
            background: #e8fffe;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #20b2aa;
        }
        .controls {
            background: #f8ffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #20b2aa;
        }
        button {
            background: linear-gradient(45deg, #2f8b8b, #20b2aa);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: transform 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .results {
            background: #ffffff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .chart-container {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #20b2aa;
            height: 400px;
            position: relative;
        }
        select, input {
            padding: 8px;
            margin: 5px;
            border: 2px solid #20b2aa;
            border-radius: 4px;
            background: white;
        }
        .formula {
            background: #f0f8ff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #2f8b8b;
            font-size: 0.95em;
        }
        .definition-box {
            background: #ffffff;
            border: 2px solid #20b2aa;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            border-left: 8px solid #2f8b8b;
        }
        .assessment {
            background: linear-gradient(to right, #f0ffff, #e8fffe);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #2f8b8b;
        }
        .question {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #20b2aa;
        }
        .highlight {
            background: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .canadian-context {
            background: linear-gradient(to right, #ffe8e8, #fff0f0);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .ethics-box {
            background: linear-gradient(to right, #fff8dc, #fffacd);
            border: 2px solid #daa520;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #20b2aa;
            padding: 8px;
            text-align: left;
        }
        th {
            background: #2f8b8b;
            color: white;
        }
        tr:nth-child(even) {
            background: #f8fffe;
        }
        .navigation {
            background: #e8fffe;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            border: 1px solid #20b2aa;
        }
        .nav-button {
            background: #2f8b8b;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .nav-button:hover {
            background: #20b2aa;
        }
        .section-content {
            display: none;
        }
        .section-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Foundation Series: Descriptive Medical Statistics & Healthcare Data Analysis</h1>
        <div class="subtitle">Essential Statistical Foundations for Health Research</div>
        
        <div class="foundation-badge">üè• FOUNDATION SERIES: Building Statistical Literacy in Healthcare</div>

        <div class="navigation">
            <h3>Navigate the Foundation Series</h3>
            <button class="nav-button" onclick="showSection('means')">Measures of Central Tendency</button>
            <button class="nav-button" onclick="showSection('missing')">Missing Data Mechanisms</button>
            <button class="nav-button" onclick="showSection('rates')">Rates, Ratios & Proportions</button>
            <button class="nav-button" onclick="showSection('standardization')">Age Standardization</button>
            <button class="nav-button" onclick="showSection('confidence')">Confidence Intervals</button>
            <button class="nav-button" onclick="showSection('data-sources')">Canadian Healthcare Data</button>
            <button class="nav-button" onclick="showSection('visualizations')">Medical Visualizations</button>
            <button class="nav-button" onclick="showSection('quality')">Data Quality & Ethics</button>
            <button class="nav-button" onclick="showSection('system')">Healthcare System Context</button>
            <button class="nav-button" onclick="showSection('assessment')">Assessment</button>
        </div>

        <!-- Section 1: Measures of Central Tendency -->
        <div id="means-section" class="section-content active">
            <div class="section">
                <h2>üìä Advanced Measures of Central Tendency</h2>
                
                <div class="concept">
                    <h3>Arithmetic, Weighted, and Geometric Means</h3>
                    
                    <div class="definition-box">
                        <h4>When to Use Each Mean:</h4>
                        <p><strong>Arithmetic Mean:</strong> Symmetric data, equal importance of all observations</p>
                        <p><strong>Weighted Mean:</strong> Different observations have different importance (sample sizes, precision)</p>
                        <p><strong>Geometric Mean:</strong> Multiplicative processes, rates of change, skewed data</p>
                    </div>

                    <div class="formula">
                        Arithmetic Mean: xÃÑ = (Œ£xi) / n
                        <br>Weighted Mean: xÃÑw = (Œ£ wi √ó xi) / (Œ£ wi)
                        <br>Geometric Mean: xÃÑg = ‚Åø‚àö(x‚ÇÅ √ó x‚ÇÇ √ó ... √ó x‚Çô) = exp[(Œ£ ln(xi))/n]
                    </div>

                    <div class="controls">
                        <h4>Canadian Healthcare Example: Multi-Center Drug Trial</h4>
                        <label>Number of Centers: <input type="number" id="num-centers" value="5" min="3" max="8" step="1"></label><br>
                        <label>Base Response Rate (%): <input type="number" id="base-response" value="65" min="40" max="90" step="5"></label><br>
                        <label>Variation Between Centers: <input type="range" id="center-variation" min="0.1" max="0.3" step="0.05" value="0.15"></label>
                        <span id="variation-display">15%</span><br>
                        <button onclick="calculateMeans()">Calculate Different Means</button>
                    </div>

                    <div id="means-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="means-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 2: Missing Data Mechanisms -->
        <div id="missing-section" class="section-content">
            <div class="section">
                <h2>üîç Missing Data Mechanisms in Healthcare</h2>
                
                <div class="concept">
                    <h3>Understanding MCAR, MAR, and NMAR</h3>
                    
                    <div class="definition-box">
                        <h4>Missing Data Mechanisms:</h4>
                        <p><strong>MCAR (Missing Completely at Random):</strong> Missingness is unrelated to any observed or unobserved variables</p>
                        <p><strong>MAR (Missing at Random):</strong> Missingness depends on observed variables but not on the missing values themselves</p>
                        <p><strong>NMAR (Not Missing at Random):</strong> Missingness depends on the unobserved values</p>
                    </div>

                    <div class="canadian-context">
                        <h4>Canadian Healthcare Examples:</h4>
                        <p><strong>MCAR:</strong> Lab equipment randomly fails during processing</p>
                        <p><strong>MAR:</strong> Older patients more likely to miss follow-up appointments (age is observed)</p>
                        <p><strong>NMAR:</strong> Patients with severe depression skip mental health assessments</p>
                    </div>

                    <div class="controls">
                        <h4>Simulate Missing Data in Patient Registry</h4>
                        <label>Total Patients: <input type="number" id="total-patients" value="1000" min="500" max="2000" step="100"></label><br>
                        <label>Missing Mechanism: 
                            <select id="missing-mechanism">
                                <option value="MCAR">MCAR - Random Equipment Failure</option>
                                <option value="MAR">MAR - Age-Related Missingness</option>
                                <option value="NMAR">NMAR - Severity-Related Missingness</option>
                            </select>
                        </label><br>
                        <label>Missing Rate (%): <input type="number" id="missing-rate" value="15" min="5" max="40" step="5"></label><br>
                        <button onclick="simulateMissingData()">Simulate Missing Data Pattern</button>
                    </div>

                    <div id="missing-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="missing-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Rates, Ratios & Proportions -->
        <div id="rates-section" class="section-content">
            <div class="section">
                <h2>üìà Rates, Ratios & Proportions in Public Health</h2>
                
                <div class="concept">
                    <h3>Fundamental Epidemiological Measures</h3>
                    
                    <div class="definition-box">
                        <h4>Key Measures:</h4>
                        <p><strong>Incidence Rate:</strong> New cases per population per time period</p>
                        <p><strong>Prevalence:</strong> Existing cases in population at specific time</p>
                        <p><strong>Mortality Rate:</strong> Deaths per population per time period</p>
                        <p><strong>Relative Risk:</strong> Risk in exposed / Risk in unexposed</p>
                        <p><strong>Case Fatality Rate:</strong> Deaths among cases</p>
                    </div>

                    <div class="formula">
                        Incidence Rate = (New Cases in Time Period) / (Population at Risk √ó Time Period)
                        <br>Prevalence = (Existing Cases) / (Total Population)
                        <br>Mortality Rate = (Deaths in Time Period) / (Population √ó Time Period)
                        <br>Relative Risk = [a/(a+b)] / [c/(c+d)]
                    </div>

                    <div class="controls">
                        <h4>Canadian Provincial Health Comparison</h4>
                        <label>Province A Population: <input type="number" id="pop-a" value="5000000" min="1000000" max="15000000" step="100000"></label><br>
                        <label>Province B Population: <input type="number" id="pop-b" value="1500000" min="500000" max="5000000" step="100000"></label><br>
                        <label>Disease: 
                            <select id="disease-type">
                                <option value="diabetes">Type 2 Diabetes</option>
                                <option value="covid">COVID-19</option>
                                <option value="heart">Heart Disease</option>
                                <option value="cancer">Lung Cancer</option>
                            </select>
                        </label><br>
                        <label>Time Period (years): <input type="number" id="time-period" value="1" min="0.5" max="5" step="0.5"></label><br>
                        <button onclick="calculateRates()">Calculate Epidemiological Measures</button>
                    </div>

                    <div id="rates-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="rates-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Age Standardization -->
        <div id="standardization-section" class="section-content">
            <div class="section">
                <h2>‚öñÔ∏è Age Standardization for Population Comparisons</h2>
                
                <div class="concept">
                    <h3>Direct and Indirect Standardization</h3>
                    
                    <div class="definition-box">
                        <h4>Why Age-Standardize?</h4>
                        <p>Age is a major confounder in health outcomes. Age standardization allows fair comparison between populations with different age structures.</p>
                        <p><strong>Direct Method:</strong> Apply age-specific rates to standard population</p>
                        <p><strong>Indirect Method:</strong> Compare observed to expected cases using standard rates</p>
                    </div>

                    <div class="formula">
                        Direct Age-Standardized Rate = Œ£(wi √ó ri)
                        <br>where wi = proportion in age group i of standard population
                        <br>ri = age-specific rate in study population for age group i
                        <br><br>
                        SMR (Standardized Mortality Ratio) = (Observed Deaths / Expected Deaths) √ó 100
                    </div>

                    <div class="controls">
                        <h4>Compare Alberta vs Nova Scotia Mortality</h4>
                        <label>Standard Population: 
                            <select id="standard-pop">
                                <option value="canada">Canada 2021 Census</option>
                                <option value="who">WHO World Standard</option>
                            </select>
                        </label><br>
                        <label>Disease Focus: 
                            <select id="disease-focus">
                                <option value="cardiovascular">Cardiovascular Disease</option>
                                <option value="cancer">All Cancers</option>
                                <option value="respiratory">Respiratory Disease</option>
                            </select>
                        </label><br>
                        <label>Year: <input type="number" id="study-year" value="2022" min="2018" max="2024" step="1"></label><br>
                        <button onclick="calculateStandardization()">Calculate Age-Standardized Rates</button>
                    </div>

                    <div id="standardization-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="standardization-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 5: Confidence Intervals -->
        <div id="confidence-section" class="section-content">
            <div class="section">
                <h2>üéØ Confidence Intervals in Medical Research</h2>
                
                <div class="concept">
                    <h3>Understanding and Interpreting Confidence Intervals</h3>
                    
                    <div class="definition-box">
                        <h4>What Confidence Intervals Tell Us:</h4>
                        <p>A 95% CI means that if we repeated the study many times, 95% of the intervals would contain the true population parameter.</p>
                        <p><strong>Wide CI:</strong> Less precision, smaller sample size, more variability</p>
                        <p><strong>Narrow CI:</strong> More precision, larger sample size, less variability</p>
                        <p><strong>CI excludes null value:</strong> Statistically significant result</p>
                    </div>

                    <div class="formula">
                        For Mean: xÃÑ ¬± t(Œ±/2, df) √ó (s/‚àön)
                        <br>For Proportion: p ¬± z(Œ±/2) √ó ‚àö[p(1-p)/n]
                        <br>For Difference: (xÃÑ‚ÇÅ - xÃÑ‚ÇÇ) ¬± t(Œ±/2, df) √ó SE(difference)
                        <br>For Relative Risk: exp[ln(RR) ¬± z(Œ±/2) √ó SE(ln(RR))]
                    </div>

                    <div class="controls">
                        <h4>Clinical Trial: Blood Pressure Reduction</h4>
                        <label>Sample Size per Group: <input type="number" id="ci-sample-size" value="120" min="30" max="500" step="10"></label><br>
                        <label>Treatment Effect (mmHg): <input type="number" id="ci-effect" value="8.5" min="2" max="20" step="0.5"></label><br>
                        <label>Standard Deviation: <input type="number" id="ci-sd" value="15" min="8" max="25" step="1"></label><br>
                        <label>Confidence Level: 
                            <select id="ci-level">
                                <option value="90">90%</option>
                                <option value="95" selected>95%</option>
                                <option value="99">99%</option>
                            </select>
                        </label><br>
                        <button onclick="calculateConfidenceIntervals()">Calculate Confidence Intervals</button>
                    </div>

                    <div id="confidence-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="confidence-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 6: Canadian Healthcare Data Sources -->
        <div id="data-sources-section" class="section-content">
            <div class="section">
                <h2>üá®üá¶ Canadian Healthcare Data Sources & Linkage</h2>
                
                <div class="concept">
                    <h3>Understanding Canadian Health Data Landscape</h3>
                    
                    <div class="definition-box">
                        <h4>Major National Data Sources:</h4>
                        <p><strong>CCHS (Canadian Community Health Survey):</strong> Population health survey</p>
                        <p><strong>DAD (Discharge Abstract Database):</strong> Hospital separations</p>
                        <p><strong>NACRS (National Ambulatory Care Reporting System):</strong> Emergency department visits</p>
                        <p><strong>OMIM (Ontario Mental Health Reporting System):</strong> Mental health services</p>
                        <p><strong>CIHI (Canadian Institute for Health Information):</strong> National health data coordination</p>
                    </div>

                    <div class="canadian-context">
                        <h4>Provincial Variations:</h4>
                        <p><strong>Ontario:</strong> OHIP billing, ICES data center</p>
                        <p><strong>Quebec:</strong> RAMQ, R√©gie de l'assurance maladie</p>
                        <p><strong>British Columbia:</strong> MSP, Population Data BC</p>
                        <p><strong>Alberta:</strong> AHCIP, Alberta Health administrative data</p>
                    </div>

                    <div class="controls">
                        <h4>Data Linkage Scenario Simulator</h4>
                        <label>Research Question: 
                            <select id="research-question">
                                <option value="diabetes">Diabetes care across primary/secondary care</option>
                                <option value="mental-health">Mental health service utilization</option>
                                <option value="cancer">Cancer screening to treatment pathway</option>
                                <option value="covid">COVID-19 vaccination effectiveness</option>
                            </select>
                        </label><br>
                        <label>Province: 
                            <select id="province">
                                <option value="ontario">Ontario</option>
                                <option value="quebec">Quebec</option>
                                <option value="bc">British Columbia</option>
                                <option value="alberta">Alberta</option>
                            </select>
                        </label><br>
                        <label>Study Period (years): <input type="number" id="study-period" value="5" min="1" max="10" step="1"></label><br>
                        <button onclick="simulateDataLinkage()">Simulate Data Linkage Strategy</button>
                    </div>

                    <div id="data-sources-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="data-sources-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 7: Medical Visualizations -->
        <div id="visualizations-section" class="section-content">
            <div class="section">
                <h2>üìä Essential Medical Data Visualizations</h2>
                
                <div class="concept">
                    <h3>Choosing Appropriate Chart Types for Healthcare Data</h3>
                    
                    <div class="definition-box">
                        <h4>Medical Visualization Types:</h4>
                        <p><strong>Forest Plot:</strong> Meta-analysis results, effect sizes with confidence intervals</p>
                        <p><strong>Funnel Plot:</strong> Publication bias detection in systematic reviews</p>
                        <p><strong>Kaplan-Meier Curves:</strong> Survival analysis, time-to-event data</p>
                        <p><strong>ROC Curves:</strong> Diagnostic test performance</p>
                        <p><strong>Epidemiological Curves:</strong> Disease outbreak patterns</p>
                    </div>

                    <div class="controls">
                        <h4>Interactive Visualization Selector</h4>
                        <label>Data Type: 
                            <select id="viz-data-type">
                                <option value="meta-analysis">Meta-Analysis Results</option>
                                <option value="survival">Survival Data</option>
                                <option value="diagnostic">Diagnostic Test Performance</option>
                                <option value="outbreak">Disease Outbreak</option>
                            </select>
                        </label><br>
                        <label>Number of Studies/Groups: <input type="number" id="viz-groups" value="6" min="3" max="12" step="1"></label><br>
                        <label>Effect Size Variation: <input type="range" id="viz-variation" min="0.1" max="0.8" step="0.1" value="0.3"></label>
                        <span id="viz-variation-display">30%</span><br>
                        <button onclick="createMedicalVisualization()">Generate Medical Visualization</button>
                    </div>

                    <div id="visualizations-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="visualizations-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 8: Data Quality & Ethics -->
        <div id="quality-section" class="section-content">
            <div class="section">
                <h2>üîç Data Quality & Research Ethics in Healthcare</h2>
                
                <div class="concept">
                    <h3>Ensuring Data Integrity and Ethical Compliance</h3>
                    
                    <div class="definition-box">
                        <h4>Data Quality Dimensions:</h4>
                        <p><strong>Completeness:</strong> Missing data patterns and impact</p>
                        <p><strong>Accuracy:</strong> Correct values, validation rules</p>
                        <p><strong>Consistency:</strong> Data agrees across sources</p>
                        <p><strong>Timeliness:</strong> Data currency and recording delays</p>
                        <p><strong>Validity:</strong> Data measures what it claims to measure</p>
                    </div>

                    <div class="ethics-box">
                        <h4>Canadian Privacy Legislation:</h4>
                        <p><strong>PIPEDA (Federal):</strong> Personal Information Protection and Electronic Documents Act</p>
                        <p><strong>Provincial Acts:</strong> Health Information Acts (HIA) in each province</p>
                        <p><strong>Tri-Council Policy (TCPS2):</strong> Research ethics guidelines</p>
                        <p><strong>De-identification:</strong> Safe Harbor vs Expert Determination methods</p>
                    </div>

                    <div class="controls">
                        <h4>Data Quality Assessment Tool</h4>
                        <label>Dataset Type: 
                            <select id="quality-dataset">
                                <option value="ehr">Electronic Health Records</option>
                                <option value="registry">Disease Registry</option>
                                <option value="survey">Population Survey</option>
                                <option value="clinical-trial">Clinical Trial</option>
                            </select>
                        </label><br>
                        <label>Sample Size: <input type="number" id="quality-sample" value="10000" min="1000" max="100000" step="1000"></label><br>
                        <label>Data Collection Period (months): <input type="number" id="quality-period" value="24" min="6" max="60" step="6"></label><br>
                        <label>Quality Issues Present: 
                            <select id="quality-issues" multiple>
                                <option value="missing">Missing Data</option>
                                <option value="outliers">Outliers</option>
                                <option value="duplicates">Duplicates</option>
                                <option value="inconsistent">Inconsistent Coding</option>
                            </select>
                        </label><br>
                        <button onclick="assessDataQuality()">Assess Data Quality</button>
                    </div>

                    <div id="quality-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="quality-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 9: Healthcare System Context -->
        <div id="system-section" class="section-content">
            <div class="section">
                <h2>üè• Canadian Healthcare System Structure & Metrics</h2>
                
                <div class="concept">
                    <h3>Understanding Healthcare Delivery and Performance Measurement</h3>
                    
                    <div class="definition-box">
                        <h4>System Structure:</h4>
                        <p><strong>Federal Role:</strong> Canada Health Act, transfer payments, health protection</p>
                        <p><strong>Provincial Role:</strong> Healthcare delivery, physician billing, hospital administration</p>
                        <p><strong>Regional Health Authorities:</strong> Local service delivery and coordination</p>
                        <p><strong>Primary Care:</strong> Family physicians, nurse practitioners, community health centers</p>
                    </div>

                    <div class="canadian-context">
                        <h4>Key Performance Indicators:</h4>
                        <p><strong>Access:</strong> Wait times, emergency department visits, specialist referrals</p>
                        <p><strong>Quality:</strong> Patient safety indicators, clinical outcomes, patient experience</p>
                        <p><strong>Efficiency:</strong> Length of stay, readmission rates, resource utilization</p>
                        <p><strong>Equity:</strong> Health disparities, Indigenous health, rural/remote access</p>
                    </div>

                    <div class="controls">
                        <h4>Healthcare Performance Dashboard</h4>
                        <label>Region: 
                            <select id="health-region">
                                <option value="toronto">Toronto Central LHIN</option>
                                <option value="vancouver">Vancouver Coastal Health</option>
                                <option value="montreal">CISSS Montr√©al</option>
                                <option value="calgary">Alberta Health Services - Calgary</option>
                            </select>
                        </label><br>
                        <label>Performance Metric: 
                            <select id="performance-metric">
                                <option value="wait-times">Surgical Wait Times</option>
                                <option value="ed-visits">Emergency Department Visits</option>
                                <option value="readmissions">Hospital Readmissions</option>
                                <option value="patient-experience">Patient Experience Scores</option>
                            </select>
                        </label><br>
                        <label>Reporting Year: <input type="number" id="reporting-year" value="2023" min="2019" max="2024" step="1"></label><br>
                        <button onclick="generatePerformanceDashboard()">Generate Performance Report</button>
                    </div>

                    <div id="system-results" class="results" style="display:none;">
                        <!-- Results will be populated by JavaScript -->
                    </div>

                    <div class="chart-container">
                        <canvas id="system-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Assessment Section -->
        <div id="assessment-section" class="section-content">
            <div class="assessment">
                <h2>üß† Foundation Assessment: Descriptive Medical Statistics</h2>
                <p>Test your understanding of foundational concepts in medical statistics. Questions rotate each session.</p>
                <button onclick="generateFoundationQuestions()">Generate New Questions</button>
                
                <div id="foundation-questions-container">
                    <!-- Questions will be populated by JavaScript -->
                </div>
                
                <button onclick="checkFoundationAnswers()" id="foundation-check-btn" style="display:none;">Check Answers</button>
                <div id="foundation-assessment-results"></div>
            </div>
        </div>
    </div>

    <script>
        let currentFoundationQuestions = [];
        let charts = {};
        
        // Navigation functionality
        function showSection(sectionName) {
            // Hide all sections
            const sections = document.querySelectorAll('.section-content');
            sections.forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section
            const selectedSection = document.getElementById(sectionName + '-section');
            if (selectedSection) {
                selectedSection.classList.add('active');
            }
        }

        // Update variation display
        document.getElementById('center-variation').addEventListener('input', function() {
            document.getElementById('variation-display').textContent = Math.round(this.value * 100) + '%';
        });

        document.getElementById('viz-variation').addEventListener('input', function() {
            document.getElementById('viz-variation-display').textContent = Math.round(this.value * 100) + '%';
        });

        // Section 1: Calculate Different Means
        function calculateMeans() {
            const numCenters = parseInt(document.getElementById('num-centers').value);
            const baseResponse = parseFloat(document.getElementById('base-response').value);
            const variation = parseFloat(document.getElementById('center-variation').value);

            // Simulate multi-center trial data
            const centers = [];
            let totalPatients = 0;
            let totalResponses = 0;

            for (let i = 1; i <= numCenters; i++) {
                const patients = Math.floor(Math.random() * 100) + 50; // 50-150 patients
                const centerEffect = (Math.random() - 0.5) * variation * 2 * baseResponse;
                const responseRate = Math.max(0.1, Math.min(0.95, (baseResponse + centerEffect) / 100));
                const responses = Math.floor(patients * responseRate);
                
                centers.push({
                    id: i,
                    patients: patients,
                    responses: responses,
                    rate: responseRate * 100,
                    weight: patients // Sample size as weight
                });
                
                totalPatients += patients;
                totalResponses += responses;
            }

            // Calculate different means
            const arithmeticMean = centers.reduce((sum, c) => sum + c.rate, 0) / numCenters;
            
            const weightedMean = centers.reduce((sum, c) => sum + (c.weight * c.rate), 0) / 
                               centers.reduce((sum, c) => sum + c.weight, 0);
            
            // For geometric mean, add small constant to handle any zero values
            const geometricMean = Math.exp(centers.reduce((sum, c) => sum + Math.log(c.rate + 0.1), 0) / numCenters) - 0.1;
            
            // Overall response rate for comparison
            const overallRate = (totalResponses / totalPatients) * 100;

            document.getElementById('means-results').style.display = 'block';
            document.getElementById('means-results').innerHTML = `
                <h4>Multi-Center Drug Trial Analysis</h4>
                <table>
                    <tr><th>Center</th><th>Patients</th><th>Responses</th><th>Response Rate (%)</th><th>Weight</th></tr>
                    ${centers.map(c => `
                        <tr>
                            <td>Center ${c.id}</td>
                            <td>${c.patients}</td>
                            <td>${c.responses}</td>
                            <td>${c.rate.toFixed(1)}</td>
                            <td>${c.weight}</td>
                        </tr>
                    `).join('')}
                </table>
                
                <h4>Comparison of Mean Calculations</h4>
                <table>
                    <tr><th>Mean Type</th><th>Value (%)</th><th>Interpretation</th></tr>
                    <tr><td>Arithmetic Mean</td><td>${arithmeticMean.toFixed(2)}</td><td>Equal weight to each center</td></tr>
                    <tr style="background-color: #e8ffe8;"><td>Weighted Mean</td><td>${weightedMean.toFixed(2)}</td><td>Weighted by sample size (preferred)</td></tr>
                    <tr><td>Geometric Mean</td><td>${geometricMean.toFixed(2)}</td><td>Multiplicative average</td></tr>
                    <tr><td>Overall Rate</td><td>${overallRate.toFixed(2)}</td><td>Pooled analysis</td></tr>
                </table>
                
                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Weighted mean (${weightedMean.toFixed(1)}%) is most appropriate</span> for regulatory submission</p>
                <p>‚Ä¢ Difference between arithmetic and weighted: ${Math.abs(arithmeticMean - weightedMean).toFixed(1)}%</p>
                <p>‚Ä¢ ${arithmeticMean > weightedMean ? 'Larger' : 'Smaller'} centers had ${arithmeticMean > weightedMean ? 'lower' : 'higher'} response rates</p>
            `;

            createMeansChart(centers, arithmeticMean, weightedMean, geometricMean);
        }

        function createMeansChart(centers, arithmetic, weighted, geometric) {
            const ctx = document.getElementById('means-chart').getContext('2d');
            
            if (charts.means) charts.means.destroy();

            const centerLabels = centers.map(c => `Center ${c.id}`);
            const centerRates = centers.map(c => c.rate);
            const centerSizes = centers.map(c => c.patients);

            charts.means = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: centerLabels,
                    datasets: [{
                        label: 'Response Rate (%)',
                        data: centerRates,
                        backgroundColor: centerRates.map((rate, i) => {
                            const intensity = Math.min(255, Math.max(100, centerSizes[i] * 2));
                            return `rgba(47, 139, 139, ${intensity / 255})`;
                        }),
                        borderColor: '#2f8b8b',
                        borderWidth: 2
                    }, {
                        label: 'Arithmetic Mean',
                        data: Array(centers.length).fill(arithmetic),
                        type: 'line',
                        borderColor: '#ff6b6b',
                        borderWidth: 3,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'Weighted Mean',
                        data: Array(centers.length).fill(weighted),
                        type: 'line',
                        borderColor: '#dc143c',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Multi-Center Trial: Response Rates and Different Means'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Research Centers'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Response Rate (%)'
                            },
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        // Section 2: Missing Data Simulation
        function simulateMissingData() {
            const totalPatients = parseInt(document.getElementById('total-patients').value);
            const mechanism = document.getElementById('missing-mechanism').value;
            const missingRate = parseFloat(document.getElementById('missing-rate').value) / 100;

            // Generate patient data
            const patients = [];
            for (let i = 1; i <= totalPatients; i++) {
                const age = Math.floor(Math.random() * 60) + 20; // 20-80 years
                const severity = Math.random(); // 0-1, higher = sicker
                const outcome = 50 + age * 0.3 + severity * 20 + Math.random() * 15; // Health score
                
                let missing = false;
                
                // Determine missingness based on mechanism
                switch (mechanism) {
                    case 'MCAR':
                        missing = Math.random() < missingRate;
                        break;
                    case 'MAR':
                        // Older patients more likely to miss
                        const ageEffect = (age - 20) / 60; // 0-1
                        missing = Math.random() < (missingRate * 0.5 + ageEffect * missingRate);
                        break;
                    case 'NMAR':
                        // Sicker patients more likely to miss
                        missing = Math.random() < (missingRate * 0.3 + severity * missingRate * 1.5);
                        break;
                }
                
                patients.push({
                    id: i,
                    age: age,
                    severity: severity,
                    outcome: missing ? null : outcome,
                    missing: missing
                });
            }

            // Calculate statistics
            const observedPatients = patients.filter(p => !p.missing);
            const actualMissingRate = patients.filter(p => p.missing).length / totalPatients;
            
            const meanAge = patients.reduce((sum, p) => sum + p.age, 0) / totalPatients;
            const meanAgeObserved = observedPatients.reduce((sum, p) => sum + p.age, 0) / observedPatients.length;
            
            const meanOutcome = observedPatients.reduce((sum, p) => sum + p.outcome, 0) / observedPatients.length;
            
            // Age group analysis
            const ageGroups = [
                { name: '20-39', min: 20, max: 39 },
                { name: '40-59', min: 40, max: 59 },
                { name: '60+', min: 60, max: 80 }
            ];
            
            const ageGroupStats = ageGroups.map(group => {
                const groupPatients = patients.filter(p => p.age >= group.min && p.age <= group.max);
                const groupMissing = groupPatients.filter(p => p.missing).length;
                return {
                    name: group.name,
                    total: groupPatients.length,
                    missing: groupMissing,
                    rate: groupPatients.length > 0 ? groupMissing / groupPatients.length : 0
                };
            });

            document.getElementById('missing-results').style.display = 'block';
            document.getElementById('missing-results').innerHTML = `
                <h4>Missing Data Analysis: ${mechanism} Mechanism</h4>
                <p><strong>Overall Statistics:</strong></p>
                <p>‚Ä¢ Total patients: ${totalPatients}</p>
                <p>‚Ä¢ Missing outcome data: ${patients.filter(p => p.missing).length} (${(actualMissingRate*100).toFixed(1)}%)</p>
                <p>‚Ä¢ Complete cases: ${observedPatients.length}</p>
                
                <p><strong>Bias Assessment:</strong></p>
                <p>‚Ä¢ Mean age (full sample): ${meanAge.toFixed(1)} years</p>
                <p>‚Ä¢ Mean age (observed only): ${meanAgeObserved.toFixed(1)} years</p>
                <p>‚Ä¢ Age bias: ${(meanAgeObserved - meanAge).toFixed(1)} years</p>
                <p>‚Ä¢ Mean health score (observed): ${meanOutcome.toFixed(1)}</p>
                
                <table>
                    <tr><th>Age Group</th><th>Total</th><th>Missing</th><th>Missing Rate (%)</th></tr>
                    ${ageGroupStats.map(group => `
                        <tr style="background-color: ${group.rate > actualMissingRate * 1.2 ? '#ffe8e8' : '#f8f8f8'}">
                            <td>${group.name}</td>
                            <td>${group.total}</td>
                            <td>${group.missing}</td>
                            <td>${(group.rate*100).toFixed(1)}</td>
                        </tr>
                    `).join('')}
                </table>
                
                <p><strong>Clinical Implications:</strong></p>
                <p>‚Ä¢ <span class="highlight">Missing mechanism: ${mechanism}</span></p>
                <p>‚Ä¢ Bias severity: ${Math.abs(meanAgeObserved - meanAge) > 2 ? 'High - consider imputation' : 'Low - complete case analysis acceptable'}</p>
                <p>‚Ä¢ Recommended approach: ${getMissingDataRecommendation(mechanism, actualMissingRate)}</p>
            `;

            createMissingDataChart(ageGroupStats, mechanism);
        }

        function getMissingDataRecommendation(mechanism, rate) {
            if (mechanism === 'MCAR') {
                return rate < 0.05 ? 'Complete case analysis' : 'Multiple imputation for efficiency';
            } else if (mechanism === 'MAR') {
                return 'Multiple imputation including age and other predictors';
            } else {
                return 'Pattern-mixture models or sensitivity analysis needed';
            }
        }

        function createMissingDataChart(ageGroupStats, mechanism) {
            const ctx = document.getElementById('missing-chart').getContext('2d');
            
            if (charts.missing) charts.missing.destroy();

            charts.missing = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ageGroupStats.map(g => g.name),
                    datasets: [{
                        label: 'Total Patients',
                        data: ageGroupStats.map(g => g.total),
                        backgroundColor: 'rgba(47, 139, 139, 0.3)',
                        borderColor: '#2f8b8b',
                        borderWidth: 2
                    }, {
                        label: 'Missing Data',
                        data: ageGroupStats.map(g => g.missing),
                        backgroundColor: 'rgba(220, 20, 60, 0.7)',
                        borderColor: '#dc143c',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Missing Data Pattern: ${mechanism} Mechanism`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Age Groups'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Number of Patients'
                            }
                        }
                    }
                }
            });
        }

        // Section 3: Calculate Epidemiological Rates
        function calculateRates() {
            const popA = parseInt(document.getElementById('pop-a').value);
            const popB = parseInt(document.getElementById('pop-b').value);
            const disease = document.getElementById('disease-type').value;
            const timePeriod = parseFloat(document.getElementById('time-period').value);

            // Disease-specific parameters
            const diseaseParams = {
                diabetes: { baseIncidence: 0.008, baseMortality: 0.0001, caseFatality: 0.05 },
                covid: { baseIncidence: 0.15, baseMortality: 0.001, caseFatality: 0.02 },
                heart: { baseIncidence: 0.012, baseMortality: 0.002, caseFatality: 0.15 },
                cancer: { baseIncidence: 0.006, baseMortality: 0.0015, caseFatality: 0.25 }
            };

            const params = diseaseParams[disease];
            
            // Add some random variation between provinces
            const variationA = 0.8 + Math.random() * 0.4; // 0.8-1.2
            const variationB = 0.8 + Math.random() * 0.4;

            // Calculate rates for Province A
            const incidenceA = params.baseIncidence * variationA * timePeriod;
            const newCasesA = Math.round(popA * incidenceA);
            const prevalenceA = incidenceA * 5; // Assume 5-year duration
            const existingCasesA = Math.round(popA * prevalenceA);
            const mortalityA = params.baseMortality * variationA * timePeriod;
            const deathsA = Math.round(popA * mortalityA);
            const caseFatalityA = params.caseFatality * (0.8 + Math.random() * 0.4);

            // Calculate rates for Province B
            const incidenceB = params.baseIncidence * variationB * timePeriod;
            const newCasesB = Math.round(popB * incidenceB);
            const prevalenceB = incidenceB * 5;
            const existingCasesB = Math.round(popB * prevalenceB);
            const mortalityB = params.baseMortality * variationB * timePeriod;
            const deathsB = Math.round(popB * mortalityB);
            const caseFatalityB = params.caseFatality * (0.8 + Math.random() * 0.4);

            // Calculate relative risk
            const relativeRisk = incidenceA / incidenceB;

            document.getElementById('rates-results').style.display = 'block';
            document.getElementById('rates-results').innerHTML = `
                <h4>Epidemiological Analysis: ${disease.charAt(0).toUpperCase() + disease.slice(1)} in Canadian Provinces</h4>
                
                <table>
                    <tr><th>Measure</th><th>Province A</th><th>Province B</th><th>Relative Risk</th></tr>
                    <tr>
                        <td>Population</td>
                        <td>${popA.toLocaleString()}</td>
                        <td>${popB.toLocaleString()}</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>New Cases (${timePeriod} year${timePeriod > 1 ? 's' : ''})</td>
                        <td>${newCasesA.toLocaleString()}</td>
                        <td>${newCasesB.toLocaleString()}</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>Incidence Rate (per 1,000/year)</td>
                        <td>${(incidenceA * 1000 / timePeriod).toFixed(2)}</td>
                        <td>${(incidenceB * 1000 / timePeriod).toFixed(2)}</td>
                        <td>${relativeRisk.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Prevalence (per 1,000)</td>
                        <td>${(prevalenceA * 1000).toFixed(2)}</td>
                        <td>${(prevalenceB * 1000).toFixed(2)}</td>
                        <td>${(prevalenceA / prevalenceB).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Mortality Rate (per 100,000/year)</td>
                        <td>${(mortalityA * 100000 / timePeriod).toFixed(2)}</td>
                        <td>${(mortalityB * 100000 / timePeriod).toFixed(2)}</td>
                        <td>${(mortalityA / mortalityB).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Case Fatality Rate (%)</td>
                        <td>${(caseFatalityA * 100).toFixed(1)}</td>
                        <td>${(caseFatalityB * 100).toFixed(1)}</td>
                        <td>${(caseFatalityA / caseFatalityB).toFixed(2)}</td>
                    </tr>
                </table>
                
                <p><strong>Public Health Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Province A has ${relativeRisk > 1 ? 'higher' : 'lower'} incidence (RR=${relativeRisk.toFixed(2)})</span></p>
                <p>‚Ä¢ Risk difference: ${Math.abs((incidenceA - incidenceB) * 1000).toFixed(2)} cases per 1,000 population</p>
                <p>‚Ä¢ Attributable risk %: ${((relativeRisk - 1) / relativeRisk * 100).toFixed(1)}%</p>
                <p>‚Ä¢ Public health priority: ${relativeRisk > 1.5 ? 'High - investigate risk factors in Province A' : 'Moderate - monitor trends'}</p>
            `;

            createRatesChart(incidenceA, incidenceB, mortalityA, mortalityB, disease);
        }

        function createRatesChart(incA, incB, mortA, mortB, disease) {
            const ctx = document.getElementById('rates-chart').getContext('2d');
            
            if (charts.rates) charts.rates.destroy();

            charts.rates = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Incidence Rate', 'Mortality Rate'],
                    datasets: [{
                        label: 'Province A',
                        data: [incA * 1000, mortA * 100000],
                        backgroundColor: 'rgba(47, 139, 139, 0.8)',
                        borderColor: '#2f8b8b',
                        borderWidth: 2
                    }, {
                        label: 'Province B',
                        data: [incB * 1000, mortB * 100000],
                        backgroundColor: 'rgba(220, 20, 60, 0.8)',
                        borderColor: '#dc143c',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${disease.charAt(0).toUpperCase() + disease.slice(1)} Rates: Provincial Comparison`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Rate Type'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Rate (per 1,000 for incidence, per 100,000 for mortality)'
                            }
                        }
                    }
                }
            });
        }

        // Section 4: Age Standardization
        function calculateStandardization() {
            const standardPop = document.getElementById('standard-pop').value;
            const disease = document.getElementById('disease-focus').value;
            const year = parseInt(document.getElementById('study-year').value);

            // Standard population weights (simplified)
            const ageGroups = ['0-19', '20-39', '40-59', '60-79', '80+'];
            const standardWeights = standardPop === 'canada' 
                ? [0.20, 0.25, 0.25, 0.20, 0.10]  // Canada 2021
                : [0.35, 0.25, 0.20, 0.15, 0.05]; // WHO standard

            // Disease-specific age-specific rates (per 100,000)
            const diseaseRates = {
                cardiovascular: [2, 15, 85, 400, 1200],
                cancer: [5, 25, 150, 600, 1000],
                respiratory: [10, 8, 30, 200, 800]
            };

            const baseRates = diseaseRates[disease];

            // Simulate Alberta and Nova Scotia data
            const albertaRates = baseRates.map(rate => rate * (0.8 + Math.random() * 0.4));
            const novaScotiaRates = baseRates.map(rate => rate * (0.8 + Math.random() * 0.4));

            // Population structures (proportions in each age group)
            const albertaPop = [0.22, 0.28, 0.26, 0.18, 0.06]; // Younger population
            const novaScotiaPop = [0.16, 0.22, 0.24, 0.24, 0.14]; // Older population

            // Calculate crude rates
            const crudeAlberta = ageGroups.reduce((sum, group, i) => 
                sum + albertaRates[i] * albertaPop[i], 0);
            const crudeNovaScotia = ageGroups.reduce((sum, group, i) => 
                sum + novaScotiaRates[i] * novaScotiaPop[i], 0);

            // Calculate age-standardized rates
            const asr_Alberta = ageGroups.reduce((sum, group, i) => 
                sum + albertaRates[i] * standardWeights[i], 0);
            const asr_NovaScotia = ageGroups.reduce((sum, group, i) => 
                sum + novaScotiaRates[i] * standardWeights[i], 0);

            // Calculate SMRs (using Alberta as standard)
            const expectedAlberta = ageGroups.reduce((sum, group, i) => 
                sum + albertaRates[i] * novaScotiaPop[i], 0);
            const smr_NovaScotia = (crudeNovaScotia / expectedAlberta) * 100;

            document.getElementById('standardization-results').style.display = 'block';
            document.getElementById('standardization-results').innerHTML = `
                <h4>Age Standardization: ${disease.charAt(0).toUpperCase() + disease.slice(1)} Mortality, ${year}</h4>
                
                <p><strong>Population Age Structures:</strong></p>
                <table>
                    <tr><th>Age Group</th><th>Alberta (%)</th><th>Nova Scotia (%)</th><th>Standard (%)</th></tr>
                    ${ageGroups.map((group, i) => `
                        <tr>
                            <td>${group}</td>
                            <td>${(albertaPop[i] * 100).toFixed(1)}</td>
                            <td>${(novaScotiaPop[i] * 100).toFixed(1)}</td>
                            <td>${(standardWeights[i] * 100).toFixed(1)}</td>
                        </tr>
                    `).join('')}
                </table>

                <p><strong>Age-Specific Rates (per 100,000):</strong></p>
                <table>
                    <tr><th>Age Group</th><th>Alberta</th><th>Nova Scotia</th></tr>
                    ${ageGroups.map((group, i) => `
                        <tr>
                            <td>${group}</td>
                            <td>${albertaRates[i].toFixed(1)}</td>
                            <td>${novaScotiaRates[i].toFixed(1)}</td>
                        </tr>
                    `).join('')}
                </table>

                <p><strong>Standardized Rate Comparison:</strong></p>
                <table>
                    <tr><th>Rate Type</th><th>Alberta</th><th>Nova Scotia</th><th>Ratio</th></tr>
                    <tr>
                        <td>Crude Rate</td>
                        <td>${crudeAlberta.toFixed(1)}</td>
                        <td>${crudeNovaScotia.toFixed(1)}</td>
                        <td>${(crudeNovaScotia/crudeAlberta).toFixed(2)}</td>
                    </tr>
                    <tr style="background-color: #e8ffe8;">
                        <td>Age-Standardized Rate</td>
                        <td>${asr_Alberta.toFixed(1)}</td>
                        <td>${asr_NovaScotia.toFixed(1)}</td>
                        <td>${(asr_NovaScotia/asr_Alberta).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>SMR (Alberta = 100)</td>
                        <td>100.0</td>
                        <td>${smr_NovaScotia.toFixed(1)}</td>
                        <td>${(smr_NovaScotia/100).toFixed(2)}</td>
                    </tr>
                </table>

                <p><strong>Public Health Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Age-standardized rates provide fair comparison</span></p>
                <p>‚Ä¢ Crude rate difference: ${Math.abs(crudeNovaScotia - crudeAlberta).toFixed(1)} per 100,000</p>
                <p>‚Ä¢ Age-standardized difference: ${Math.abs(asr_NovaScotia - asr_Alberta).toFixed(1)} per 100,000</p>
                <p>‚Ä¢ Age structure ${Math.abs(crudeNovaScotia/crudeAlberta - asr_NovaScotia/asr_Alberta) > 0.1 ? 'significantly' : 'minimally'} affects comparison</p>
            `;

            createStandardizationChart(ageGroups, albertaRates, novaScotiaRates, albertaPop, novaScotiaPop);
        }

        function createStandardizationChart(ageGroups, albertaRates, nsRates, albertaPop, nsPop) {
            const ctx = document.getElementById('standardization-chart').getContext('2d');
            
            if (charts.standardization) charts.standardization.destroy();

            charts.standardization = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ageGroups,
                    datasets: [{
                        label: 'Alberta Mortality Rate',
                        data: albertaRates,
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.1)',
                        borderWidth: 3,
                        pointRadius: 6,
                        yAxisID: 'y'
                    }, {
                        label: 'Nova Scotia Mortality Rate',
                        data: nsRates,
                        borderColor: '#dc143c',
                        backgroundColor: 'rgba(220, 20, 60, 0.1)',
                        borderWidth: 3,
                        pointRadius: 6,
                        yAxisID: 'y'
                    }, {
                        label: 'Alberta Population %',
                        data: albertaPop.map(p => p * 100),
                        borderColor: '#20b2aa',
                        backgroundColor: 'rgba(32, 178, 170, 0.3)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 4,
                        yAxisID: 'y1',
                        fill: false
                    }, {
                        label: 'Nova Scotia Population %',
                        data: nsPop.map(p => p * 100),
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.3)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 4,
                        yAxisID: 'y1',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Age-Specific Rates and Population Structures'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Age Groups'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Mortality Rate (per 100,000)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Population Proportion (%)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });
        }

        // Section 5: Confidence Intervals
        function calculateConfidenceIntervals() {
            const n = parseInt(document.getElementById('ci-sample-size').value);
            const effect = parseFloat(document.getElementById('ci-effect').value);
            const sd = parseFloat(document.getElementById('ci-sd').value);
            const level = parseInt(document.getElementById('ci-level').value);

            // Generate sample data
            const controlGroup = [];
            const treatmentGroup = [];
            
            for (let i = 0; i < n; i++) {
                controlGroup.push(140 + Math.random() * sd);
                treatmentGroup.push(140 - effect + Math.random() * sd);
            }

            // Calculate statistics
            const controlMean = controlGroup.reduce((a, b) => a + b) / n;
            const treatmentMean = treatmentGroup.reduce((a, b) => a + b) / n;
            const observedEffect = controlMean - treatmentMean;

            // Pooled standard deviation
            const controlSS = controlGroup.reduce((sum, x) => sum + Math.pow(x - controlMean, 2), 0);
            const treatmentSS = treatmentGroup.reduce((sum, x) => sum + Math.pow(x - treatmentMean, 2), 0);
            const pooledSD = Math.sqrt((controlSS + treatmentSS) / (2 * n - 2));
            
            // Standard error for difference
            const se = pooledSD * Math.sqrt(2 / n);
            
            // Critical values
            const criticalValues = { 90: 1.645, 95: 1.96, 99: 2.576 };
            const criticalValue = criticalValues[level];
            
            // Confidence intervals
            const marginError = criticalValue * se;
            const ciLower = observedEffect - marginError;
            const ciUpper = observedEffect + marginError;
            
            // Individual group CIs
            const seMean = pooledSD / Math.sqrt(n);
            const controlCILower = controlMean - criticalValue * seMean;
            const controlCIUpper = controlMean + criticalValue * seMean;
            const treatmentCILower = treatmentMean - criticalValue * seMean;
            const treatmentCIUpper = treatmentMean + criticalValue * seMean;

            // Clinical significance
            const clinicallySignificant = Math.abs(observedEffect) >= 5; // 5 mmHg threshold
            const statisticallySignificant = ciLower > 0 || ciUpper < 0;

            document.getElementById('confidence-results').style.display = 'block';
            document.getElementById('confidence-results').innerHTML = `
                <h4>Confidence Interval Analysis: Blood Pressure Clinical Trial</h4>
                
                <p><strong>Study Results:</strong></p>
                <table>
                    <tr><th>Group</th><th>N</th><th>Mean (mmHg)</th><th>${level}% CI</th></tr>
                    <tr>
                        <td>Control</td>
                        <td>${n}</td>
                        <td>${controlMean.toFixed(1)}</td>
                        <td>[${controlCILower.toFixed(1)}, ${controlCIUpper.toFixed(1)}]</td>
                    </tr>
                    <tr>
                        <td>Treatment</td>
                        <td>${n}</td>
                        <td>${treatmentMean.toFixed(1)}</td>
                        <td>[${treatmentCILower.toFixed(1)}, ${treatmentCIUpper.toFixed(1)}]</td>
                    </tr>
                </table>

                <p><strong>Treatment Effect Analysis:</strong></p>
                <p>‚Ä¢ Observed difference: ${observedEffect.toFixed(2)} mmHg</p>
                <p>‚Ä¢ Standard error: ${se.toFixed(3)} mmHg</p>
                <p>‚Ä¢ ${level}% Confidence Interval: [${ciLower.toFixed(2)}, ${ciUpper.toFixed(2)}] mmHg</p>
                <p>‚Ä¢ Margin of error: ¬±${marginError.toFixed(2)} mmHg</p>

                <p><strong>Clinical Interpretation:</strong></p>
                <p>‚Ä¢ <span class="highlight">Statistical significance: ${statisticallySignificant ? 'Yes' : 'No'}</span> (CI ${statisticallySignificant ? 'excludes' : 'includes'} 0)</p>
                <p>‚Ä¢ Clinical significance: ${clinicallySignificant ? 'Yes' : 'No'} (threshold: 5 mmHg reduction)</p>
                <p>‚Ä¢ Precision: ${marginError < 3 ? 'High' : marginError < 6 ? 'Moderate' : 'Low'} (margin of error ${marginError.toFixed(1)} mmHg)</p>
                <p>‚Ä¢ Regulatory decision: ${statisticallySignificant && clinicallySignificant ? 'Recommend approval' : 'Insufficient evidence'}</p>

                <p><strong>Sample Size Considerations:</strong></p>
                <p>‚Ä¢ Current power: ~${calculatePower(observedEffect, se).toFixed(0)}%</p>
                <p>‚Ä¢ For 90% power: ~${calculateRequiredN(effect, sd).toFixed(0)} patients per group needed</p>
            `;

            createConfidenceChart(controlMean, treatmentMean, ciLower, ciUpper, level);
        }

        function calculatePower(effect, se) {
            const z = Math.abs(effect) / se;
            return (1 - normalCDF(1.96 - z) + normalCDF(-1.96 - z)) * 100;
        }

        function calculateRequiredN(effect, sd) {
            const power = 0.9;
            const alpha = 0.05;
            const zAlpha = 1.96;
            const zBeta = 1.282; // For 90% power
            return Math.pow((zAlpha + zBeta) * sd / effect, 2) * 2;
        }

        function normalCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function erf(x) {
            const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
            const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        function createConfidenceChart(controlMean, treatmentMean, ciLower, ciUpper, level) {
            const ctx = document.getElementById('confidence-chart').getContext('2d');
            
            if (charts.confidence) charts.confidence.destroy();

            const observedEffect = controlMean - treatmentMean;
            
            charts.confidence = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Treatment Effect Estimate',
                        data: [{x: 1, y: observedEffect}],
                        backgroundColor: '#2f8b8b',
                        borderColor: '#2f8b8b',
                        pointRadius: 8,
                        pointStyle: 'circle'
                    }, {
                        label: `${level}% Confidence Interval`,
                        data: [{x: 1, y: ciLower}, {x: 1, y: ciUpper}],
                        backgroundColor: 'transparent',
                        borderColor: '#dc143c',
                        showLine: true,
                        borderWidth: 4,
                        pointRadius: 6,
                        pointStyle: 'line'
                    }, {
                        label: 'No Effect (Null)',
                        data: [{x: 0.5, y: 0}, {x: 1.5, y: 0}],
                        backgroundColor: 'transparent',
                        borderColor: '#666',
                        showLine: true,
                        borderWidth: 2,
                        borderDash: [10, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Treatment Effect with ${level}% Confidence Interval`
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Study'
                            },
                            min: 0.5,
                            max: 1.5,
                            ticks: {
                                display: false
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Blood Pressure Reduction (mmHg)'
                            }
                        }
                    }
                }
            });
        }

        // Section 6: Data Sources and Linkage
        function simulateDataLinkage() {
            const question = document.getElementById('research-question').value;
            const province = document.getElementById('province').value;
            const period = parseInt(document.getElementById('study-period').value);

            // Define data sources by province and research question
            const provincialSources = {
                ontario: {
                    primary: 'OHIP',
                    hospital: 'DAD/CIHI',
                    emergency: 'NACRS',
                    pharmacy: 'Ontario Drug Benefit',
                    specialty: 'ICES'
                },
                quebec: {
                    primary: 'RAMQ',
                    hospital: 'MED-ECHO',
                    emergency: 'NACRS',
                    pharmacy: 'RAMQ Pharmacy',
                    specialty: 'INSPQ'
                },
                bc: {
                    primary: 'MSP',
                    hospital: 'DAD',
                    emergency: 'NACRS',
                    pharmacy: 'PharmaNet',
                    specialty: 'Population Data BC'
                },
                alberta: {
                    primary: 'AHCIP',
                    hospital: 'Alberta Health',
                    emergency: 'NACRS',
                    pharmacy: 'PIN Database',
                    specialty: 'Alberta Health'
                }
            };

            const researchQuestions = {
                diabetes: {
                    title: 'Diabetes Care Across Primary/Secondary Care',
                    sources: ['primary', 'hospital', 'pharmacy', 'specialty'],
                    linkageKey: 'Provincial Health Number',
                    challenges: ['Coding variations', 'Care setting transitions', 'Medication adherence tracking']
                },
                'mental-health': {
                    title: 'Mental Health Service Utilization',
                    sources: ['primary', 'hospital', 'emergency', 'specialty'],
                    linkageKey: 'Provincial Health Number',
                    challenges: ['Stigma effects on recording', 'Private practice gaps', 'Crisis vs routine care']
                },
                cancer: {
                    title: 'Cancer Screening to Treatment Pathway',
                    sources: ['primary', 'hospital', 'specialty'],
                    linkageKey: 'Provincial Health Number + Cancer Registry',
                    challenges: ['Multiple providers', 'Out-of-province treatment', 'Long follow-up periods']
                },
                covid: {
                    title: 'COVID-19 Vaccination Effectiveness',
                    sources: ['primary', 'hospital', 'emergency', 'specialty'],
                    linkageKey: 'Provincial Health Number + Immunization Registry',
                    challenges: ['Rapid policy changes', 'Testing availability', 'Variant effects']
                }
            };

            const currentQuestion = researchQuestions[question];
            const currentProvince = provincialSources[province];
            
            // Simulate linkage statistics
            const basePopulation = province === 'ontario' ? 15000000 : 
                                 province === 'quebec' ? 8500000 :
                                 province === 'bc' ? 5200000 : 4500000;
            
            const eligibleCohort = Math.floor(basePopulation * (0.6 + Math.random() * 0.3));
            const linkageSuccess = 0.85 + Math.random() * 0.12; // 85-97%
            const finalCohort = Math.floor(eligibleCohort * linkageSuccess);
            
            // Data quality metrics
            const completeness = currentQuestion.sources.map(() => 0.88 + Math.random() * 0.10);
            const accuracy = currentQuestion.sources.map(() => 0.92 + Math.random() * 0.06);

            document.getElementById('data-sources-results').style.display = 'block';
            document.getElementById('data-sources-results').innerHTML = `
                <h4>Data Linkage Strategy: ${currentQuestion.title}</h4>
                <h5>Province: ${province.charAt(0).toUpperCase() + province.slice(1)}</h5>
                
                <p><strong>Required Data Sources:</strong></p>
                <table>
                    <tr><th>Data Type</th><th>Provincial Source</th><th>Completeness</th><th>Accuracy</th></tr>
                    ${currentQuestion.sources.map((source, i) => `
                        <tr>
                            <td>${source.charAt(0).toUpperCase() + source.slice(1).replace('-', ' ')}</td>
                            <td>${currentProvince[source]}</td>
                            <td>${(completeness[i] * 100).toFixed(1)}%</td>
                            <td>${(accuracy[i] * 100).toFixed(1)}%</td>
                        </tr>
                    `).join('')}
                </table>

                <p><strong>Linkage Strategy:</strong></p>
                <p>‚Ä¢ Linkage key: ${currentQuestion.linkageKey}</p>
                <p>‚Ä¢ Study population: ${basePopulation.toLocaleString()} (provincial population)</p>
                <p>‚Ä¢ Eligible cohort: ${eligibleCohort.toLocaleString()} (${(eligibleCohort/basePopulation*100).toFixed(1)}%)</p>
                <p>‚Ä¢ Successful linkage: ${finalCohort.toLocaleString()} (${(linkageSuccess*100).toFixed(1)}%)</p>
                <p>‚Ä¢ Study period: ${period} year${period > 1 ? 's' : ''}</p>

                <p><strong>Privacy and Ethics Considerations:</strong></p>
                <p>‚Ä¢ <span class="highlight">Ethics approval required from ${getEthicsBoard(province)}</span></p>
                <p>‚Ä¢ Data custodian agreements: ${currentQuestion.sources.length} required</p>
                <p>‚Ä¢ De-identification: Applied before researcher access</p>
                <p>‚Ä¢ Data security: Certified secure environment required</p>

                <p><strong>Key Challenges:</strong></p>
                ${currentQuestion.challenges.map(challenge => `<p>‚Ä¢ ${challenge}</p>`).join('')}

                <p><strong>Timeline and Resources:</strong></p>
                <p>‚Ä¢ Ethics approval: 3-6 months</p>
                <p>‚Ä¢ Data access agreements: 6-12 months</p>
                <p>‚Ä¢ Data preparation: 2-4 months</p>
                <p>‚Ä¢ Estimated cost: CAD $${(currentQuestion.sources.length * 25000 + Math.random() * 50000).toFixed(0).toLocaleString()}</p>
            `;

            createDataSourcesChart(currentQuestion.sources, completeness, accuracy);
        }

        function getEthicsBoard(province) {
            const boards = {
                ontario: 'Research Ethics Board + ICES Privacy Office',
                quebec: 'Comit√© d\'√©thique + CAI (Commission d\'acc√®s √† l\'information)',
                bc: 'UBC Ethics Board + Population Data BC',
                alberta: 'Alberta Health Ethics + Health Quality Council'
            };
            return boards[province];
        }

        function createDataSourcesChart(sources, completeness, accuracy) {
            const ctx = document.getElementById('data-sources-chart').getContext('2d');
            
            if (charts.dataSources) charts.dataSources.destroy();

            charts.dataSources = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: sources.map(s => s.charAt(0).toUpperCase() + s.slice(1).replace('-', ' ')),
                    datasets: [{
                        label: 'Data Completeness (%)',
                        data: completeness.map(c => c * 100),
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.3)',
                        pointBackgroundColor: '#2f8b8b',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#2f8b8b'
                    }, {
                        label: 'Data Accuracy (%)',
                        data: accuracy.map(a => a * 100),
                        borderColor: '#dc143c',
                        backgroundColor: 'rgba(220, 20, 60, 0.3)',
                        pointBackgroundColor: '#dc143c',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#dc143c'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Data Quality Assessment Across Sources'
                        }
                    },
                    scales: {
                        r: {
                            angleLines: {
                                display: false
                            },
                            suggestedMin: 80,
                            suggestedMax: 100
                        }
                    }
                }
            });
        }

        // Section 7: Medical Visualizations
        function createMedicalVisualization() {
            const dataType = document.getElementById('viz-data-type').value;
            const groups = parseInt(document.getElementById('viz-groups').value);
            const variation = parseFloat(document.getElementById('viz-variation').value);

            document.getElementById('visualizations-results').style.display = 'block';
            
            switch (dataType) {
                case 'meta-analysis':
                    createForestPlot(groups, variation);
                    break;
                case 'survival':
                    createSurvivalCurve(groups, variation);
                    break;
                case 'diagnostic':
                    createROCCurve(groups, variation);
                    break;
                case 'outbreak':
                    createEpiCurve(groups, variation);
                    break;
            }
        }

        function createForestPlot(studies, variation) {
            document.getElementById('visualizations-results').innerHTML = `
                <h4>Forest Plot: Meta-Analysis of Treatment Effectiveness</h4>
                <p>Showing ${studies} studies with effect sizes and 95% confidence intervals</p>
                <p>‚Ä¢ Pooled effect size calculated using random-effects model</p>
                <p>‚Ä¢ Heterogeneity (I¬≤) and overall effect significance assessed</p>
            `;

            const ctx = document.getElementById('visualizations-chart').getContext('2d');
            if (charts.visualizations) charts.visualizations.destroy();

            // Generate study data
            const studyData = [];
            let totalWeight = 0;
            let weightedSum = 0;
            
            for (let i = 1; i <= studies; i++) {
                const effectSize = 0.5 + (Math.random() - 0.5) * variation * 2;
                const se = 0.1 + Math.random() * 0.2;
                const weight = 1 / (se * se);
                const ciLower = effectSize - 1.96 * se;
                const ciUpper = effectSize + 1.96 * se;
                
                studyData.push({
                    study: `Study ${i}`,
                    effect: effectSize,
                    ciLower: ciLower,
                    ciUpper: ciUpper,
                    weight: weight
                });
                
                totalWeight += weight;
                weightedSum += weight * effectSize;
            }
            
            const pooledEffect = weightedSum / totalWeight;
            
            // Create error bar chart
            charts.visualizations = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Effect Size',
                        data: studyData.map((study, i) => ({
                            x: study.effect,
                            y: i + 1
                        })),
                        backgroundColor: '#2f8b8b',
                        borderColor: '#2f8b8b',
                        pointRadius: 6
                    }, {
                        label: 'Pooled Effect',
                        data: [{x: pooledEffect, y: 0}, {x: pooledEffect, y: studies + 1}],
                        type: 'line',
                        borderColor: '#dc143c',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'No Effect',
                        data: [{x: 0, y: 0}, {x: 0, y: studies + 1}],
                        type: 'line',
                        borderColor: '#666',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Forest Plot: Treatment Effect Meta-Analysis'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Effect Size (Risk Ratio)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Studies'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value === 0 || value === studies + 1 ? '' : `Study ${value}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createSurvivalCurve(groups, variation) {
            document.getElementById('visualizations-results').innerHTML = `
                <h4>Kaplan-Meier Survival Curves</h4>
                <p>Comparing ${groups} treatment groups over time</p>
                <p>‚Ä¢ Step function shows probability of survival at each time point</p>
                <p>‚Ä¢ Log-rank test used to compare group differences</p>
            `;

            const ctx = document.getElementById('visualizations-chart').getContext('2d');
            if (charts.visualizations) charts.visualizations.destroy();

            const timePoints = Array.from({length: 61}, (_, i) => i); // 0-60 months
            const colors = ['#2f8b8b', '#dc143c', '#ff6b6b', '#20b2aa', '#ffd93d', '#6a5acd'];
            
            const datasets = [];
            for (let g = 0; g < groups; g++) {
                const survivalData = [];
                let survival = 1.0;
                
                for (let t = 0; t < timePoints.length; t++) {
                    // Simulate hazard with some variation between groups
                    const baseHazard = 0.01 + g * 0.005 + variation * (Math.random() - 0.5) * 0.01;
                    if (t > 0) {
                        survival *= (1 - baseHazard);
                    }
                    survivalData.push(Math.max(0, survival));
                }
                
                datasets.push({
                    label: `Group ${g + 1}`,
                    data: survivalData,
                    borderColor: colors[g % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    stepped: true,
                    pointRadius: 0,
                    fill: false
                });
            }

            charts.visualizations = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timePoints,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Kaplan-Meier Survival Curves'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time (months)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Survival Probability'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        function createROCCurve(tests, variation) {
            document.getElementById('visualizations-results').innerHTML = `
                <h4>ROC Curves for Diagnostic Tests</h4>
                <p>Comparing ${tests} diagnostic tests performance</p>
                <p>‚Ä¢ Area Under Curve (AUC) indicates overall test performance</p>
                <p>‚Ä¢ Diagonal line represents random chance (AUC = 0.5)</p>
            `;

            const ctx = document.getElementById('visualizations-chart').getContext('2d');
            if (charts.visualizations) charts.visualizations.destroy();

            const colors = ['#2f8b8b', '#dc143c', '#ff6b6b', '#20b2aa', '#ffd93d', '#6a5acd'];
            const datasets = [];
            
            // Add diagonal reference line
            datasets.push({
                label: 'Random Chance (AUC=0.5)',
                data: [{x: 0, y: 0}, {x: 1, y: 1}],
                borderColor: '#999',
                borderWidth: 2,
                borderDash: [10, 5],
                pointRadius: 0,
                fill: false
            });
            
            for (let t = 0; t < tests; t++) {
                const rocData = [];
                const baseAUC = 0.7 + Math.random() * 0.25; // 0.7-0.95
                
                // Generate ROC curve points
                for (let i = 0; i <= 100; i++) {
                    const specificity = i / 100;
                    const fpr = 1 - specificity;
                    
                    // Approximate TPR based on desired AUC
                    let tpr = 2 * baseAUC * fpr - fpr * fpr;
                    tpr = Math.max(0, Math.min(1, tpr + (Math.random() - 0.5) * variation * 0.2));
                    
                    rocData.push({x: fpr, y: tpr});
                }
                
                datasets.push({
                    label: `Test ${t + 1} (AUC=${baseAUC.toFixed(2)})`,
                    data: rocData,
                    borderColor: colors[t % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                });
            }

            charts.visualizations = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'ROC Curves: Diagnostic Test Performance'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'False Positive Rate (1 - Specificity)'
                            },
                            min: 0,
                            max: 1
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'True Positive Rate (Sensitivity)'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            });
        }

        function createEpiCurve(weeks, variation) {
            document.getElementById('visualizations-results').innerHTML = `
                <h4>Epidemiological Curve: Disease Outbreak Pattern</h4>
                <p>Showing ${weeks} weeks of outbreak data</p>
                <p>‚Ä¢ Classic epidemic curve showing rise, peak, and decline phases</p>
                <p>‚Ä¢ Pattern analysis helps identify outbreak source and transmission</p>
            `;

            const ctx = document.getElementById('visualizations-chart').getContext('2d');
            if (charts.visualizations) charts.visualizations.destroy();

            const weekLabels = Array.from({length: weeks}, (_, i) => `Week ${i + 1}`);
            const cases = [];
            
            // Generate epidemic curve data
            const peakWeek = Math.floor(weeks * 0.3); // Peak around 30% through outbreak
            
            for (let w = 0; w < weeks; w++) {
                let casesThisWeek;
                
                if (w < peakWeek) {
                    // Rising phase - exponential growth
                    casesThisWeek = 5 * Math.pow(1.4, w) + Math.random() * 10;
                } else if (w === peakWeek) {
                    // Peak
                    casesThisWeek = 5 * Math.pow(1.4, w) + Math.random() * 20;
                } else {
                    // Declining phase - exponential decay
                    const decayFactor = Math.pow(0.8, w - peakWeek);
                    casesThisWeek = 5 * Math.pow(1.4, peakWeek) * decayFactor + Math.random() * 5;
                }
                
                cases.push(Math.max(0, Math.round(casesThisWeek * (1 + variation * (Math.random() - 0.5)))));
            }

            charts.visualizations = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekLabels,
                    datasets: [{
                        label: 'Confirmed Cases',
                        data: cases,
                        backgroundColor: cases.map((caseCount, i) => {
                            if (i < peakWeek) return 'rgba(255, 165, 0, 0.8)'; // Orange for rising
                            if (i === peakWeek) return 'rgba(220, 20, 60, 0.8)'; // Red for peak
                            return 'rgba(47, 139, 139, 0.8)'; // Teal for declining
                        }),
                        borderColor: '#333',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Epidemic Curve: Weekly Case Counts'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Week'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Number of Cases'
                            }
                        }
                    }
                }
            });
        }

        // Section 8: Data Quality Assessment
        function assessDataQuality() {
            const dataset = document.getElementById('quality-dataset').value;
            const sampleSize = parseInt(document.getElementById('quality-sample').value);
            const period = parseInt(document.getElementById('quality-period').value);
            const issuesSelected = Array.from(document.getElementById('quality-issues').selectedOptions).map(option => option.value);

            // Simulate data quality issues based on dataset type and selected issues
            const baseQuality = {
                'ehr': { completeness: 0.92, accuracy: 0.88, consistency: 0.85, timeliness: 0.95 },
                'registry': { completeness: 0.96, accuracy: 0.94, consistency: 0.92, timeliness: 0.85 },
                'survey': { completeness: 0.78, accuracy: 0.85, consistency: 0.90, timeliness: 0.98 },
                'clinical-trial': { completeness: 0.98, accuracy: 0.96, consistency: 0.95, timeliness: 0.92 }
            };

            let quality = { ...baseQuality[dataset] };
            
            // Adjust quality based on issues present
            issuesSelected.forEach(issue => {
                switch (issue) {
                    case 'missing':
                        quality.completeness -= 0.15;
                        break;
                    case 'outliers':
                        quality.accuracy -= 0.10;
                        break;
                    case 'duplicates':
                        quality.consistency -= 0.12;
                        break;
                    case 'inconsistent':
                        quality.consistency -= 0.15;
                        quality.accuracy -= 0.08;
                        break;
                }
            });

            // Ensure quality metrics stay within reasonable bounds
            Object.keys(quality).forEach(key => {
                quality[key] = Math.max(0.5, Math.min(1.0, quality[key]));
            });

            // Calculate overall quality score
            const overallQuality = (quality.completeness + quality.accuracy + quality.consistency + quality.timeliness) / 4;
            
            // Generate specific metrics
            const missingDataRate = (1 - quality.completeness) * 100;
            const errorRate = (1 - quality.accuracy) * 100;
            const duplicateRate = issuesSelected.includes('duplicates') ? 2 + Math.random() * 3 : 0.1 + Math.random() * 0.3;
            const outlierRate = issuesSelected.includes('outliers') ? 3 + Math.random() * 2 : 0.5 + Math.random() * 0.5;

            // Privacy risk assessment
            const reidentificationRisk = dataset === 'clinical-trial' ? 'Low' : 
                                        dataset === 'ehr' ? 'Moderate' :
                                        dataset === 'registry' ? 'Moderate-High' : 'Low-Moderate';

            document.getElementById('quality-results').style.display = 'block';
            document.getElementById('quality-results').innerHTML = `
                <h4>Data Quality Assessment: ${dataset.toUpperCase().replace('-', ' ')}</h4>
                
                <p><strong>Dataset Characteristics:</strong></p>
                <p>‚Ä¢ Sample size: ${sampleSize.toLocaleString()} records</p>
                <p>‚Ä¢ Collection period: ${period} months</p>
                <p>‚Ä¢ Data issues identified: ${issuesSelected.length > 0 ? issuesSelected.join(', ') : 'None selected'}</p>

                <p><strong>Quality Dimensions Assessment:</strong></p>
                <table>
                    <tr><th>Dimension</th><th>Score</th><th>Grade</th><th>Impact</th></tr>
                    <tr style="background-color: ${getQualityColor(quality.completeness)}">
                        <td>Completeness</td>
                        <td>${(quality.completeness * 100).toFixed(1)}%</td>
                        <td>${getQualityGrade(quality.completeness)}</td>
                        <td>${missingDataRate.toFixed(1)}% missing data</td>
                    </tr>
                    <tr style="background-color: ${getQualityColor(quality.accuracy)}">
                        <td>Accuracy</td>
                        <td>${(quality.accuracy * 100).toFixed(1)}%</td>
                        <td>${getQualityGrade(quality.accuracy)}</td>
                        <td>${errorRate.toFixed(1)}% error rate</td>
                    </tr>
                    <tr style="background-color: ${getQualityColor(quality.consistency)}">
                        <td>Consistency</td>
                        <td>${(quality.consistency * 100).toFixed(1)}%</td>
                        <td>${getQualityGrade(quality.consistency)}</td>
                        <td>${duplicateRate.toFixed(1)}% duplicates</td>
                    </tr>
                    <tr style="background-color: ${getQualityColor(quality.timeliness)}">
                        <td>Timeliness</td>
                        <td>${(quality.timeliness * 100).toFixed(1)}%</td>
                        <td>${getQualityGrade(quality.timeliness)}</td>
                        <td>Recording delays minimal</td>
                    </tr>
                </table>

                <p><strong>Overall Assessment:</strong></p>
                <p>‚Ä¢ <span class="highlight">Overall Quality Score: ${(overallQuality * 100).toFixed(1)}% (${getQualityGrade(overallQuality)})</span></p>
                <p>‚Ä¢ Outlier rate: ${outlierRate.toFixed(1)}%</p>
                <p>‚Ä¢ Data usability: ${overallQuality > 0.85 ? 'High - suitable for analysis' : overallQuality > 0.70 ? 'Moderate - needs cleaning' : 'Low - extensive validation required'}</p>
                
                <p><strong>Privacy and Ethics Assessment:</strong></p>
                <p>‚Ä¢ Re-identification risk: ${reidentificationRisk}</p>
                <p>‚Ä¢ Recommended privacy measures: ${getPrivacyMeasures(dataset, reidentificationRisk)}</p>
                <p>‚Ä¢ Ethics compliance: ${getEthicsCompliance(dataset)}</p>
                <p>‚Ä¢ Data sharing restrictions: ${getDataSharing(dataset)}</p>

                <p><strong>Recommendations:</strong></p>
                ${getQualityRecommendations(quality, issuesSelected).map(rec => `<p>‚Ä¢ ${rec}</p>`).join('')}
            `;

            createQualityChart(quality, issuesSelected);
        }

        function getQualityColor(score) {
            if (score >= 0.9) return '#e8ffe8';
            if (score >= 0.8) return '#fffacd';
            if (score >= 0.7) return '#ffe8e8';
            return '#ffcccc';
        }

        function getQualityGrade(score) {
            if (score >= 0.95) return 'Excellent';
            if (score >= 0.85) return 'Good';
            if (score >= 0.75) return 'Fair';
            return 'Poor';
        }

        function getPrivacyMeasures(dataset, risk) {
            const measures = {
                'clinical-trial': 'Standard de-identification, participant consent',
                'ehr': 'Expert determination method, secure environment',
                'registry': 'Safe Harbor method, data use agreements',
                'survey': 'Statistical disclosure control, aggregation'
            };
            return measures[dataset];
        }

        function getEthicsCompliance(dataset) {
            return dataset === 'clinical-trial' ? 'REB approval, informed consent' : 
                   'Privacy impact assessment, minimal risk determination';
        }

        function getDataSharing(dataset) {
            return dataset === 'clinical-trial' ? 'Trial registry requirements' :
                   'Provincial data sharing agreements required';
        }

        function getQualityRecommendations(quality, issues) {
            const recommendations = [];
            
            if (quality.completeness < 0.85) {
                recommendations.push('Implement missing data imputation strategies');
            }
            if (quality.accuracy < 0.85) {
                recommendations.push('Enhance data validation rules and training');
            }
            if (quality.consistency < 0.85) {
                recommendations.push('Standardize coding practices across sites');
            }
            if (issues.includes('outliers')) {
                recommendations.push('Develop clinical review process for extreme values');
            }
            if (issues.includes('duplicates')) {
                recommendations.push('Implement automated duplicate detection algorithms');
            }
            
            return recommendations.length > 0 ? recommendations : ['Data quality is acceptable for intended analysis'];
        }

        function createQualityChart(quality, issues) {
            const ctx = document.getElementById('quality-chart').getContext('2d');
            
            if (charts.quality) charts.quality.destroy();

            charts.quality = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Completeness', 'Accuracy', 'Consistency', 'Timeliness'],
                    datasets: [{
                        label: 'Quality Scores',
                        data: [
                            quality.completeness * 100,
                            quality.accuracy * 100,
                            quality.consistency * 100,
                            quality.timeliness * 100
                        ],
                        borderColor: '#2f8b8b',
                        backgroundColor: 'rgba(47, 139, 139, 0.3)',
                        borderWidth: 3,
                        pointBackgroundColor: '#2f8b8b',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: '#2f8b8b'
                    }, {
                        label: 'Target Quality (90%)',
                        data: [90, 90, 90, 90],
                        borderColor: '#dc143c',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Data Quality Assessment Radar Chart'
                        }
                    },
                    scales: {
                        r: {
                            angleLines: {
                                display: false
                            },
                            suggestedMin: 0,
                            suggestedMax: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Section 9: Healthcare Performance Dashboard
        function generatePerformanceDashboard() {
            const region = document.getElementById('health-region').value;
            const metric = document.getElementById('performance-metric').value;
            const year = parseInt(document.getElementById('reporting-year').value);

            const regionNames = {
                toronto: 'Toronto Central LHIN',
                vancouver: 'Vancouver Coastal Health',
                montreal: 'CISSS Montr√©al',
                calgary: 'Alberta Health Services - Calgary'
            };

            const metricInfo = {
                'wait-times': {
                    name: 'Surgical Wait Times',
                    unit: 'weeks',
                    target: 26,
                    categories: ['Hip Replacement', 'Knee Replacement', 'Cardiac Surgery', 'Cancer Surgery', 'Cataract Surgery']
                },
                'ed-visits': {
                    name: 'Emergency Department Performance',
                    unit: 'hours',
                    target: 4,
                    categories: ['CTAS 1', 'CTAS 2', 'CTAS 3', 'CTAS 4', 'CTAS 5']
                },
                'readmissions': {
                    name: 'Hospital Readmission Rates',
                    unit: '%',
                    target: 8.5,
                    categories: ['Medical', 'Surgical', 'Obstetric', 'Psychiatric', 'Pediatric']
                },
                'patient-experience': {
                    name: 'Patient Experience Scores',
                    unit: '/10',
                    target: 8.0,
                    categories: ['Communication', 'Pain Management', 'Discharge Planning', 'Care Coordination', 'Overall Rating']
                }
            };

            const currentMetric = metricInfo[metric];
            
            // Generate performance data
            const performanceData = currentMetric.categories.map(category => {
                let value;
                if (metric === 'patient-experience') {
                    value = 6.5 + Math.random() * 3; // 6.5-9.5 scale
                } else if (metric === 'readmissions') {
                    value = 5 + Math.random() * 8; // 5-13%
                } else if (metric === 'ed-visits') {
                    value = 2 + Math.random() * 6; // 2-8 hours
                } else {
                    value = 15 + Math.random() * 25; // 15-40 weeks
                }
                
                const meetingTarget = metric === 'patient-experience' ? value >= currentMetric.target :
                                   metric === 'readmissions' ? value <= currentMetric.target :
                                   metric === 'wait-times' ? value <= currentMetric.target :
                                   value <= currentMetric.target;

                return {
                    category: category,
                    value: value,
                    target: currentMetric.target,
                    meeting: meetingTarget,
                    trend: Math.random() > 0.5 ? 'improving' : 'stable'
                };
            });

            // Calculate summary statistics
            const avgPerformance = performanceData.reduce((sum, d) => sum + d.value, 0) / performanceData.length;
            const targetsMet = performanceData.filter(d => d.meeting).length;
            const percentTargetsMet = (targetsMet / performanceData.length) * 100;
            
            // Regional comparison (simulated)
            const regionalAvg = avgPerformance * (0.9 + Math.random() * 0.2);
            const nationalAvg = avgPerformance * (0.95 + Math.random() * 0.1);

            document.getElementById('system-results').style.display = 'block';
            document.getElementById('system-results').innerHTML = `
                <h4>Healthcare Performance Dashboard</h4>
                <h5>${regionNames[region]} - ${currentMetric.name} (${year})</h5>
                
                <p><strong>Performance Summary:</strong></p>
                <table>
                    <tr><th>Category</th><th>Current (${currentMetric.unit})</th><th>Target (${currentMetric.unit})</th><th>Status</th><th>Trend</th></tr>
                    ${performanceData.map(d => `
                        <tr style="background-color: ${d.meeting ? '#e8ffe8' : '#ffe8e8'}">
                            <td>${d.category}</td>
                            <td>${d.value.toFixed(1)}</td>
                            <td>${d.target.toFixed(1)}</td>
                            <td>${d.meeting ? '‚úì Met' : '‚úó Not Met'}</td>
                            <td>${d.trend === 'improving' ? '‚Üó' : '‚Üí'}</td>
                        </tr>
                    `).join('')}
                </table>

                <p><strong>Key Performance Indicators:</strong></p>
                <p>‚Ä¢ <span class="highlight">Targets achieved: ${targetsMet}/${performanceData.length} (${percentTargetsMet.toFixed(0)}%)</span></p>
                <p>‚Ä¢ Regional average: ${avgPerformance.toFixed(1)} ${currentMetric.unit}</p>
                <p>‚Ä¢ Provincial average: ${regionalAvg.toFixed(1)} ${currentMetric.unit}</p>
                <p>‚Ä¢ National benchmark: ${nationalAvg.toFixed(1)} ${currentMetric.unit}</p>

                <p><strong>Quality Improvement Priorities:</strong></p>
                ${getImprovementPriorities(performanceData, metric).map(priority => `<p>‚Ä¢ ${priority}</p>`).join('')}

                <p><strong>Resource Allocation Insights:</strong></p>
                <p>‚Ä¢ Performance relative to targets: ${getResourceAllocation(percentTargetsMet)}</p>
                <p>‚Ä¢ Recommended focus areas: ${getFocusAreas(performanceData, metric)}</p>
                <p>‚Ä¢ Estimated budget impact: ${getBudgetImpact(metric, avgPerformance)}</p>

                <p><strong>Healthcare System Context:</strong></p>
                <p>‚Ä¢ Population served: ~${getPopulationServed(region).toLocaleString()}</p>
                <p>‚Ä¢ Healthcare spending per capita: CAD $${getSpendingPerCapita(region)}</p>
                <p>‚Ä¢ Provider capacity: ${getProviderCapacity(region)}</p>
            `;

            createSystemChart(performanceData, currentMetric);
        }

        function getImprovementPriorities(data, metric) {
            const unmetTargets = data.filter(d => !d.meeting);
            if (unmetTargets.length === 0) {
                return ['All targets currently met - focus on maintaining performance'];
            }
            
            return unmetTargets.map(target => 
                `${target.category}: current ${target.value.toFixed(1)} vs target ${target.target.toFixed(1)}`
            );
        }

        function getResourceAllocation(percentMet) {
            if (percentMet >= 80) return 'Good performance - maintain current resources';
            if (percentMet >= 60) return 'Moderate performance - targeted resource reallocation needed';
            return 'Poor performance - significant resource investment required';
        }

        function getFocusAreas(data, metric) {
            const worst = data.sort((a, b) => {
                if (metric === 'patient-experience') return a.value - b.value;
                return b.value - a.value;
            })[0];
            
            return `${worst.category} (highest priority improvement area)`;
        }

        function getBudgetImpact(metric, avgValue) {
            const impacts = {
                'wait-times': `CAD $${(avgValue * 50000).toLocaleString()} in delayed care costs`,
                'ed-visits': `CAD $${(avgValue * 100000).toLocaleString()} in overcapacity costs`,
                'readmissions': `CAD $${(avgValue * 75000).toLocaleString()} in preventable readmissions`,
                'patient-experience': `Patient satisfaction affects ${(10 - avgValue) * 5}% of performance funding`
            };
            return impacts[metric];
        }

        function getPopulationServed(region) {
            const populations = {
                toronto: 1200000,
                vancouver: 850000,
                montreal: 950000,
                calgary: 750000
            };
            return populations[region];
        }

        function getSpendingPerCapita(region) {
            return Math.floor(4500 + Math.random() * 1500); // CAD 4500-6000
        }

        function getProviderCapacity(region) {
            const capacities = {
                toronto: 'High - major academic center',
                vancouver: 'High - regional referral center',
                montreal: 'Moderate - francophone services',
                calgary: 'Moderate - growing population demands'
            };
            return capacities[region];
        }

        function createSystemChart(data, metricInfo) {
            const ctx = document.getElementById('system-chart').getContext('2d');
            
            if (charts.system) charts.system.destroy();

            charts.system = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.map(d => d.category),
                    datasets: [{
                        label: `Current Performance (${metricInfo.unit})`,
                        data: data.map(d => d.value),
                        backgroundColor: data.map(d => d.meeting ? 'rgba(47, 139, 139, 0.8)' : 'rgba(220, 20, 60, 0.8)'),
                        borderColor: data.map(d => d.meeting ? '#2f8b8b' : '#dc143c'),
                        borderWidth: 2
                    }, {
                        label: `Target (${metricInfo.unit})`,
                        data: data.map(d => d.target),
                        type: 'line',
                        borderColor: '#ffd93d',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        pointRadius: 6,
                        pointStyle: 'triangle',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${metricInfo.name}: Performance vs Targets`
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Service Categories'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${metricInfo.name} (${metricInfo.unit})`
                            }
                        }
                    }
                }
            });
        }

        // Foundation Assessment Questions
        const foundationQuestionPools = {
            means: [
                {
                    question: "When analyzing a multi-center clinical trial where different sites have varying sample sizes, which measure of central tendency is most appropriate for the overall treatment effect?",
                    options: [
                        "Arithmetic mean of site-specific response rates",
                        "Weighted mean using sample sizes as weights",
                        "Geometric mean of response rates",
                        "Median response rate across sites"
                    ],
                    correct: 1,
                    explanation: "Weighted mean accounts for different sample sizes, giving more influence to larger, more precise studies in the overall estimate."
                },
                {
                    question: "For analyzing fold-changes in gene expression data from a genomics study, which measure of central tendency is most appropriate?",
                    options: [
                        "Arithmetic mean of fold-changes",
                        "Weighted mean by sample quality",
                        "Geometric mean of fold-changes",
                        "Median fold-change"
                    ],
                    correct: 2,
                    explanation: "Geometric mean is appropriate for multiplicative data like fold-changes, as it handles the multiplicative nature of the scale correctly."
                }
            ],
            missing: [
                {
                    question: "In a longitudinal study of elderly patients, younger patients are more likely to complete follow-up visits while health status is the actual predictor of outcomes. What type of missing data mechanism is this?",
                    options: [
                        "MCAR - the missingness is completely random",
                        "MAR - missingness depends on observed age, not unobserved health",
                        "NMAR - missingness depends on unobserved health status",
                        "This scenario cannot be classified without more information"
                    ],
                    correct: 1,
                    explanation: "This is MAR because missingness (follow-up completion) depends on an observed variable (age) but not on the unobserved outcome (health status after accounting for age)."
                },
                {
                    question: "A clinical trial has 15% missing outcome data due to patients dropping out when they feel worse (but this isn't recorded). What is the most appropriate analysis approach?",
                    options: [
                        "Complete case analysis since 15% missing is acceptable",
                        "Multiple imputation assuming MAR mechanism",
                        "Sensitivity analysis for NMAR mechanism",
                        "Simple mean imputation for missing values"
                    ],
                    correct: 2,
                    explanation: "When patients drop out due to unobserved worsening (NMAR), sensitivity analysis is needed to assess how different assumptions about the missing data affect conclusions."
                }
            ],
            rates: [
                {
                    question: "Province A has 150 new diabetes cases per 100,000 population per year. Province B has 120 cases per 100,000. What is the relative risk of diabetes in Province A compared to Province B?",
                    options: [
                        "1.25 - Province A has 25% higher risk",
                        "0.80 - Province A has 20% lower risk", 
                        "30 - Province A has 30 more cases per 100,000",
                        "Cannot calculate without knowing population sizes"
                    ],
                    correct: 0,
                    explanation: "Relative Risk = 150/120 = 1.25, meaning Province A has a 25% higher incidence rate than Province B."
                },
                {
                    question: "A disease has an incidence rate of 5 per 1,000 per year and case fatality rate of 10%. What is the mortality rate per 1,000 per year?",
                    options: [
                        "15 per 1,000 (5 + 10)",
                        "0.5 per 1,000 (5 √ó 0.10)",
                        "50 per 1,000 (5 √ó 10)",
                        "Cannot calculate without prevalence data"
                    ],
                    correct: 1,
                    explanation: "Mortality rate = Incidence rate √ó Case fatality rate = 5 per 1,000 √ó 0.10 = 0.5 per 1,000 per year."
                }
            ],
            confidence: [
                {
                    question: "A clinical trial reports a treatment effect of -8 mmHg (95% CI: -12 to -4). What can you conclude?",
                    options: [
                        "The treatment significantly reduces blood pressure",
                        "The treatment may increase blood pressure in some patients",
                        "The confidence interval is too wide to draw conclusions",
                        "More patients are needed to reach statistical significance"
                    ],
                    correct: 0,
                    explanation: "Since the 95% CI entirely excludes zero (-12 to -4), the treatment significantly reduces blood pressure (p < 0.05)."
                },
                {
                    question: "Two studies report the same treatment effect (6 mmHg reduction) but Study A has CI [2, 10] and Study B has CI [4, 8]. What does this indicate?",
                    options: [
                        "Study A has better methodology than Study B",
                        "Study B has higher precision (narrower CI)",
                        "Study A has higher power than Study B",
                        "Both studies are equally reliable"
                    ],
                    correct: 1,
                    explanation: "Study B has a narrower confidence interval (4 mmHg width vs 8 mmHg), indicating higher precision, typically from larger sample size or less variability."
                }
            ]
        };

        function generateFoundationQuestions() {
            currentFoundationQuestions = [];
            const pools = Object.keys(foundationQuestionPools);
            
            // Select one question from each pool
            pools.forEach(pool => {
                const questions = foundationQuestionPools[pool];
                const randomQ = questions[Math.floor(Math.random() * questions.length)];
                currentFoundationQuestions.push(randomQ);
            });

            displayFoundationQuestions();
        }

        function displayFoundationQuestions() {
            const container = document.getElementById('foundation-questions-container');
            let html = '';
            
            currentFoundationQuestions.forEach((q, index) => {
                // Shuffle answer options
                const shuffledOptions = [...q.options];
                const correctAnswer = shuffledOptions[q.correct];
                
                for (let i = shuffledOptions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                }
                
                const newCorrectIndex = shuffledOptions.indexOf(correctAnswer);
                
                html += `
                    <div class="question">
                        <h4>Question ${index + 1}</h4>
                        <p><strong>${q.question}</strong></p>
                        ${shuffledOptions.map((option, i) => `
                            <label>
                                <input type="radio" name="fq${index}" value="${i}" data-correct="${i === newCorrectIndex}">
                                ${String.fromCharCode(65 + i)}. ${option}
                            </label><br>
                        `).join('')}
                    </div>
                `;
            });
            
            container.innerHTML = html;
            document.getElementById('foundation-check-btn').style.display = 'block';
        }

        function checkFoundationAnswers() {
            let correct = 0;
            let total = currentFoundationQuestions.length;
            let results = '<h4>Foundation Assessment Results</h4>';
            
            currentFoundationQuestions.forEach((q, index) => {
                const selected = document.querySelector(`input[name="fq${index}"]:checked`);
                const isCorrect = selected && selected.dataset.correct === 'true';
                
                if (isCorrect) correct++;
                
                results += `
                    <p><strong>Question ${index + 1}:</strong> ${isCorrect ? '‚úì Correct' : '‚úó Incorrect'}</p>
                    <p><em>Explanation:</em> ${q.explanation}</p>
                `;
            });
            
            const percentage = (correct / total * 100).toFixed(1);
            results = `<p><strong>Score: ${correct}/${total} (${percentage}%)</strong></p>` + results;
            
            if (correct === total) {
                results += '<p><span style="color: #2f8b8b; font-weight: bold;">üéì Excellent! You have mastered the foundational concepts in medical statistics!</span></p>';
            } else if (correct >= total * 0.8) {
                results += '<p><span style="color: #2f8b8b; font-weight: bold;">üëç Good work! Review the explanations for areas of improvement.</span></p>';
            }
            
            document.getElementById('foundation-assessment-results').innerHTML = results;
        }

        // Initialize the tool
        window.onload = function() {
            generateFoundationQuestions();
            // Initialize first section
            showSection('means');
        };
    </script>
</body>
</html>
